var documenterSearchIndex = {"docs":
[{"location":"Optimization/优化问题1/#优化问题1","page":"-","title":"优化问题1","text":"","category":"section"},{"location":"Optimization/优化问题1/#.基本信息","page":"-","title":"1.基本信息","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"地点：","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"新疆哈密\n气象数据","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"系统：","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"离网系统：不连接电网","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"系统组件：","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"- 电源：光伏\r\n- 热源：热泵\r\n- 氢能：电解水制氢+储氢罐+燃料电池发电","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"系统结构参考文献  (见wolai  https://www.wolai.com/6DDLR3UZQMS1M4bK2tctXg)","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"- 在此基础上，增加热泵用于提供热负荷\r\n\n  [热泵COP计算](https://www.wolai.com/efiXSi9XbcmhtkPWavNq4r)","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"负荷：某小区的热/电负荷","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"年度总电负荷EL：794.13 MWh\n年度总热负荷HL：1749.26 MWh","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"(Image: img)","category":"page"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"小时负荷文件（kWh）：(详情见 wolai https://www.wolai.com/6DDLR3UZQMS1M4bK2tctXg  有相关excel附件)","category":"page"},{"location":"Optimization/优化问题1/#.能源系统建模","page":"-","title":"2.能源系统建模","text":"","category":"section"},{"location":"Optimization/优化问题1/#系统设计","page":"-","title":"系统设计","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"描述负荷场景，能源系统结构与运行方式","category":"page"},{"location":"Optimization/优化问题1/#组件模型","page":"-","title":"组件模型","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"详细介绍各组件的计算模型","category":"page"},{"location":"Optimization/优化问题1/#.优化问题建模","page":"-","title":"3.优化问题建模","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"优化问题概述，并使用数学语言描述优化问题","category":"page"},{"location":"Optimization/优化问题1/#优化变量","page":"-","title":"优化变量","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"变量名称，类型，变量域","category":"page"},{"location":"Optimization/优化问题1/#优化目标","page":"-","title":"优化目标","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"优化目标函数计算方法","category":"page"},{"location":"Optimization/优化问题1/#约束条件","page":"-","title":"约束条件","text":"","category":"section"},{"location":"Optimization/优化问题1/","page":"-","title":"-","text":"能量守恒、物理设备约束等","category":"page"},{"location":"#study-note-个人学习文档分享空间","page":"Home","title":"study-note 个人学习文档分享空间","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"#内容","page":"Home","title":"内容","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dirs = [\"Optimization,'Pages' \"]\n\"总篇数：$(sum(map(file -> length(readdir(joinpath(@__DIR__,\"..\",\"src\",file))), dirs)))\"","category":"page"},{"location":"#优化","page":"Home","title":"优化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Optimization\", file), readdir(\"Optimization\"))","category":"page"},{"location":"#前端","page":"Home","title":"前端","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Front-end\", file), readdir(\"Front-end\"))","category":"page"},{"location":"Front-end/前端笔记/#前端笔记","page":"前端笔记","title":"前端笔记","text":"","category":"section"},{"location":"Front-end/前端笔记/#.说说console","page":"前端笔记","title":"0.说说console","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"console语法     console是前端开发人员经常使用的调试工具，可以在控制台输出各种信息，以便快速地调试JavaScript代码。console语法与使用方法是入门前端开发中的必备技能之一。在本文中，将分步骤阐述console语法的基本知识。     1. console.log()         console.log()是console语法中最常用的方法。它可以在控制台输出任何类型的变量，如字符串、数字、数组、对象等。例如，下面的代码演示了如何使用console.log()方法输出一个字符串变量：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"const greeting = \"Hello World!\";\r\nconsole.log(greeting);\r\n    ```\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"当我们运行这段代码时，控制台将输出字符串\"Hello World!\"。通过console.log()方法，我们可以在控制台查看程序运行时的变量值，以便有效地调试代码。\r\n2. console.error()\r\nconsole.error()可以在控制台输出错误信息。它的输出会被标记为红色，以便开发者快速地定位问题。例如，下面的代码演示了如何使用console.error()方法输出一个错误信息：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\nconst num1 = 10;\r\nconst num2 = \"ABC\";\r\nif (isNaN(num1) || isNaN(num2)) {\r\n  console.error(\"One or both variables are not numbers!\");\r\n}\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"当我们运行这段代码时，控制台将输出错误信息\"One or both variables are not numbers!\"。通过使用console.error()方法，我们可以迅速识别程序中的错误，并排除故障。\r\n3. console.warn()\r\nconsole.warn()可以在控制台上输出警告信息，以便开发者识别可能存在的问题，但不一定需要处理。例如，下面的代码演示了如何使用console.warn()方法：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\nconst array = [1, 2, 3];\r\nconst index = 3;\r\nif (index > array.length - 1) {\r\n  console.warn(\"Index out of range!\");\r\n}\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"在这个例子中，当我们运行这段代码时，控制台会在index超出array长度范围时输出警告信息\"Index out of range!\"。通过使用console.warn()方法，我们可以识别问题并采取适当的行动，以避免产生更严重的后果。\r\n4. console.group()\r\nconsole.group()可用于将控制台信息分组显示，并便于开发者快速识别不同部分的输出。例如，下面的代码演示了如何使用console.group()方法：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\nconsole.group(\"UI Components\");\r\nconsole.log(\"Header\");\r\nconsole.log(\"Navigation Bar\");\r\nconsole.groupEnd();\r\n    console.group(\"Functions\");\r\nconsole.log(\"CalculateTax()\");\r\nconsole.log(\"CalculateInterest()\");\r\nconsole.groupEnd();\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"在这个例子中，控制台中的输出将分成两个组：一个是UI组件，另一个是函数。通过使用console.group()方法，我们可以让控制台输出更整洁，并增强代码的可读性。\r\n总之，console语法是前端开发的重要组成部分，学习和掌握它可以帮助我们更快地、更高效地调试代码。通过本文的介绍，我们了解了console语法中常用的一些方法和用法，包括console.log()、console.error()、console.warn()和console.group()。当我们在开发JavaScript应用程序时，应该善于利用这些工具来使我们的代码更加健壮和可靠。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 1.ES （EcmaScript）\r\n\r\n简介：脚本语言的规范。javascript是ES的一种实现。1.语法简洁2.框架开发应用3.前端开发职位要求\r\n\r\n\r\n\r\n\r\n\r\nES6前端发展趋势，就业必备技能\r\n\r\n\r\n\r\n## 2.JavaScript\r\n\r\n语法大全网站地址： https://blog.csdn.net/qq_51657072/article/details/128831333\r\n\r\nconst ——设置常量\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript ##JavaScript const todos=[ {     id:1,     text:\"go on\",     isCompleted : true, }, {     id:2,     text:\"fly away\",     isCompleted : true, }, {     id:3,     text:\"try it out\",     isCompleted : true, }, ]; const todoJSON = JSON.stringify(todos) for (let todo of todos){ console.log(todo.text); } alert(\"验证正确\");//弹窗显示 document.write(todos[0].text);//网页显示","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!–html里注释是这样写的–> /js和css里的多行注释这样写/ //单行注释","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n### 正则表达\r\n\r\n1.限定符 ？ *  + {...}\r\n\r\n2.或 |运算符\r\n\r\n3.字符类 元字符\r\n\r\n4.贪婪与懒惰匹配\r\n\r\n\r\n\r\n正则表达表单网站：\r\n\r\nhttps://r2coding.com/#/README?id=%e5%b8%b8%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e7%a4%ba%e4%be%8b\r\n\r\n\r\n\r\n\r\n\r\n## 3.Vue2笔记\r\n\r\nnodejs\r\n\r\nnode express\r\n\r\nwebpack\r\n\r\n### 1.Vue核心+组件化编程\r\n\r\n#### 1.初识Vue：\r\n\r\n要点：\r\n\r\n1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\r\n\r\n2.root容器里的代码符合html规范，只不过混入了一些特殊得Vue语法\r\n\r\n3.root容器里的代码被称为[vue模版]\r\n\r\n4.容器和实例一一对应\r\n\r\n5.注意区分js表达式和js代码（语句）\r\n\r\n**表达式：**一个表达式会产生一个值，可以放在任何一个需要值的地方\r\n\r\n(1).a\r\n\r\n(2)a+b\r\n\r\n(3)demo(1)\r\n\r\n(4)x===y?'a':'b'    [三目表达式]\r\n\r\n**js代码（语句）**\r\n\r\n(1)if(){}\r\n\r\n(2)for(){}\r\n\r\n\r\n\r\n\r\n\r\n#### 2.模版语法\r\n\r\nv-bind ====>简写为   ：\r\n\r\nvue 模版语法有2大类：\r\n\r\n**1.插值语法：**\r\n\r\n功能：用于解析标签体内容\r\n\r\n写法：{{xxx}},xxx是js表达式，且可以直接读取到data中的所有属性。\r\n\r\n**2.指令语法：**\r\n\r\n功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）\r\n\r\n举例：v-bind:href=\"xxx\"或简写为  :href=\"xxx\"，xxx同样要写js表达式且可以直接读取到data中的所有属性\r\n\r\n备注：Vue中有很多的指令，且形式都是：v-????,此处我们只是拿v-bind举例子\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>模版语法</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id=\"root\">     <h1>插值语法</h1>     <h3>你好，{{name}}</h3>     <hr/>     <h1>指令语法</h1>     <a v-bind:href=\"school.url.toUpperCase()\">点我去百度</a>     <a :href=\"school.url\">点我又去百度</a>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">\r\nnew Vue({\r\n    el:\"#root\",\r\n    data:{\r\n        name:'chd',\r\n        school:{\r\n            name:\"chdchd\",\r\n            url:\"https://www.baidu.com/?tn=15007414_20_dg\"\r\n\n        }\r\n        \r\n    }\r\n})\r\n</script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 3.数据绑定\r\n\r\nVue中有2种数据绑定方式：\r\n\r\n1.单项绑定（v-bind）：数据只能从data流向页面。\r\n\r\n2.双向绑定（v-model）:数据不仅能从data流向页面，还能从页面流向data\r\n\r\n备注：\r\n\r\n​\t1.双向绑定一般都应用在表单类元素上（如：input、select等）\r\n\r\n​\t2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>数据绑定</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <!– 普通写法 –>         单项数据绑定：<input type=\"text\" v-bind:value=\"name\"><br/>         双项数据绑定：<input type=\"text\" v-model:value=\"name\"><br/>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    <!-- 简写 -->\r\n    单项数据绑定：<input type=\"text\" :value=\"name\"><br/>\r\n    双项数据绑定：<input type=\"text\" v-model=\"name\"><br/>\r\n    \r\n    <!-- 如下代码是错误的,因为v-model只能应用在表单类元素(输入类元素)上\r\n    <h2 v-model:x=\"name\">nihao</h2> -->\r\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</body>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             name:\"chd\"         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>     </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n\r\n\r\n#### 4.el与data的两种写法\r\n\r\ndata与el的2种写法\r\n\r\n##### 1.el有2种写法\r\n\r\n（1) new Vue时候配置el属性\r\n\r\n（2）先创建Vue实例，随后再通过vm.$mount('#root')指定el的值\r\n\r\n##### 2.data有两种写法\r\n\r\n（1）对象式\r\n\r\n（2）函数式\r\n\r\n如何选择：组件运用时要用函数式\r\n\r\n##### 3.一个重要的原则：\r\n\r\n由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <h1>你好，{{name}}</h1>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</body>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">\r\n    // const v = new Vue({\r\n    //     //el:'#root',//第一种写法\r\n    //     data:{\r\n    //         name:'chd'\r\n    //     }\r\n    // })\r\n    // console.log(v)\r\n    // v.$mount('#root')//第二种写法\r\n    // 定时器演示\r\n    // console.log(v)\r\n    // setTimeout(() => {\r\n    //     v.$mount('#root')\r\n    // },1000);\r\nnew Vue({\r\n    el:'#root',\r\n    // //data的第一种写法：对象式\r\n    // data:{\r\n    //     name:'hello'\r\n    // }\r\n    \r\n    //data的第二种写法：函数式（组件时必须使用）\r\n    data:function(){\r\n        console.log('@@@',this)\r\n        return{\r\n            name:'chhd'\r\n        }\r\n    }\r\n})\r\n</script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 5.理解MVVM\r\n\r\n**vue的设计受到了MVVM的启发**\r\n\r\n**MVVM模型：**\r\n\r\n1.M:模型（Model）:对应data中的数据\r\n\r\n2.V：试图（View）:模版\r\n\r\n3.VM：视图模型（ViewModel）:Vue实例对象\r\n\r\n**观察发现**\r\n\r\n1.data中所有的属性，最后都出现在vm上\r\n\r\n2.vm身上所有的属性，以及Vue原型上所有属性，在Vue模版中都可以直接使用\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <h1>学校名称：{{name}}</h1>         <h1>学校地址：{{address}}</h1>           <h1>测试一下1:{{1+1}}</h1>         <h1>测试一下1:{{_c}}</h1>         <!– VIEW –>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</body>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     vm = new Vue({//VIEWMODEL         el:'#root',         data:{             name:'hello',             address:'beijing' //MODEL         }     })     console.log(vm) </script>     </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 6.数据代理\r\n\r\n**1.回顾Object.defineProperty方法**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>回顾Object.defineProperty方法</title>     <!– <script type=\"text/javascript\" src=\"../js/vue.js\"></script> –> </head> <body>     <div id =\"root\">","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     let number =20     let person = {         name:'ss',         sex:'nan',","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"}\r\n\nObject.defineProperty(person,'age',{\r\n    // value:18,\r\n    // enumerable:true,//可枚举\r\n    // writable:true,//可修改\r\n    // configurable:true, //控制属性是否被删除 \r\n    \r\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\r\n    get:function(){\r\n        return number\r\n    },\r\n\n\n    //当有人修改person的age属性时，set函数（setter）就会被调用，且会收到修改的具体值\r\n    set(value){\r\n        console.log('sss',value)\r\n        number=value\r\n    }\r\n})  \r\nconsole.log(Object.keys(person))\r\nconsole.log(person)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n**2.何为数据代理**\r\n\r\n数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>何为数据代理</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <!– 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） –> <script type=\"text/javascript\">     let obj={x:100}     let obj2={y:200}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Object.defineProperty(obj2,'x',{\r\n  get(){\r\n    return obj.x\r\n  },\r\n  set(value){\r\n    obj.x = value\r\n  }\r\n  //简单来说就是通过改变obj2.x里的数改变了obj的x。这就是一个简单的数据代理\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script> </body>   </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n**3.Vue中的数据代理**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"数据代理就好比右图中的实线部分，实现的功能好比就是将data里的name和address放在vm里。这样在编写代码时更为方便，不用vm._data.name这样的写法，而直接vm.name即可。背后的逻辑也是实现了getter()和setter()的这样一个过程，也就是通过Object.defineProperty进行的实现。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n![image-20230803195743858](C:\\Users\\ccchhhddd\\Desktop\\image-20230803195743858.png)\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <h2>学校名称：{{name}}</h2>         <h2>学校地址：{{address}}</h2>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm =new Vue({         el:'#root',         data:{             name:'ccchhhddd',             address:'beijing'         }         //埋一个数据劫持的坑     }) </script>  </body>  </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 7.事件处理\r\n\r\n##### **1.事件的基本使用：**\r\n\r\n1.使用v-on：xxx 或 @xxx 绑定事件，其中xxx是事件名；\r\n\r\n2.事件的回调需要配置在methods对象中，最终会在vm上；\r\n\r\n3.methods中配置的函数，不要用箭头函数：否则this就不是vm了\r\n\r\n4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；\r\n\r\n5.@click=\"demo\" 和@click=\"demo\"($event)效果一致，但后者可以传参；\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <h2>{{name}}欢迎你</h2>         <button v-on:click=\"showInfo1\">点我提示信息（不传参）</button>         <button v-on:click=\"showInfo2(66,event)\">点我提示信息2（传参）</button>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"const vm=new Vue({\r\n    el:'#root',\r\n    data:{\r\n        name:'Beijing'\r\n    },\r\n    methods:{\r\n        showInfo1(event){\r\n            console.log(event.target)\r\n            alert('nihao')\r\n        },\r\n        showInfo2(number,event){//最好别放在data里，会进行无意义的数据代理，这个东西只是用来被别人调用的\r\n            console.log(number,event)\r\n            alert(number)\r\n        }\r\n    }\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body>  </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n**补充概念：JavaScript事件的冒泡**\r\n\r\n##### 事件冒泡的概念\r\n\r\n事件冒泡是指当一个元素触发了某个事件（例如点击事件），该事件将从最内层的元素开始，逐级向外传播到父元素，直到传播到文档根节点。这种事件传播的过程就是事件冒泡。\r\n\r\n##### 事件冒泡的处理方式\r\n\r\n在处理事件冒泡时，有两种常用的方式：停止事件冒泡和使用事件委托。\r\n\r\n##### 停止事件冒泡\r\n\r\n通过停止事件冒泡，可以阻止事件继续向父元素传播。在事件处理函数中，可以使用event.stopPropagation()方法来停止事件冒泡。调用该方法后，事件将不再传播到父元素。\r\n\r\n\r\n\r\n##### 2.事件修饰符\r\n\r\nvue中的事件修饰符：\r\n\r\n1.prevent:阻止默认事件（常用）\r\n\r\n2.stop:阻止事件冒泡（常用）\r\n\r\n3.once:事件只触发一次（常用）\r\n\r\n4.capture：使用事件的捕获模式 \r\n\r\n5.self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生\r\n\r\n6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script>     <style>         /*  通配符*  */         *{             margin-top :20px;         }         .demo1{             height: 50px;             background-color: aqua;         }         .box1{             padding: 5px;             background-color: skyblue;         }         .box2{             padding: 5px;             background-color: orange;         }         .list{             width:200px;             height: 200px;             background-color: peru;             overflow: auto;         }         li{            height: 100px;          }     </style>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</head> <body>     <div id =\"root\">         <!– prevent:阻止默认事件（常用） –>         <a href=\"https://www.baidu.com/?tn=1500741420dg\" @click.prevent=\"showInfo\">点击去{{name}}</a>         <!–stop:阻止事件冒泡（常用） –>     <div class=\"demo1\" @click.self=\"showInfo\">         <button @click.stop=\"showInfo\">点点试试</button>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!--once:事件只触发一次（常用）  -->\r\n<button @click.once=\"showInfo\">点点试试</button>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</br>     <!– capture：使用事件的捕获模式 –>     <div class=\"box1\" @click.capture=\"showMsg(1)\">         div1         <div class=\"box2\" @click=\"showMsg(2)\">         div2            </div>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!-- self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生 -->\r\n<div class=\"demo1\" @click.self=\"showInfo\">\r\n<button @click=\"showInfo\">点点试试</button>\r\n</div>\r\n<!-- passive:事件的默认行为立即执行，无需等待事件回调执行完毕 -->\r\n<ul @wheel.passive=\"demo\" class=\"list\">\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n</ul>\r\n\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             name:'百度'         },     methods:{         showInfo(e){             // e.stopPropagation()             alert('同学你好')             //console.log(e.target)         },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    showMsg(msg){\r\n        console.log(msg)\r\n    },\r\n    demo(){\r\n        for (let i=0;i<100000;i++){\r\n            console.log('#')\r\n        }\r\n        console.log('wanle')\r\n    }\r\n}\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body>  </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 3.键盘事件\r\n\r\n**1.vue中常用的按键别名：**\r\n\r\n回车=>enter\r\n\r\n删除=>delete(捕获“删除”和“退格键”)\r\n\r\n退出=>esc\r\n\r\n空格=>space\r\n\r\n换行=>tab\r\n\r\n上=>up\r\n\r\n下=>down\r\n\r\n左=>left\r\n\r\n右=>right\r\n\r\n**2.Vue未提供别名的按键，**可以使用按键原始的key值去绑定，但注意要转为kebab-case(短横线命名)\r\n\r\n\r\n\r\n**3.系统修饰键（用法特殊）**：ctrl、alt、shift、meta\r\n\r\n​\t(1)配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发\r\n\r\n（2）配合keydown使用：正常触发事件\r\n\r\n\r\n\r\n**4.也可以使用keyCode去指定具体的按键（不推荐）**\r\n\r\n**5.Vue.config.keyCodes.自定义键名=键码，可以去定制按键别名** （  直接关机键绑事件  【狗头】）\r\n\r\n\r\n\r\n##### 4.事件总结\r\n\r\n修饰符可以连写\r\n\r\n例如：@keyup.ctrl.y   或者@click.stop.prevent\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n#### 8.计算属性\r\n\r\n**计算属性：**\r\n\r\n1.定义：要用的属性不存在，要通过已有属性计算得来\r\n\r\n2.原理：底层借助了Object.defineproperty方法提供的getter和setter\r\n\r\n3.get函数什么时候执行？\r\n\r\n（1）初次读取时会执行一次\r\n\r\n（2）当依赖的数据发生变化时会被再次调用\r\n\r\n4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\r\n\r\n5.备注：\r\n\r\n​\t1.计算属性最终会出现在vm上，直接读取使用即可\r\n\r\n​\t2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\r\n\r\n​\t\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         姓：<input type=\"text\" v-model=\"firstname\"><br/><br/>         名：<input type=\"text\" v-model=\"lastname\"><br/><br/>         测试：<input type=\"text\" v-model=\"x\"><br/><br/>         姓名：<span>{{fullname}}</span><br/><br/>         姓名：<span>{{fullname}}</span><br/><br/>         姓名：<span>{{fullname}}</span><br/><br/>         姓名：<span>{{fullname}}</span><br/><br/>         姓名：<span>{{fullname}}</span>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm = new Vue({         el:'#root',         data:{             firstname:'张',             lastname:'三',             x:'你好'         },         computed:{             fullname:{             //get有什么作用？当有人读取fullname时，get就会被调用，且返回值就作为fullname的值             //get什么时候调用？1.初次读取fullname时2.所依赖的数据发生变化时             get() {                 console.log('get被调用')                 //console.log(this)//此处的this=vm                 return this.firstname +'-'+ this.lastname             },             //set什么时候调用？当fullName被修改时             set(value){                 console.log('set被调用',value)                     const arr = value.split('-')                 this.firstname = arr[0]                 this.lastname = arr[1]             }              }         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 9.监视属性\r\n\r\n##### 1.监视属性watch:\r\n\r\n1.当被监视的属性变化时，回调函数自动调用，进行相关操作\r\n\r\n2.监视的属性必须存在，才能进行监视\r\n\r\n3.监视的两种写法;\r\n\r\n（1）new Vue时传入watch配置\r\n\r\n（2）通过vm.$watch监视\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>今天天气很{{info}}</h2>        <button @click=\"cw\">切换天气</button>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm = new Vue({         el:'#root',         data:{             isHot:true,         },         computed:{             info(){                 return this.isHot ?'炎热':'凉爽'             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视的两个方法         // watch:{         //     isHot:{         //     immediate:true,//初始化时让handler调用一下         //     //handler什么时候调用？当isHot发生改变时。         //     handler(newvalue,oldvalue){         //         console.log('info被修改了',newvalue,oldvalue)         //     }             //     }         // }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"})\r\nvm.$watch('isHot',{\r\n    immediate:true,//初始化时让handler调用一下\r\n        //handler什么时候调用？当isHot发生改变时。\r\n        handler(newvalue,oldvalue){\r\n            console.log('info被修改了',newvalue,oldvalue)\r\n        } \r\n\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 2.深度监视\r\n\r\n**要点：**\r\n\r\n（1）Vue中的watch默认不监测对象内部值的改变（一层）\r\n\r\n（2）配置deep:true可以监测对象内部值改变（多层）\r\n\r\n**注：**\r\n\r\n（1）Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以\r\n\r\n（2）使用watch时根据数据的具体结构。决定是否采用深度监测\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>今天天气很{{info}}</h2>        <button @click=\"cw\">切换天气</button>     <hr/>     <h3>a的值是:{{numbers.a}}</h3>     <button @click=\"numbers.a++\">点我让a+1</button>     <h3>a的值是:{{numbers.b}}</h3>     <button @click=\"numbers.b++\">点我让b+1</button>     <button @click=\"numbers = {a:666,b:888}\">彻底更换numbers</button>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm = new Vue({         el:'#root',         data:{             isHot:true,             numbers:{              a:1,              b:1               }         },         computed:{             info(){                 return this.isHot ?'炎热':'凉爽'             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视有两个方法         //方法一         watch:{             isHot:{             immediate:true,//初始化时让handler调用一下             //handler什么时候调用？当isHot发生改变时。             handler(newvalue,oldvalue){                 console.log('info被修改了',newvalue,oldvalue)             }         },              // 监视多级结构中某个属性的变化               'numbers.a':{                 deep:true,                 handler(){                     console.log('a被改变了')                 }             }         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    //监视多级结构中所有属性的变化\r\n    // numbers:{\r\n    //         deep:true,\r\n    //         handler(){\r\n    //             console.log('numbers中有属性被改变了')\r\n    //         }\r\n    //     }   \r\n    // }\r\n    \r\n\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 3.监视属性_简写\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>今天天气很{{info}}</h2>        <button @click=\"cw\">切换天气</button>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm = new Vue({         el:'#root',         data:{             isHot:true,         },         computed:{             info(){                 return this.isHot ?'炎热':'凉爽'             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视有两个方法         //方法一         watch:{             // isHot:{             // //正常写法             // immediate:true,//初始化时让handler调用一下             // //handler什么时候调用？当isHot发生改变时。             // //deep:true ,//深度监视             // handler(newvalue,oldvalue){             //     console.log('info被修改了',newvalue,oldvalue)             //         }             //     }         //简写         // isHot(newvalue,oldvalue){         //     console.log(\"isHot被修改\",newvalue,oldvalue)         // }         }})         //正常写法         // vm.watch('isHot',{immediate:true,//初始化时让handler调用一下         //     // //handler什么时候调用？当isHot发生改变时。         //     // //deep:true ,//深度监视         //      handler(newvalue,oldvalue){         //          console.log('info被修改了',newvalue,oldvalue)         //              }         //          }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    // )\r\n    //简写 \r\n    vm.$watch('isHot',function(newvalue,oldvalue){\r\n        console.log('info被修改了',newvalue,oldvalue)\r\n    })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 4.计算属性和监视属性的区别（computed和watch）\r\n\r\n1.computed能完成的功能，watch都可以完成\r\n\r\n2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作\r\n\r\n\r\n\r\n##### **重要原则：**\r\n\r\n1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象\r\n\r\n2.所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数、promise回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。\r\n\r\n\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>姓名案例_watch实现</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         姓：<input type=\"text\" v-model=\"firstname\"><br/><br/>         名：<input type=\"text\" v-model=\"lastname\"><br/><br/>         姓名：<span>{{fullname}}</span><br/><br/>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm = new Vue({         el:'#root',         data:{             firstname:'张',             lastname:'三',             fullname:\"张-三\"//初始值需要自己设定         },         watch:{             firstname(newvalue){                 setTimeout(() => {//这个地方要写成箭头函数，括号里，没写东西，所以就往外找，this就指定为vm。否则指定为Windows，由js引擎帮忙调用                     this.fullname = newvalue +'-' +this.lastname                 }, 1000);","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"        },\r\n        lastname(newvalue){\r\n            this.fullname = this.firstname+'-' + newvalue\r\n        },\r\n        \r\n        }\r\n    }\r\n\n       \r\n    \r\n    \r\n)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 10.绑定样式\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <style>         .basic{             width: 400px;             height: 100px;             border: 1px solid black;         }         .sad{             border-color: green;             background-color: gray;         }         .happy{             border-color: red;             background-color: yellow;         }         .normal{             border-color: blue;             background-color: brown;         }         .chd1{             font-style: oblique;         }         .chd2{             font-size: 30px;                    }         .chd3{             border-color: skyblue;         }     </style>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <!– 绑定class样式–字符串写法，适用于：样式的类别不确定，需要动态指定 –>     <div class=\"basic\" :class=\"mood\" @click=\"change\">{{name}}</div>     </br></br>     <!– 绑定class样式–数组写法，适用于：适用于要样式个数不确定，名字也不确定 –>     <div class=\"basic\" :class=\"arr\" >{{name}}</div>     </br></br>     <!– 绑定class样式–数组写法，适用于：适用于要绑定样式个数确定，名字也确定，但要动态决定用不用 –>     <div class=\"basic\" :class=\"classobj\">{{name}}</div>     </br></br>     <!– 绑定style样式–对象写法 –>     <div class=\"basic\" :style=\"styleobj\">{{name}}</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     const vm=new Vue({         el:'#root',         data:{             name:'ccchhhddd',             mood:\"basic\",             arr:['chd1','chd2','chd3'],             classobj:{                 chd1:false,                 chd2:false,             },             styleobj:{                 fontSize:'40px',                 color: 'red',                 backgroundColor:'green'             }         },         methods: {             change(){                 const arr =['happy','sad','normal']                 const index = Math.floor(Math.random()*3)                 this.mood = arr[index]             }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    },\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 11.条件渲染\r\n\r\n##### **1.v-if**\r\n\r\n写法：\r\n\r\n（1）v-if=\"表达式\"\r\n\r\n（2）v-else-if=\"表达式\"\r\n\r\n（3）v-else=\"表达式\"\r\n\r\n适用于：切换频率较低的场景\r\n\r\n特点：不展示的DOM元素直接被移除\r\n\r\n注意：v-if可以和：v-else-if和v-else 一起使用。但要求结构不能被”打断“\r\n\r\n\r\n\r\n##### **2.v-show**\r\n\r\n写法：v-show=\"表达式\"\r\n\r\n适用于：切换频率较高的场景\r\n\r\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\r\n\r\n\r\n\r\n##### **3.备注:**\r\n\r\n使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <h2>当前的n值是:{{n}}</h2>         <button @click=\"n++\">点我n+1</button>         <!– 使用v-show做条件渲染 –>         <!– <h2 v-show=\"false\">欢迎来到{{name}}</h2>     –>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    <!-- 使用v-if做条件渲染 -->\r\n    <!-- <h2 v-if=\"false\">欢迎来到{{name}}</h2> -->\r\n\n    <!-- 注意： v-if和v-else-if这组结构中间不允许被打断 -->\r\n    <div v-if=\"n===1\">angular</div>\r\n    <div v-else-if=\"n===2\">react</div>\r\n    <div v-else-if=\"n===3\">Vue</div>\r\n    <div v-else>hhh</div>\r\n    \r\n\n    <!-- v-if和template的配合使用（不能和v-show） -->\r\n    <template v-if=\"n===1\">\r\n        <h2>你好</h2>\r\n        <h2>chd</h2>\r\n        <h2>hhh</h2>\r\n    </template>\r\n\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             name:'chd',             n:0         }     }) </script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 12.列表渲染\r\n\r\n##### 1.基本列表\r\n\r\n###### v-for指令：\r\n\r\n1.用于展示列表数据\r\n\r\n2.语法：v-for=\"(item,index) in xxx\" :key='yyy'\r\n\r\n3.可遍历：数组、对象、字符串、指定次数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">         <!– 遍历数组(用的最多) –>     <h2>人员列表</h2>     <ul>         <li v-for=\"(p,index) of persons\" :key=\"index\">             {{p.name}}-{{p.age}}         </li>     </ul>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!-- 遍历对象 -->\r\n<h2>汽车信息</h2>\r\n<ul>\r\n    <li v-for=\"(value,k) of car\" :key=\"k\">\r\n        {{k}}-{{value}}\r\n    </li>\r\n</ul>\r\n\r\n<!-- 遍历字符串 -->\r\n<h2>测试遍历字符串</h2>\r\n<ul>\r\n    <li v-for=\"(char,index) of str\" :key=\"index\">\r\n        {{index}}-{{char}}\r\n    </li>\r\n</ul>\r\n\n<!-- 遍历指定次数 -->\r\n<h2>测试遍历字符串</h2>\r\n<ul>\r\n    <li v-for=\"(number,index) of 5\" :key=\"index\">\r\n        {{index}}-{{number}}\r\n    </li>\r\n</ul>\r\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             persons:[                 {id:\"001\",name:'张三',age:18},                 {id:'002',name:'李四',age:19},                 {id:'003',name:'王五',age:20}             ],             car:{                 name:'奥迪A8',                 price:'70万',                 color:'red'             },             str:'hello'","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    }\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n\r\n\r\n##### 2.Vue面试重点题：vue中的key有什么作用？（key的内部原理）\r\n\r\n###### 1.虚拟DOM中key的作用：\r\n\r\n​\t\tkey是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\r\n\r\n\r\n\r\n###### 2.对比规则;\r\n\r\n(1)旧虚拟DOM 中找到了与新虚拟DOM相同的key:\r\n\r\n​\t\t1)若虚拟DOM中的内容没变，直接使用之前的真实DOM\r\n\r\n​\t\t2）若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM\r\n\r\n（2）旧虚拟DOM中未找到与新虚拟DOM相同的key:\r\n\r\n​\t\t创建新的真实DOM，随后渲染到页面\r\n\r\n\r\n\r\n###### 3.用index作为key可能会引发的问题：\r\n\r\n​\t\t1）若对数据进行：逆序添加、逆序删除等破坏顺序操作：\r\n\r\n​\t\t\t\t\t会产生没有必要的真实DOM更新===》 界面效果没问题，但效率低\r\n\r\n\r\n\r\n​\t\t2）如果结构中还包含输入类的DOM：\r\n\r\n​\t\t\t\t会产生错误DOM更新 ===》界面有问题\r\n\r\n\r\n\r\n###### 4.开发中如何选择key?\r\n\r\n​\t\t1.最好使用每条数据的唯一标识作为key,比如 id、手机号、身份证号、学号等唯一标识\r\n\r\n​\t\t2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。\r\n\r\n\r\n\r\n##### 3.列表过滤\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>列表过滤</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>人员列表</h2>     <input type=\"text\" placeholder=\"输入名字\" v-model=\"keyword\">     <ul>         <li v-for=\"(p,index) of filPersons\" :key=\"index\">             {{p.name}}-{{p.age}}-{{p.sex}}         </li>     </ul>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     // 用watch实现     // new Vue({     //     el:'#root',     //     data:{     //         keyword:'',     //         persons:[     //             {id:\"001\",name:'马冬梅',age:19,sex:'女'},     //             {id:'002',name:'周冬雨',age:20,sex:'女'},     //             {id:'003',name:'周杰伦',age:21,sex:'男'},     //             {id:'004',name:'温兆伦',age:22,sex:'男'},     //         ],     //         filPersons:[]","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//     },\r\n//     watch:{\r\n//         keyword:{\r\n//             immediate:true,\r\n//             handler(val){\r\n//                 this.filPersons = this.persons.filter((p)=>{\r\n//                 return p.name.indexOf(val) !==-1\r\n//             })\r\n            \r\n//         }\r\n//         }\r\n//     }\r\n// })\r\n\nnew Vue({\r\n    el:'#root',\r\n    data:{\r\n        keyword:'',\r\n        persons:[\r\n            {id:\"001\",name:'马冬梅',age:19,sex:'女'},\r\n            {id:'002',name:'周冬雨',age:20,sex:'女'},\r\n            {id:'003',name:'周杰伦',age:21,sex:'男'},\r\n            {id:'004',name:'温兆伦',age:22,sex:'男'},\r\n         ],\r\n    },\r\n    computed:{\r\n        filPersons(){\r\n           return this.persons.filter((p)=>{\r\n             return p.name.indexOf(this.keyword) !==-1   \r\n            })\r\n        }\r\n    }          \r\n    }\r\n)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 4.列表排序\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title>列表过滤</title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>人员列表</h2>     <input type=\"text\" placeholder=\"输入名字\" v-model=\"keyword\">     <button @click=\"sortType=2\">年龄升序</button>     <button @click=\"sortType=1\">年龄降序</button>     <button @click=\"sortType=0\">原顺序</button>     <ul>         <li v-for=\"(p,index) of filPersons\" :key=\"p.id\">             {{p.name}}-{{p.age}}-{{p.sex}}         </li>     </ul>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\"> // 列表排序用computed实现     new Vue({         el:'#root',         data:{             keyword:'',             sortType:0,//0原顺序，1降序，2升序             persons:[                 {id:\"001\",name:'马冬梅',age:12,sex:'女'},                 {id:'002',name:'周冬雨',age:11,sex:'女'},                 {id:'003',name:'周杰伦',age:28,sex:'男'},                 {id:'004',name:'温兆伦',age:50,sex:'男'},              ],         },         computed:{             filPersons(){                const arr= this.persons.filter((p)=>{                  return p.name.indexOf(this.keyword) !==-1                    })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"            if(this.sortType){\r\n                arr.sort((p1,p2)=>{\r\n                    return this.sortType ===1 ? p2.age-p1.age :p1.age-p2.age\r\n                })\r\n            }\r\n\n            return arr\r\n        }\r\n    }          \r\n    }\r\n)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 5.vue监测数据改变的原理\r\n\r\n\r\n\r\ndata里的每一项数据（包括细分的数据）都有对应的getter和setter,以这样的方式实现数据的监测和修改\r\n\r\n**如下图所示：**\r\n\r\n![image-20230808092841959](C:\\Users\\ccchhhddd\\Desktop\\image-20230808092841959.png)\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>学校名称：{{name}}</h2>     <h2>学校地址：{{address}}</h2>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\"> // 列表排序用computed实现     const vm =new Vue({         el:'#root',         data:{             name:'chd',             address:\"beijing\",             student:{                 name:'tom',                 age:{                     sage:20,                     tage:18                 }             }                     },                        }     ) </script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 6.Vue.set的使用\r\n\r\n**用法**：\r\n\r\n向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property\r\n\r\n (比如 `this.myObject.newProperty = 'hi'`)\r\n\r\n**注意：**\r\n\r\n对象不能是 Vue 实例，或者 Vue 实例的根数据对象。\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">     <h2>学校名称：{{name}}</h2>     <h2>学校地址：{{address}}</h2>     <hr/>     <h1>学生信息</h1>     <button @click=\"addsex\">添加一个性别信息</button>     <h2>学生姓名：{{student.name}}</h2>     <h2>学生年龄：真实{{student.age.rage}},对外{{student.age.sage}}</h2>     <h2 v-if=\"student.sex\">性别:{{student.sex}}</h2>     <h2>朋友们</h2>     <ul>         <li v-for=\"(f,index) in student.friends\" :key=\"index\">             {{f.name}}–-{{f.age}}         </li>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\"> // 列表排序用computed实现     const vm =new Vue({         el:'#root',         data:{             name:'chd',             address:\"beijing\",             student:{                 name:'tom',                 age:{                     sage:20,                     rage:18                 },                 friends:[                     {name:'eecc',age:30},                     {name:'eveve',age:14}                 ]","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"        }            \r\n    },\r\n    methods: {\r\n        addsex(){\r\n            Vue.set(this.student,'sex','男')\r\n            // this.$set(this.student,'sex','男')\r\n        }\r\n    },               \r\n    }\r\n)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 7.Vue监测数据改变的原理\r\n\r\nVue 将被侦听的数组的变更方法进行了**包裹**，所以它们也将会触发视图更新。这些被包裹过的方法包括：\r\n\r\n- `push()`\t\r\n- `pop()`\r\n- `shift()`\r\n- `unshift()`\r\n- `splice()`\r\n- `sort()`\r\n- `reverse()`\r\n\r\n你可以打开控制台，然后对前面例子的 `items` 数组尝试调用变更方法。比如 `example1.items.push({ message: 'Baz' })`\r\n\r\n\r\n\r\n##### 8.总结Vue数据监测\r\n\r\nVue监视数据的原理：\r\n\r\n**1.Vue会监视data中所有层次的数据**\r\n\r\n**2.如何监测对象的数据？**\r\n\r\n​\t通过setter实现监视，且要在new Vue时就传入要检测的数据\r\n\r\n（1）对象中后追加的属性，Vue默认不做响应式处理\r\n\r\n（2）如需给后添加的属性做响应式，请使用如下API:\r\n\t\t\tVue.set(targer,propertyName,value)或\r\n\r\n​\t\t\tvm.$set(target,propertyName/index,value)\r\n\r\n\r\n\r\n**3.如何监测数组中的数据？**\r\n\r\n​\t\t通过包裹数组更新元素的方法实现，本质就是做了两件事：\r\n\r\n​\t（1）调用原生对应的方法对数组进行更新\r\n\r\n​\t（2）重新解析模版，进行更新页面\r\n\r\n\r\n\r\n**4.在Vue修改数组中的某个元素一定要用如下方法：**\r\n\r\n​\t（1）使用这些API：push()  、pop() 、shift()  、unshift()  、splice()\r\n\r\n​\t\t(2)Vue.set()  或 vm.$set()\r\n\r\n\r\n\r\n**注意：**Vue.set() 和vm.$set() 不能给vm或vm的根数据对象 添加属性！！！\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue spilce() 的一个用法 this.student.hobby.splice(0,1,'xc') //Vue.set(this.student.hobby.0,'xc') //this.set(this.student.hobby,0,'xc')","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 13.收集表单数据\r\n\r\n**若：<input type='text'/>**则v-model收集的是value值。用户输入就是value的值\r\n\r\n**若：<input type='radio'/>**,则v-model收集的是value值，且要给标签配置value值\r\n\r\n**若：<input type='checkbox'/>**\r\n\r\n​\t1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是bool值）\r\n\r\n​\t2.v-model 的初始值是数组，那么收集的是value组成的数组\r\n\r\n**备注：v-model的三个修饰符：**\r\n\r\n​\tlazy:失去焦点再收集数据\r\n\r\n​\tnumber:输入字符串转为有效数字\r\n\r\n​\ttrim:输入收尾空格过滤\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <div id =\"root\">       <form @submit.prevent=\"demo\">","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    账号：<input type=\"text\" v-model.trim=\"userInfo.account\"><br/><br/>\r\n    密码：<input type=\"password\" v-model=\"userInfo.password\"><br/><br/>\r\n    年龄：<input type=\"number\" v-model.number=\"userInfo.age\"><br/><br/>\r\n    性别：\r\n    男<input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"male\">\r\n    女<input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"female\"><br/><br/>\r\n    爱好：\r\n    学习<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"study\">\r\n    打游戏<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"play\">\r\n    唱歌<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"sing\"><br/><br/>\r\n    所属校区\r\n    <select v-model=\"userInfo.city\">\r\n        <option value=\"\">请选择校区</option>\r\n        <option value=\"beijing\">北京</option>\r\n        <option value=\"shanghai\">上海</option>\r\n        <option value=\"nanjing\">深圳</option>\r\n    </select><br/><br/>\r\n    其他信息： \r\n    <textarea v-model.lazy=\"userInfo.other\"></textarea><br/><br/>\r\n    <input type=\"checkbox\" v-model=\"userInfo.agree\">阅读并接受<a href=\"http://www.baidu.com\">《用户协议》</a>\r\n    <button>提交</button>\r\n</form>\r\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             userInfo:{             account:'',             password:'',             sex:'',             age:'',             hobby:[],             city:'',             other:'',             agree:''         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    },\r\n    methods: {\r\n        demo(){\r\n           console.log(JSON.stringify(this.userInfo))\r\n        }\r\n    },\r\n})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 14.过滤器\r\n\r\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑得处理）\r\n\r\n语法:\r\n\r\n​\t1.注册过滤器： Vue.filter(name,callback) 或 new Vue(filters:{})\r\n\r\n​\t2.使用过滤器：{{ xxx | 过滤器名}}  或 v-bind: 属性 = ‘xxx |过滤器名’\r\n\r\n备注：\r\n\r\n​\t1.过滤器也可以接受额外参数，多个过滤器也可以串联\r\n\r\n​\t2.并没有改变原本的数据，是产生新的对应的数据\r\n\r\n\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script>     <script type=\"text/javascript\" src=\"../js/cdn.bootcdn.netajaxlibsdayjs1.11.7_dayjs.min.js\"></script> </head> <body>     <div id =\"root\">     <h2>显示格式化后的时间</h2>       <!–计算属性实现  –>     <h3> 1现在是:{{fmtTime}}</h3>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!--methods实现 -->\r\n<h3> 2现在是:{{getfmtTime()}}</h3>\r\n\n<!--过滤器实现 -->\r\n<h3> 3现在是:{{time | timeFormater}}</h3>\r\n\n<!--过滤器实现(传参+串联) -->\r\n<h3> 4现在是:{{time | timeFormater('YYYY-MM-DD') | mySlice}}</h3>\r\n</div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     //全局过滤器     // Vue.filters('mySlice',function(value){     //     return value.slice(0,4)     // })     new Vue({         el:'#root',         data:{             time:1621561377603,//时间戳         },         computed:{             fmtTime(){                 return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss')             }         },         methods: {             getfmtTime(){                 return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')             }         },         //局部的过滤器         filters:{             timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){                 return dayjs(value).format(str)             },             mySlice(value){                 return value.slice(0,4)             }         }     }                 ) </script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 15.内置指令\r\n\r\n**v-bind :** 单向绑定解析表达式，可简写为： xxx\r\n\r\n**v-model :** 双向数据绑定\r\n\r\n**v-for :** 遍历数组/对象/字符串\r\n\r\n**v-on ：** 绑定事件监听，可简写为@\r\n\r\n**v-if :** 条件渲染（动态控制节点是否存在）\r\n\r\n**v-else :** 条件渲染（动态控制节点是否存在）\r\n\r\n**v-show :** 条件渲染（动态控制节点是否展示）\r\n\r\n\r\n\r\n**v-text指令：**\r\n\r\n​\t1.作用：向其所在的节点中渲染文本内容\r\n\r\n​\t2.与差值语法的区别：v-text会替换掉节点中的内容，{{xx}}不会\r\n\r\n\r\n\r\n**v-html指令：**\r\n\r\n1.作用：向指定节点中渲染包含html结构的内容\r\n\r\n2.与差值语法的区别：\r\n\r\n​\t（1）v-html会替换掉节点中所有的内容，{{xx}}不会\r\n\r\n​\t（2）v-html可以识别html结构\r\n\r\n3.严重注意：v-html有安全性问题\r\n\r\n​\t（1）在网站上动态渲染任意html是非常危险的，容易导致XSS攻击\r\n\r\n​\t（2）一定要在可信的内容上使用v-html。永远不要在用户提交的内容上用v-html\r\n\r\n\r\n\r\n**补充cookie:**\r\n\r\n![image-20230811103728403](C:\\Users\\ccchhhddd\\Desktop\\image-20230811103728403.png)\r\n\r\n![image-20230811103835634](C:\\Users\\ccchhhddd\\Desktop\\image-20230811103835634.png)\r\n\r\n\r\n\r\n**v-clock指令**（没有值）：\r\n\r\n​\t1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-clock属性\r\n\r\n​\t2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。\r\n\r\n**v-once指令：**\r\n\r\n​\t1.v-once所在节点在初次渲染后，被视为静态内容了\r\n\r\n​\t2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能\r\n\r\n**v-pre指令：**\r\n\r\n​\t1.跳过其所在节点的编译过程\r\n\r\n​\t2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译\r\n\r\n\r\n\r\n#### 16.自定义指令\r\n\r\n总结：\r\n\r\n一、定义语法：\r\n\r\n（1）局部指令：\r\n\r\n​\t\tnew Vue({\r\n\r\n​\tdirectives:{指令名：配置对象}\r\n\r\n})\r\n\r\n或\r\n\r\nnew Vue({\r\n\r\n​\tdirectives{指令名：回调函数}\r\n\r\n})\r\n\r\n（2）全局指令\r\n\r\n​\tVue.directive{指令名，配置对象） 或Vue.directive(指令名，回调函数)\r\n\r\n\r\n\r\n二、配置对象中常用的3个回调：\r\n\r\n​\t\t（1）bind:指令与元素成功绑定时调用\r\n\r\n​\t\t（2）inserted:指令所在元素被插入页面时调用\r\n\r\n​\t\t（3）update:指令所在模版结构被重新解析时调用\r\n\r\n\r\n\r\n三、备注：\r\n\r\n​\t\t1.指令定义时不加v-,但使用时要加v-;\r\n\r\n​\t\t2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名（驼峰命名法）。\r\n\r\n\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <!– 需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍          需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。 –>     <div id =\"root\">      <h2>当前的n值是:<span v-text=\"n\"></span></h2>      <h2>放大10倍后的n值是:<span v-big=\"n\"></span></h2>      <button @click=\"n++\">点我n+1</button>      <hr/>      <input type=\"text\" v-fbind:value=\"n\">     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     new Vue({         el:'#root',         data:{             n:1,         },         directives:{             //big函数何时会被调用？1.指令与元素成功绑定时（一上来）2.指令所在的模版被重新解析时             big(element,binding){                 element.innerText = binding.value*10                 //console.log(element,binding.value)             },             fbind:{                 //指令与元素成功绑定时（一上来）                bind(element,binding){                 element.value =binding.value                },                //指令所在元素被插入页面时                 inserted(element,binding){                     element.focus()                 },                 //指令所在的模版被重新解析时                 update(element,binding){                     element.value =binding.value                  },             }             }         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":")","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 17.生命周期\r\n\r\n**生命周期：**\r\n\r\n1.又名：生命周期回调函数、生命周期函数、生命周期钩子\r\n\r\n2.是什么：Vue在关键时刻帮助我们调用的一些特殊名称的函数\r\n\r\n3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的\r\n\r\n4.生命周期函数中的this指向是vm或组件实例对象\t\r\n\r\n\r\n\r\n**常用的生命周期钩子：**\r\n\r\n1.mounted:发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】\r\n\r\n2.beforeDestroy:清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】\r\n\r\n\r\n\r\n**关于销毁Vue实例：**\r\n\r\n1.销毁后借助Vue开发者工具看不到任何信息\r\n\r\n2.销毁后自定义事件会失效，但原生DOM事件依然有效\r\n\r\n3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\r\n\r\n\r\n\r\n\r\n\r\n**图示：**\r\n\r\n![Vue 实例生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)\r\n\r\n#### 18.组件化编程\r\n\r\n![image-20230816160242109](C:\\Users\\ccchhhddd\\Desktop\\image-20230816160242109.png)\r\n\r\n##### **1.Vue中使用组件的三大步骤：**\r\n\r\n1.定义组件（创建组件）\r\n\r\n2.注册组件\r\n\r\n3.使用组件\r\n\r\n\r\n\r\n##### **一、如何定义一个组件？**\r\n\r\n使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但区别如下：\r\n\r\n1.el不要写，为什么？\r\n\r\n——最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器\r\n\r\n2.data必须写成函数，为什么？\r\n\r\n——避免组件被复用，数据存在引用关系\r\n\r\n备注：使用template可以配置组件结构\r\n\r\n\r\n\r\n##### **二、如何注册组件？**\r\n\r\n1.局部注册：靠new Vue的时候传入components选项\r\n\r\n2.全局注册：靠Vue.component('组件名'，组件)\r\n\r\n\r\n\r\n##### **三、编写注册组件：**\r\n\r\n<school></school>\r\n\r\n\r\n\r\n**1.基本使用.html**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <!– 准备好一个容器 –>     <div id =\"root\">    <!– 第三步:编写组件标签 –>     <school></school>      <hr>     <student></student>     </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     //第一步：创建school组件     const a =Vue.extend({         //el:'#root',  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理         template:<div>         <h2>学校名称：{{schoolname}}</h2>         <h2>学校地址：{{address}}</h2>         <button @click='showname'>点我提示学校名</button>         </div>,         data(){//函数式             return{             schoolname:'jiaoda',             address:'xian',              }},             methods: {                 showname(){                     alert(this.schoolname)                 }             },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    }\r\n)\r\n//第二步：创建student组件\r\nconst b =Vue.extend({\r\n    \r\n    //el:'#root',  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理\r\n    template:`\r\n    <div>\r\n    <h2>学生姓名：{{name}}</h2>\r\n    <h2>学生年龄：{{age}}</h2>\r\n    </div>\r\n    `,\r\n    data(){\r\n        return{\r\n        name:'chd',\r\n        age:20, \r\n        }}     \r\n    }\r\n)\r\n\n\n//创建vm\r\nnew Vue({\r\n    el:'#root',\r\n    //第二步：注册组件（局部注册）\r\n    components:{\r\n        school:a,//组件名在这里定\r\n        student:b\r\n    }  }            \r\n)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>  </body> </html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 2.几个注意的要点\r\n\r\n**1.关于组件名：**\r\n\r\n一个单词组成：\r\n\r\n​\t第一种写法（首字母小写）：school\r\n\r\n​\t第二种写法（首字母大写）：School\r\n\r\n多个单词组成：\r\n\r\n​\t第一种写法（kebab-case命名）：my-school\r\n\r\n​\t第二种写法（CamelCase命名）：MySchool(需要Vue脚手架支持)\r\n\r\n备注:\r\n\r\n​\t(1)组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行\r\n\r\n（2）可以使用name配置项指定组件在开发者工具中呈现的名字\r\n\r\n\r\n\r\n**2.关于组件标签**\r\n\r\n​\t第一种写法：<school></school>\r\n\r\n​\t第二种写法：<school/>\r\n\r\n​\t备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。\r\n\r\n\r\n\r\n**3.一个简写方式：**\r\n\r\n const school =Vue.extend(options) 可简写为：const school = options\r\n\r\n\r\n\r\n##### 3.VueComponent\r\n\r\n 关于VueComponent:\r\n\r\n​\t1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\r\n\r\n​\t2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)\r\n\r\n​\t3.特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent !!!\r\n\r\n​\t4.关于this指向：\r\n\r\n​\t\t(1)组件配置中：\r\n\r\n​\t\t\t\tdata函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】\r\n\r\n​\t（2）new Vue(options)配置中：\r\n\r\n​\t\t\tdata函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】\r\n\r\n​\t5.VueComponent的实例对象、以后简称vc（也可称之为：组件实例对象）\r\n\r\nVue的实例对象，以后简称vm\r\n\r\n​\t6.因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。（vm和vc的异同）\r\n\r\n\r\n\r\n##### 4.一个重要的内置关系\r\n\r\n1.一个重要的内置关系：VueComponent.prototype.__proto__ ===Vue.prototype\r\n\r\n2.为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性、方法\r\n\r\n![image-20230829121059619](C:\\Users\\ccchhhddd\\Desktop\\image-20230829121059619.png)\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html <!DOCTYPE html> <html lang=\"en\"> <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">     <title></title>     <script type=\"text/javascript\" src=\"../js/vue.js\"></script> </head> <body>     <!– 准备好一个容器 –>     <div id =\"root\">     <school></school>     </div> </body>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script type=\"text/javascript\">     Vue.prototype.x=99//得益于VueComponent.prototype.proto === Vue.prototype这个内置重要关系    const school =Vue.extend({         name:'school',         //el:'#root',  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理         template:<div>         <h2>学校名称：{{schoolname}}</h2>         <h2>学校地址：{{address}}</h2>         <button @click='showX'>点我输出X</button>           </div>,         data(){//函数式             return{             schoolname:'jiaoda',             address:'xian',              }},         methods: {             showX(){             console.log(this.x)             },         },     })    const vm=new Vue({     el:'#root',     data:{         msg:'你好'     },     components:{         school     }    })    //console.log(school.prototype.proto === Vue.prototype)     // function Demo(){     //     this.a=1     //     this.b=2     // }     // //创建一个Demo的实例对象     // const d= new Demo()","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// console.log(Demo.prototype) //显示原型属性\r\n// console.log(d.__proto__)//隐式原型属性\r\n\n// //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99\r\n// Demo.prototype.x = 99\r\n\n// console.log('@',d)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script> ","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</html>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n### 2.使用Vue脚手架\r\n\r\n#### 1.单文件组件+脚手架简介+相关函数+相关配置\r\n\r\nxxxxx.Vue\r\n\r\n**1.webpack**\r\n\r\n**2.脚手架  Vue CLI  动能：浏览器不能直接识别并运行Vue文件，需要通过脚手架的环境配置的支持**\r\n\r\n1. Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）。\r\n2. 最新的版本是 4.x。\r\n3. 文档: https://cli.vuejs.org/zh/\r\n\r\n**3.模版目录框架**\r\n\r\n├── node_modules\r\n\r\n ├── public \r\n\r\n│ ├── favicon.ico: 页签图标\r\n\r\n │ └── index.html: 主页面\r\n\r\n ├── src\r\n\r\n │ ├── assets: 存放静态资源 \r\n\r\n│ │└── logo.png \r\n\r\n│ │── component: 存放组件\r\n\r\n │ │ └── HelloWorld.vue\r\n\r\n │ │── App.vue: 汇总所有组件\r\n\r\n │ │── main.js: 入口文件\r\n\r\n ├── .gitignore: git 版本管制忽略的配置\r\n\r\n ├── babel.config.js: babel 的配置文件\r\n\r\n ├── package.json: 应用包配置文件\r\n\r\n ├── README.md: 应用描述文件\r\n\r\n ├── package-lock.json：包版本控制文件\r\n\r\n\r\n\r\n**4.render函数**\r\n\r\n关于不同版本的Vue：\r\n\r\n​\t1.vue.js与vue.runtime.xxx.js的区别：\r\n\r\n​\t\t（1）vue.js是完整版的Vue  包含：核心功能+模版解析器\r\n\r\n​\t\t（2） vue.runtime.xxx.js是运行版的Vue ,只包含：核心功能，没有模版解析器\r\n\r\n​\t2.因为vue.runtime.xxx.js没有模版解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript main.js文件 //该文件是整个项目的入口文件 //引入Vue（注意：这里引入的vue只是大的文件夹，并没有指定到核心的vue.js，所以仍需要在下方引入render函数，做模版解析） import Vue from 'vue' //引入App组件，它是所有组件的父组件 import App from './App.vue' //关闭Vue的生产提示 Vue.config.productionTip = false","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 创建Vue的实例对象–-vm new Vue({   el:'#app',   // 完成功能：将App组件放入容器中   render: h => h(App),  //render函数只用在这里写一遍 })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**5.vue.config.js配置文件**\r\n\r\n使用vue inspect  > output.js 可以查看到Vue脚手架的默认配置\r\n\r\n使用vue.config.js可以对脚手架进行**个性化定制**，详情见：https://cli.vuejs.org/zh/config/#vue-config-js\r\n\r\n\r\n\r\n**6.ref属性**\r\n\r\n1.被用来给元素或子组件注册引用信息（id的替代者）\r\n\r\n2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\r\n\r\n3.使用方式：\r\n\r\n​\t\t打标识：<h1 ref='xxx'>.....</h1>或<School ref='xxx'></SChool>\r\n\r\n​\t\t获取：this.$refs.xxx\r\n\r\n\r\n\r\n**7.配置项props**\r\n\r\n​\t功能：让组件接收外部传来的数据\r\n\r\n​\t\t（1）传递数据：\r\n\r\n​\t\t\t<Demo name ='xxx'/>\r\n\r\n​\t\t（2）接收数据：\r\n\r\n​\t\t\t第一种方式（只接收）：\t\t\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript  props:['name','age','sex']//简单声明接收。 这里写了，data里就不能有了 ","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n​\t\t\t第二种方式（限制类型）：\t\t\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript // 接收的同时对数据进行类型限制         // props:{         //     name:String,         //     age:Number,         //     sex:String         // }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n​\t\t\t\t第三种方式（限制类型、限制必要性、指定默认值）：\t\t\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript props:{             name:{                 type:String, //name的类型是字符串                 required:true //name是必要的             },             age:{                 type:Number,                 default:99 //默认值             },             sex:{                 type:String,                 require:true             }         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**备注：**props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。\r\n\r\n如下是一个名叫Student.vue的文件例子\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript <template>         <div>         <h1>{{ msg }}</h1>         <h2>学生姓名：{{name}}</h2>         <h2>学生年龄：{{Myage}}</h2>         <button @click=\"chageage\">点我年龄++</button>         <h2>学生性别：{{sex}}</h2>         </div>        </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"export default {\r\n    name:'MyStudent',   \r\n    data(){//函数式\r\n        return{\r\n        msg:'我是一名学生',\r\n        Myage:this.age//这里利用的是props的优先级比data高实现的，也就是说程序先去扫描props里的数据。\r\n        \r\n        }},\r\n        methods:{\r\n            chageage(){\r\n                this.Myage++\r\n            }\r\n        },\r\n    // props:['name','age','sex']//简单声明接收。 这里写了，data里就不能有了  \r\n\n    // 接收的同时对数据进行类型限制\r\n    // props:{\r\n    //     name:String,\r\n    //     age:Number,\r\n    //     sex:String\r\n    // }\r\n\n    // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制\r\n    props:{\r\n        name:{\r\n            type:String, //name的类型是字符串\r\n            required:true //name是必要的\r\n        },\r\n        age:{\r\n            type:Number,\r\n            default:99 //默认值\r\n        },\r\n        sex:{\r\n            type:String,\r\n            require:true\r\n        }\r\n    }}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<style> </style>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**8.mixin(混入)**\r\n\r\n**功能：**可以把多个组件共用的配置提取成一个混入对象\r\n\r\n**使用方法：**\r\n\r\n​\t\t第一步定义混合，例如：\r\n\r\n{\r\n\r\ndata(){....},\r\n\r\nmethods:{....}\r\n\r\n....\r\n\r\n}\r\n\r\n​\t第二步使用混入，例如：\r\n\r\n（1）全局混入：Vue.mixin(xxx)\r\n\r\n（2）局部混入：mixins:['xxx']\r\n\r\n\r\n\r\n\r\n\r\n**9.插件**\r\n\r\n**功能：**用于增强Vue\r\n\r\n**本质：**包含install方法的一个对象，install的第一个参数是Vue,第二个以后得参数是插件使用者传递的数据\r\n\r\n**定义插件：**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript export default{     install(Vue,x,y,z){         console.log(x,y,z)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//全局过滤器\r\nVue.filter('mySlice',function(value){\r\n    return value.slice(0,4)\r\n})\r\n//定义全局指令\r\nVue.directive('fbind',{\r\n    //指令与元素成功绑定时（一上来）\r\n    bind(element,binding){\r\n        element.value = binding.value\r\n    },\r\n//指令所在元素被插入页面时\r\ninserted(element){\r\n    element.focus()\r\n},\r\n//指令所在的模版被重新解析时\r\nupdate(element,binding){\r\n    element.value = binding.value\r\n}\r\n})\r\n\n//定义混入\r\nVue.mixin({\r\n    data(){\r\n        return{\r\n            x:100,\r\n            y:200\r\n        }\r\n    }\r\n})\r\n//给Vue原型上添加一个方法\r\nVue.prototype.hello = ()=>{alert('nihaoya')}\r\n//添加实例方法\r\nVue.prototype.$myMethod = function(){...}\r\nVue.prototype.$myProperty = xxxx","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"} }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**使用插件：**Vue.use()\r\n\r\n\r\n\r\n#### 2.scoped样式\r\n\r\n作用：让样式在局部生效，防止冲突\r\n\r\n写法：<style scoped>\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <template>         <div class=\"demo\">         <h2>学生姓名：{{name}}</h2>         <h2 class=\"qwe\">学生性别：{{sex}}</h2>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    </div>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script>         export default {         name:'MyStudent',           data(){//函数式             return{             name:'cccchhhhddd',             sex:'男'             }},","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<!– 要用less 要安装less-loader 指令：npm i less-loader –> <!– 用less的好处：可以嵌套着写 –> <style lang=\"less\" scoped> // 不写lang就默认是CSS /* 加入scoped .demo就不担心存在重复的情况了,但此时demo只能在School组件里使用 */ .demo{   background-color:pink;   .qwe{     font-size:40px;   } } </style>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 3.Todo-list案例\r\n\r\n**组件化编码流程（通用）**\r\n\r\n 1.实现静态组件：抽取组件，使用组件实现静态页面效果 \r\n\r\n2.展示动态数据： 2.1. 数据的类型、名称是什么？ 2.2. 数据保存在哪个组件？ \r\n\r\n3.交互——从绑定事件监听开始\r\n\r\n\r\n\r\n**注：**父亲给儿子可以传函数、数组.....在此基础上儿子调用先前父亲给儿子传的函数方法，儿子也可以给父亲传数据\r\n\r\n![image-20230904180524916](C:\\Users\\ccchhhddd\\Desktop\\image-20230904180524916.png)\r\n\r\n\r\n\r\n##### **总结todolist案例：**\r\n\r\n##### 1.组件化编码流程：\r\n\r\n​\t（1）拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\r\n\r\n​\t（2）实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：\r\n\r\n​\t\t\t1）一个组件再用：放在组件自身即可。\r\n\r\n​\t\t\t2)一些组件在用，放在他们共同的父组件上（<span style='color:red'>状态提升</span>）\r\n\r\n​\t（3）实现交互：从绑定事件开始\r\n\r\n##### 2.props适用于：\r\n\r\n​\t(1)父组件==>子组件 通信\r\n\r\n​\t(2)子组件===>父组件 通信 （要求父先给子一个函数）\r\n\r\n##### 3.使用v-model时要切记：\r\n\r\nv-model绑定的值不能是props传过来的值，因为props是不可以修改的！\r\n\r\n##### 4.props传过来的若是对象类型的值：\r\n\r\n修改对象中的属性时Vue不会报错，但不推荐这样做\r\n\r\n\r\n\r\n#### 4.webStorage（浏览器存储）\r\n\r\n1.存储大小一般支持5MB左右（不同浏览器不一样）\r\n\r\n2.浏览器通过Window.sessionStorage和Window.localStorage 属性来实现本地存储机制\r\n\r\n3.相关API\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"xxxxxxStorage.setItem('key','value');","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"该方法接受一个键和值作为参数，会把键值对添加到存储中，如果建名存在，则更新其对应的值 2.xxxxxxStorage.getItem('person'); 该方法接受一个建名作为参数，返回键名对应的值 3.xxxxxxStorage.removeItem('key'); 该方法接受一个建名作为参数，并把该建名从存储中删除 4.xxxxxxStorage.clear() 该方法会清空存储中的所有数据","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n4.备注：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"1.SessionStorage存储的内容会随着浏览器窗口关闭而消失 2.LocalStorage存储的内容，需要手动清除才会消失 3.xxxxxxStorage.getItem(xxxx) 如果xxx对应的value获取不到，那么getItem的返回值是null 4.JSON.parse(null)的结果依然是null","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 5.组件的自定义事件\r\n\r\n​\t1.一种组件间通信的方式，适用于： 子组件==>父组件\r\n\r\n​\t2.使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）\r\n\r\n​\t3.绑定自定义事件：\r\n\r\n​\t\t1.第一种方式，在父组件中：<Demo @atguigu='test'/>  或<Demo v-on:atguigu='test'/>\r\n\r\n​\t\t2.第二种方式，在父组件中：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <Demo ref='demo'/> ...... mounted(){ this.refsxxxon('atguigu',this.test) }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n​\t\t3.若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法\r\n\r\n4.触发自定义事件：this.$emit('atguigu',数据)\r\n\r\n5.解绑自定义事件 this.$off('atguigu')\r\n\r\n6.组件上也可以绑定原生DOM事件，需要使用native修饰符\r\n\r\n7.注意：通过 this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题。【直接用function,this指的是xxx组件】\r\n\r\n\r\n\r\n#### 6.全局事件总线\r\n\r\n1.一种组件间通信的方式，适用于任意组件间通信\r\n\r\n2.安装全局事件总线：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"new Vue({ \t...... \tboforeCreate(){ \t\tVue.prototype.bus = this 安装全局事件总线bus就是当前应用的vm         },     ..... })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n3.使用事件总线：\r\n\r\n​\t1.接受数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript methods(){ \tdemo(data){....} } ...... mounted(){ \tthis.buson('xxxx',this.demo) }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n​\t2.提供数据：this.$bus.$emit('xxxx',数据)\r\n\r\n4.最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**原理图：**\r\n\r\n![image-20230906160131275](C:\\Users\\ccchhhddd\\Desktop\\image-20230906160131275.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 7.消息订阅与发布（pubsub）\r\n\r\n1.一种组件间通信的方式，适用于任意组件间通信\r\n\r\n2.使用步骤：\r\n\r\n​\t1.安装pubsub：npm i pubsub-js\r\n\r\n​\t2.引入： import pubsub from 'pubsub-js'\r\n\r\n​\t3.接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue methods(){ demo(data){....} } ...... mounted(){ this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息 }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n​\t4.提供数据： pubsub.publish('xxx',数据)\r\n\r\n​\t5.最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去<span style='color:red'>取消订阅。</span>\r\n\r\n\r\n\r\n**原理图：**\r\n\r\n![image-20230906221035052](C:\\Users\\ccchhhddd\\Desktop\\image-20230906221035052.png)\r\n\r\n\r\n\r\n#### 8.nextTick\r\n\r\n**1.语法：** this.$nextTick(回调函数)\r\n\r\n**2.作用：** 在下一次DOM更新结束后执行其指定的回调\r\n\r\n**3.什么时候用：**当改变数据后，要**基于更新后的新DOM进行某些操作时**，要在nextTick所指定的回调函数中执行\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"javascript handleEdit(todo){","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"        if('isEdit'== undefined){\r\n            todo.isEdit = true\r\n        }\r\n        else{\r\n            this.$set(todo,'isEdit',true)\r\n        }\r\n        // 若没有外包一个东西的话，下面这行代码会执行，但是input还未出现，所以并没有显示相应的结果\r\n        // 这是Vue在考虑效率时设置的形式。 异步？\r\n        // $nextTick官方写法:\r\n        this.$nextTick(function(){\r\n            this.$refs.inputtitle.focus()\r\n        })\r\n        //或者 setTimeout(()=>{\r\n        // this.$refs.inputtitle.focus()\r\n        // })\r\n       },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 9.Vue封装的过度与动画\r\n\r\n1.作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。\r\n\r\n2.图示：\r\n\r\n![image-20230914195315215](C:\\Users\\ccchhhddd\\Desktop\\image-20230914195315215.png)\r\n\r\n3.写法：\r\n\r\n1.准备好样式：\r\n\r\n​\t\t\t元素进入的样式：\r\n\r\n​\t\t\t\t\t1.v-enter :进入的起点\r\n\r\n​\t\t\t\t\t2.v-enter-active:进入过程中\r\n\r\n​\t\t\t\t\t3.v-enter-to:进入的终点\r\n\r\n​\t\t\t元素离开时的样式：\r\n\r\n​\t\t\t\t\t1.v-leave:离开的起点\r\n\r\n​\t\t\t\t\t2.v-leave-active:离开过程中\r\n\r\n​\t\t\t\t\t3.v-leave-to:离开的终点\r\n\r\n2.使用<transition>包裹要过度的元素，并配置name属性：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <transition name=\"hello\"> \t<h1 v-show=\"isShow\">你好啊！</h1> </transition>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n3.备注：若有多个元素需要过度，则需要使用：<transition-group>,且每个元素都要指定key值\r\n\r\n\r\n\r\n例子：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <template>   <div>     <button @click=\"isShow = !isShow\"> 显示/隐藏</button>     <!–引入第三方动画 –>     <transition-group     appear      name=\"animateanimated animatebounce\"       enter-active-class=\"animaterubberBand\"     leave-active-class=\"animatebackOutUp\"     >         <h1 v-show=\"!isShow\" key=\"1\">你好哈哈哈哈！</h1>         <h1 v-show=\"isShow\" key=\"2\">ccchhhddd</h1>     </transition-group>   </div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> import 'animate.css' export default {     name:'MyTest3',     data(){         return{             isShow:true         }     } } </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<style scoped>     h1{         background-color: orange;     }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</style>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n### 3.Vue中的ajax\r\n\r\n#### 1.前端服务器相关文章与视频\r\n\r\n##### 1.用Node.js搭建一个简单Web服务器\r\n\r\nhttps://blog.csdn.net/m0_46171043/article/details/132033934\r\n\r\n##### 2.【笔记】 node.js - 开启本地服务器，返回json数据\r\n\r\nhttps://blog.csdn.net/LawssssCat/article/details/103459796\r\n\r\n##### 3.FeHelper前端助手浏览器插件 chrome插件-Web开发者助手 FeHelper\r\n\r\nhttps://blog.csdn.net/A598853607/article/details/124118482\r\n\r\n可以直接在谷歌应用商店里下载\r\n\r\n##### 4.【原生Ajax】全面了解xhr的概念与使用\r\n\r\nhttp://www.shouxieziti.cn/29383.html\r\n\r\nxhr、jQuery现阶段用的比较少了，随着Vue和react框架的兴起axios用到比较多了\r\n\r\n##### 5.尚硅谷Web前端axios入门与源码解析（视频链接）\r\n\r\nhttps://www.bilibili.com/video/BV1wr4y1K7tq/?spm_id_from=333.337.search-card.all.click&vd_source=ab1c31a8db0c1b9114896077df5b64aa\r\n\r\n\r\n\r\n#### 2.解决跨域问题\r\n\r\n协议、域名、端口号都对的上即不存在跨域问题\r\n\r\n方法1：cors\r\n\r\n方法2：jsonp(需要前后端配合，很巧妙)\r\n\r\n方法3：配置代理服务器\r\n\r\n1.nginx\r\n\r\n2.vue-cli(下面用到的)\r\n\r\n##### 方法一：在vue.config.js中添加如下配置\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js devServer: {     proxy: 'http://localhost:5000'","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n说明：\r\n\r\n1.优点：配置简单，请求资源时直接发给前端（8080）即可。\r\n\r\n2.缺点：不能配置多个代理，不能灵活的控制请求是否走代理\r\n\r\n3.工作方式：若按照上述的代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）\r\n\r\n\r\n\r\n方法二：编写vue.config.js配置具体代理规则：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js module.exports = defineConfig({   // 开启代理服务器(方式2)   devServer: {     proxy: {       '/chd': {         target: 'http://localhost:5000',         pathRewrite:{'^/chd':''},         ws: true,//用于支持websocket         // changeOrigin: true //用于控制请求头中的host值        },       '/demo': {         target: 'http://localhost:5001',         pathRewrite:{'^/demo':''},         // ws: true,//用于支持websocket         // changeOrigin: true //用于控制请求头中的host值        },     }   }     // changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   // changeOrigin设置为fasle时，服务器收到的请求头中的host为：localhost:8080   // changeOrigin默认值为true })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n说明：\r\n\r\n1.优点：可以配置多个代理，且可以灵活的控制请求是否走代理\r\n\r\n2.缺点：配置略微繁琐，请求资源时必须加前缀\r\n\r\n\r\n\r\n#### 3.vue_github搜索案例\r\n\r\nhttps://blog.csdn.net/liaoai/article/details/123431352\r\n\r\n上面链接里的案例没有用到main.js自身作为$bus的全局事件总线\r\n\r\n我后面进行了部分的简化可以省去不少的内容\r\n\r\n\r\n\r\n#### 4.插槽\r\n\r\n认识Vue中组件利器-插槽Slot-案例介绍\r\n\r\nhttps://blog.csdn.net/JackieDYH/article/details/124481953\r\n\r\n\r\n\r\n##### 1.作用：\r\n\r\n让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件==>子组件\r\n\r\n##### 2.分类：\r\n\r\n默认插槽、具名插槽、作用域插槽\r\n\r\n##### 3.使用方式：\r\n\r\n###### \t\t1.默认插槽\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue 父组件： <template>   <div class=\"container\">     <Category title=\"美食\">       <img src=\"https://s3.ax1x.com/2021/01/16/srJlq0.jpg\" alt=\"\">     </Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<Category title=\"游戏\" >\r\n  <ul>\r\n    <li v-for=\"(g,index) in games\" :key=\"index\">{{g}}</li>\r\n  </ul>\r\n</Category>\r\n\n<Category title=\"电影\">\r\n  <video controls src='./assets/shengqi.mp4'></video>\r\n</Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> import Category from './components/Category.vue' export default {   name: \"App\",   components: { Category },   data(){     return{       foods:['火锅','烧烤','小龙虾','牛排'],       games:['红色警戒','穿越火线','英雄联盟','刀塔'],       films:['《教父》','《星际穿越》','《变形金刚》','《盗梦空间》']","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"} }; </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"子组件： <template>   <div class=\"category\">     <h3>{{ title }}分类</h3>     <!– 定义一个插槽（挖个坑，等着组件的使用者进行填充） –>     <slot>我是默认插槽，没有传递具体结构时，我会出现</slot>   </div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> export default {     name:'MyCategory',     props:['title'] } </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n###### \t\t2.具名插槽\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue 父组件： <template>   <div class=\"container\">     <Category title=\"美食\">       <img slot=\"center\"  src=\"https://s3.ax1x.com/2021/01/16/srJlq0.jpg\" alt=\"\">       <a class=\"foot\"  slot=\"footer\"  href=\"https://baidu.com\">百度</a>     </Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<Category title=\"游戏\" >\r\n  <ul slot=\"center\">\r\n    <li v-for=\"(g,index) in games\" :key=\"index\">{{g}}</li>\r\n  </ul>\r\n  <div class=\"foot\" slot=\"footer\">\r\n    <a solt=\"footer\"  href=\"https://baidu.com\">单机游戏</a>\r\n    <a solt=\"footer\"  href=\"https://baidu.com\">网络游戏</a>\r\n  </div>      \r\n</Category>\r\n\n<Category title=\"电影\">\r\n  <video  slot=\"center\" controls src='./assets/shengqi.mp4'></video>\r\n  <template v-slot:footer>\r\n    <div class=\"foot\">\r\n    <a solt=\"footer\"  href=\"https://baidu.com\">经典</a>\r\n    <a solt=\"footer\"  href=\"https://baidu.com\">热门</a>\r\n    <a solt=\"footer\"  href=\"https://baidu.com\">推荐</a>\r\n  </div>\r\n  <h4>欢迎前来观影</h4>\r\n  </template>\r\n  \r\n</Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> import Category from './components/Category.vue' export default {   name: \"App\",   components: { Category },   data(){     return{       foods:['火锅','烧烤','小龙虾','牛排'],       games:['红色警戒','穿越火线','英雄联盟','刀塔'],       films:['《教父》','《星际穿越》','《变形金刚》','《盗梦空间》']","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"} }; </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"子组件： <template>   <div class=\"category\">     <h3>{{ title }}分类</h3>     <!– 定义一个插槽（挖个坑，等着组件的使用者进行填充） –>     <slot name=\"center\">我是默认插槽，没有传递具体结构时，我会出现1</slot>     <slot name=\"footer\">我是默认插槽，没有传递具体结构时，我会出现2</slot>   </div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> export default {     name:'MyCategory',     props:['title'] } </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n###### \t\t3.作用域插槽：\r\n\r\n​\t\t\t1.理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。\r\n\r\n​\t\t\t（games数据在category组件中，但使用数据所遍历出来的结构由App组件决定）\r\n\r\n​\t\t\t2.编码：\t\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue 父组件: <template>   <div class=\"container\">     <Category title=\"游戏\" >       <template scope=\"duixiang\">         <ul slot=\"center\">           <li v-for=\"(g,index) in duixiang.games\" :key=\"index\">{{g}}</li>         </ul>       </template>          </Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<Category title=\"游戏\" >\r\n  <!-- 解构赋值{} -->\r\n  <template scope=\"{games}\">\r\n    <ol>\r\n      <li style=\"color: red\" v-for=\"(g,index) in games\" :key=\"index\">{{g}}</li>\r\n    </ol>\r\n  </template>     \r\n</Category>\r\n\n<Category title=\"游戏\" >\r\n  <!-- 解构赋值{} -->\r\n  <template slot-scope=\"{games}\">\r\n    <h4 v-for=\"(g,index) in games\" :key=\"index\">{{g}}</h4>     \r\n  </template>     \r\n</Category>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"</div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> import Category from './components/Category.vue' export default {   name: \"App\",   components: { Category },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"}; </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"子组件： <template>   <div class=\"category\">     <h3>{{ title }}分类</h3>     <slot :games=\"games\"></slot>   </div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> export default {     name:'MyCategory',     props:['title'],     data(){     return{       games:['红色警戒','穿越火线','英雄联盟','刀塔'],     }   } } </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n### 4.Vuex\r\n\r\n\r\n\r\n#### \t1 .vuex 是什么? \r\n\r\n1. 概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信。 \r\n2. Github 地址: https://github.com/vuejs/vuex \r\n\r\n#### \t2 .什么时候使用Vuex?\r\n\r\n1. 多个组件依赖于同一状态\r\n2. 来自不同组件的行为需要变更同一状态\r\n\r\n#### 3.逻辑图：\r\n\r\n![vuex](https://vuex.vuejs.org/vuex.png)\r\n\r\n#### 4.基本使用\r\n\r\n1.具体案例\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js //index.js","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 该文件用于创建Vuex中最为核心的store","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"import Vue from 'vue' // 引入Vuex import Vuex from 'vuex' Vue.use(Vuex) // 准备actions——用于相应组件中的动作 // 业务逻辑写在action里面 const actions = {     // jia(context,value){     //     context.commit('JIA',value)     // },     // jian(context,value){     //     context.commit('JIAN',value)     // },     oddjia(context,value){         // console.log(state,context,value)         if(context.state.sum % 2 == 1){         context.commit('ODDJIA',value)         }     },     timejia(context,value){         setTimeout(()=>{             context.commit('TIMEJIA',value)         },500)     } } // 准备mutations——用于操作数据（state） const mutations = {     JIA(state,value){         state.sum += value     },     JIAN(state,value){         state.sum -= value     },     ODDJIA(state,value){         state.sum += value     },     TIMEJIA(state,value){         state.sum += value     } } // 准备state——用于存储数据 const state = {     sum:0 //当前的和 }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 创建store export default new Vuex.Store({     actions,     mutations,     state })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue //组件Count.vue","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<template>   <div>     <h1> 当前求和为{{ store.state.sum }}</h1>     <select v-model=\"n\">         <option :value=\"1\">1</option>         <option :value=\"2\">2</option>         <option :value=\"3\">3</option>     </select>     <button @click=\"increment\">+</button>     <button @click=\"decrement\">-</button>     <button @click=\"incrementodd\">当前求和为奇数再加</button>     <button @click=\"incrementwait\">等一等再加</button>   </div> </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script> export default {     name:'MyCount',     data(){         return{             n:1,//用户选择的数字","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    }\r\n},\r\nmethods:{\r\n    increment(){\r\n        // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit\r\n        this.$store.commit('JIA',this.n)\r\n    },\r\n    decrement(){\r\n        this.$store.commit('JIAN',this.n)\r\n    },\r\n    incrementodd(){\r\n        this.$store.dispatch('oddjia',this.n)  \r\n    },\r\n    incrementwait(){\r\n        this.$store.dispatch('timejia',this.n)     \r\n    }\r\n},","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"} </script>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n2.组件中读取vuex中的数据：$store.state.sum\r\n\r\n3.组件中修改vuex中的数据：$store.dispatch('action中的方法名'，数据)或$store.commit('mutations中的方法名'，数据)\r\n\r\n\r\n\r\n#### 5.getters的使用\r\n\r\n1.概念：当state中的数据需要经过加工后再使用时，可以使用getters加工\r\n\r\n2.在store.js中追加getters配置\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js const getters = {     bigsum(state){         return state.sum*10     } }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 创建并暴露store export default new Vuex.Store({     ...     getters","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n3.组件中读取数据：$store.getters.bigsum\r\n\r\n\r\n\r\n#### 6.四个map方法的使用\r\n\r\n###### 1.mapState方法：\r\n\r\n帮我们映射state中的数据为计算属性\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue computed:{         // 1.靠程序员自己写的代码         // he(){         //     return this.storestatesum                    xuexiao()              return thisstore.state.subject         // },         // xueke(){         //     return this.store.state.school         // },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    // 2.借助mapState生成计算属性，从state中读取数据。（对象写法）\r\n    // ...mapState({sum:'sum',school:'school',subject:'subject'}),\r\n\n    // 3.借助mapState生成计算属性，从state中读取数据。（数组写法）\r\n    ...mapState(['sum','school','subject']),\r\n    }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n###### 2.mapGetters方法：\r\n\r\n用于帮助我们映射getters中的数据为计算属性\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue computed:{\t\t \t\t// 1.靠程序员自己写的代码         // bigsum(){         //     return this.store.getters.bigsum          // },         // 2.借助mapGetters生成计算属性，从getters中读取数据。（数组写法）         ...mapGetters(['bigsum'])         }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n###### 3.mapActions方法：\r\n\r\n用于帮助我们生成与actions对话的方法，即包含$store.dispatch（xxx）的函数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue methods:{ \t\t// 1.程序员手写法         // incrementodd(){         //     this.storedispatch(oddjiathisn)                      incrementwait()              thisstore.dispatch('timejia',this.n)              // }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    // 2.借助mapActions生成的方法，方法会调用dispatch去联系actions(对象写法)\r\n    ...mapActions({incrementodd:'oddjia',incrementwait:'timejia'})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n###### 4.mapMutations方法：\r\n\r\n用于帮助我们生成与mutations对话的方法，即包含$store.commit(xxx)的函数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue \tmethods:{\t \t\t// 1.程序员手写         // increment(){         //     // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit         //     this.storecommit(JIAthisn)                    decrement()              thisstore.commit('JIAN',this.n)         // },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"    // 2.借助mapMutations生成对应的方法，方法会调用commit去联系mutations(对象写法)\r\n    ...mapMutations({increment:'JIA',decrement:'JIA'}),\r\n    }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 7.模块化+命名空间\r\n\r\n**1.目的：**让代码更好维护，让更多数据分类更加明确\r\n\r\n**2.修改`store.js`**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 求和相关配置 const countOptions= {     namespaced:true,     mutations:{...},     getters:{         bigsum(state){             return state.sum*10         }     } }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 人员相关配置 const personOptions= {     namespaced:true,     actions:{...},     mutations:{...},     }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 创建并暴露store export default new Vuex.Store({     modules:{       a:countOptions,       b:personOptions     } })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**3.开启命名空间后，组件中读取state数据：**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue //1.自己直接读取 this.store.state.a.list //2.借助mapState读取 ...mapState('a',['sum','school'])","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**4.开启命名空间后，组件中读取getters数据：**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":" //1.自己直接读取  this.store.getters['b/fisrtpersonname']  //2.借助mapGetters读取  ...mapGetters('a',['bigsum'])","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**5.开启命名空间后，组件中调用dispatch**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":" //1.自己直接读取  this.store.dispatch['b/addpersonwang',person]  //2.借助mapActions;  ...mapActions('a',{increment:'oddjia',incrementwait:'timejia'})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n**6.开启命名空间后，组件中调用commit**\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":" //1.自己直接commit  this.store.commit['b/ADDPERSON',person]  //2.借助mapMutations:  ...mapMutations('a',{increment:'JIA',decrement:'JIAN'})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n### 5.vue-router\r\n\r\n#### 1.相关理解\r\n\r\n##### 1.vue-router 的理解 \r\n\r\nvue 的一个插件库，专门用来实现 **SPA 应用** \r\n\r\n##### 2.对 SPA 应用的理解 \r\n\r\n1.单页 Web 应用（single page web application，SPA）。 \r\n\r\n2.整个应用只有**一个完整的页面**。 \r\n\r\n3.点击页面中的导航链接不会刷新页面，只会做页面的**局部更新**。\r\n\r\n 4. 数据需要通过 ajax 请求获取\r\n\r\n##### 3.路由的理解\r\n\r\n###### 1.什么是路由?\r\n\r\n​\t1.一个路由就是一组映射关系（key - value） \r\n\r\n​\t2.key 为路径, value 可能是 function 或 component \r\n\r\n###### 2.路由分类\r\n\r\n1.后端路由：\r\n\r\n​\t1.理解：value 是 function, 用于处理客户端提交的请求。\r\n\r\n \t2.工作过程：服务器接收到一个请求时, 根据**请求路径**找到匹配的**函数**来处理请求, 返回响应数据。\r\n\r\n2.前端路由：\r\n\r\n​\t1.理解：value 是 component，用于展示页面内容。\r\n\r\n \t2.工作过程：当浏览器的路径改变时, 对应的组件就会显示。\r\n\r\n\r\n\r\n#### 2.基本路由\r\n\r\n##### 1.基本使用\r\n\r\n1.安装vue-router ,命令：npm i vue-router\r\n\r\n2.应用插件：Vue.use(VueRouter)\r\n\r\n3.编写router配置项：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js // 该文件专门用于创建整个应用的路由器 import VueRouter from 'vue-router'","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 引入组件 import About from '../pages/About' import Home from '../pages/Home'","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 创建并暴露一个路由器 export default new VueRouter({     routes:[       {         path:'/about',         component:About       },       {         path:'/home',         component:Home       },      ] })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n4.实现切换（active-class 可配置高亮样式）\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js <router-link active-class='active' to='/about'>About</router-link>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n5.指定展示位置\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js <router-view></router-view>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 2.几个注意点\r\n\r\n​\t1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹\r\n\r\n​\t2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载\r\n\r\n​\t3.每个组件都有自己的$route属性，里面存储着自己的路由信息。\r\n\r\n​\t4.整个应用只有一个router,可以通过组件的$router属性获取到。\r\n\r\n\r\n\r\n#### 3.嵌套路由\r\n\r\n1.配置路由规则，使用children配置项\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js // 创建并暴露一个路由器 export default new VueRouter({     routes:[       {         path:'/about',         component:About       },       {         path:'/home',         component:Home,         children:[           {             // 这里不用加斜杠             path:'news',             component:News,           },           {             path:'message',             component:Message,           },         ]       },      ] })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n2.跳转（要写完整路径）\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <router-link to='/home/news'>News</router-link>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 4.路由的query参数\r\n\r\n​\t1.传递参数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <li v-for=\"m in messagelist\" :key=\"m.id\">             <!– 跳转路由并携带query参数，to的字符串写法 –>             <!– <router-link :to=\"/home/message/detail?id=${m.id}&title=${m.title}\">{{ m.title }}</router-link>&nbsp;&nbsp; –>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"        <!-- 跳转路由并携带query参数，to的对象写法 -->\r\n        <router-link :to=\"{\r\n            path:'/home/message/detail',\r\n            query:{\r\n               id:m.id,\r\n               title:m.title                     \r\n            }\r\n        }\">\r\n            {{ m.title }}\r\n        </router-link>\r\n        &nbsp;&nbsp;\r\n    </li>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n2.接收参数：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue  route.query.id   route.query.title ","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 5.命名路由\r\n\r\n1.作用：可以简化路由的跳转\r\n\r\n2.如何使用\r\n\r\n​\t1.给路由命名：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js export default new VueRouter({     routes:[       {         name:'guanyu',         path:'/about',         component:About       },       {         path:'/home',         component:Home,         children:[           {             // 这里不用加斜杠             path:'news',             component:News,           },           {             path:'message',             component:Message,             children:[               {                 name:'xiangqing',                 path:'detail',                 component:Detail               }             ]           },         ]       },      ] })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n2.简化跳转：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue //1.简化前写完整路径 <router-link :to=\"{                 path:/home/message/detail',                 query:{                    id:m.id,                    title:m.title                                      }             }\"> //2.简化后直接通过名字跳转 <router-link :to=\"{                 name:'xiangqing',                 query:{                    id:m.id,                    title:m.title                                      }             }\">","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 6.路由的params参数\r\n\r\n1.配置路由，声明接收params参数\r\n\r\n2.传递参数\r\n\r\n注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\r\n\r\n3.接收参数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue route.params.id route.params.title","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 7.路由的props配置\r\n\r\n作用：让路由组件更方便的收到参数\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js {                 name:'xiangqing',                 path:'detail',                 component:Detail,         // props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件         // props:{a:1,b:'hello'}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"   // props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件。\r\n   // props:true\r\n\n  // props的第三种写法，值为函数,该函数返回的对象中每一组key-value都会通过props传给Detail组件\r\n            props($route){\r\n              return {\r\n                id:$route.query.id,\r\n                title:$route.query.title,\r\n              }\r\n          }\r\n      }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 8.router-link 的replace属性\r\n\r\n​\t1.作用：控制路由跳转时操作浏览器历史记录的模式\r\n\r\n​\t2.浏览器的历史记录有两种写入方式：分别为push和replace,push是追加历史记录，replace是替换当前记录。路由跳转时默认为push\r\n\r\n​\t3.如何开启replace模式：\r\n\r\n​\t<router-link replace ='true'>News</router-link>\r\n\r\n\r\n\r\n#### 9.编程式路由导航\r\n\r\n​\t1.作用：不借助router-link实现路由跳转，让路由跳转更加灵活\r\n\r\n​\t2.具体编码：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js //router的5个API thisrouter.push this.routerreplace thisrouter.forward //前进 this.routerback\t后退 thisrouter.go\t\t//可前进可后退","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 10.缓存路由组件\r\n\r\n1.作用：让不展示的路由组件保持挂载，不被销毁\r\n\r\n2.具体编码：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue <keep-alive include=\"MyNews\">             <router-view></router-view> </keep-alive>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 11.两个新的生命周期钩子\r\n\r\n1.作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。\r\n\r\n2.具体名字：\r\n\r\n​\t\t1.`activated` 路由组件被激活时触发。\r\n\r\n​\t\t2.`deactivated` 路由组件失活时触发。\r\n\r\n\r\n\r\n#### 12.路由守卫\r\n\r\n##### 1.作用：\r\n\r\n对路由进行权限控制\r\n\r\n##### 2.分类：\r\n\r\n全局守卫、独享守卫、组件内守卫\r\n\r\n##### 3.全局守卫：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js // 全局前置路由守卫——初始化的时候被调用、每次路由切换之前被调用 router.beforeEach((to,from,next)=>{   console.log(to,from)   // 这里用to.name==='xinwen' ||to.name='xiaoxi'   if(to.meta.isAuth){       if(localStorage.getItem('school')==='jiaoda'){     next()   }else{       alert('学校名不对，无权限查看!')}   }else{     next()   } })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 全局后置路由守卫————初始化的时候被调用，每次路由切换之后被调用 router.afterEach((to,from)=>{   console.log(from)   document.title = to.meta.title  || '网页页面' })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n##### 4.独享守卫\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js  beforeEnter:(to,from,next)=>{               console.log(to,from)               // 这里用to.name==='xinwen' ||to.name='xiaoxi'               if(to.meta.isAuth){                   if(localStorage.getItem('school')==='jiaoda'){                 next()               }else{                   alert('学校名不对，无权限查看!')}               }else{                 next()               }     }}","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n独享守卫可以和全局路由后置守卫配合使用，但是独享守卫不可以与全局路由前置守卫一起使用，会发生覆盖的情况。\r\n\r\n##### 5.组件内守卫\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js // 通过路由规则，进入该组件时被调用     beforeRouteEnter(to,from,next){       console.log(to,from)     if(to.meta.isAuth){         if(localStorage.getItem('school')==='jiaoda'){       next()     }else{       alert('学校名不对，无权限查看!')}     }else{       next()     }     },","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"// 通过路由规则，离开该组件时被调用     beforeRouteLeave(to,from,next){       next()     }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 13.路由器的两种工作模式\r\n\r\n1.对于一个url来说，什么是hash值？——#及其后面的内容就是hsah值\r\n\r\n2.hsah值不会包含在HTTP请求中，即：hash值不会带给服务器。\r\n\r\n3.hash模式：\r\n\r\n​\t1.地址中永远带着#好，不美观\r\n\r\n​\t2.若以后将地址通过第三方手机app分享，若app校验合格，则地址会被标记为不合法。\r\n\r\n​\t3.兼容性较好\r\n\r\n4.history模式：\r\n\r\n​\t1.地址干净，美观\r\n\r\n​\t2.兼容性和hash模式相比略差\r\n\r\n​\t3.应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\r\n\r\n\r\n\r\n### 6.Vue UI组件库\r\n\r\n该部分无需笔记，直接看官方文档即可\r\n\r\n#### 1 .移动端常用 UI 组件库 \r\n\r\n​\t1.Vant https://youzan.github.io/vant \r\n\r\n​\t2.Cube UI https://didi.github.io/cube-ui \r\n\r\n​\t3.Mint UI http://mint-ui.github.io \r\n\r\n\r\n\r\n#### 2 .PC 端常用 UI 组件库 \r\n\r\n1. Element UI https://element.eleme.cn \r\n\r\n2. IView UI https://www.iviewui.co\r\n\r\n\r\n\r\n## 4.Vue3笔记\r\n\r\n### 0.引言\r\n\r\n#### 1.    3.0发布的地址：\r\n\r\nhttps://github.com/vuejs/core/releases/tag/v3.0.0\r\n\r\n#### 2.     各个版本地址：\r\n\r\nhttps://github.com/vuejs/core/tags\r\n\r\n#### 3.vue3提升的方面\r\n\r\n##### 1.性能提升\r\n\r\n渲染更快，内存更小\r\n\r\n##### 2.源码升级\r\n\r\n1.使用Proxy代替defineProperty实现响应式\r\n\r\n2.重写虚拟 DOM的实现和Tree-Shanking\r\n\r\n##### 3.拥抱TypeScript\r\n\r\nVue3更好支持TypeScript    \r\n\r\nTS是未来前端所驱\r\n\r\n##### 4.新的特性\r\n\r\n###### 1.composition API(组合API)\r\n\r\nsetup配置\r\n\r\nref与reactive\r\n\r\nwatch与watchEffect\r\n\r\nprovide与inject\r\n\r\n###### 2.新的内置组件\r\n\r\nFragment\r\n\r\nteleport\r\n\r\nsuspense\r\n\r\n###### 3.其他改变\r\n\r\n新的生命周期钩子\r\n\r\ndata选项应始终被声明为一个函数\r\n\r\n移除keyCode支持作为v-on的修饰符\r\n\r\n\r\n\r\n### 1.创建Vue3.0工程\r\n\r\n#### 1.使用脚手架vue-cli创建\r\n\r\n官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\r\n\r\n\r\n\r\n#### 2.使用vite创建\r\n\r\n官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\r\n\r\nvite官网：https://vitejs.cn\r\n\r\n**vite**------新一代前端**构建工具**（grunt、gulp、webpack）\r\n\r\n优势：1.开发环境中，无需打包操作，可快速冷启动\r\n\r\n​\t\t\t2.轻量快速的热重载（HMR）\r\n\r\n​\t\t\t3.真正的按需编译，不再等待整个应用编译完成。\r\n\r\n![image-20230922163244812](C:\\Users\\ccchhhddd\\Desktop\\Vue\\image-20230922163244812.png)\r\n","category":"page"},{"location":"Front-end/前端笔记/#创建工程","page":"前端笔记","title":"创建工程","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"npm init vite-app <project-name>","category":"page"},{"location":"Front-end/前端笔记/#进入工程目录","page":"前端笔记","title":"进入工程目录","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"cd <project-name>","category":"page"},{"location":"Front-end/前端笔记/#安装依赖","page":"前端笔记","title":"安装依赖","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"npm install","category":"page"},{"location":"Front-end/前端笔记/#运行","page":"前端笔记","title":"运行","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"npm run dev","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n### 2.常见Composition（组合式） API\r\n\r\n\r\n\r\n#### 1.拉开序幕的setup\r\n\r\n**1.理解：**Vue3.0中一个新的配置项，值为一个函数\r\n\r\n**2.setup是所有Composition API(组合API)\"表演的舞台\"**\r\n\r\n**3.组件中所用到的：**数据、方法等等，均要配置在setup中\r\n\r\n**4.setup函数的两种返回值：**\r\n\r\n​\t1.若返回一个对象，则对象中的属性、方法，在模版中均可以直接使用。（重点关注！）\r\n\r\n​\t2.若返回一个渲染函数：则可以自定义渲染内容（了解）\r\n\r\n**5.注意点：**\r\n\r\n​\t1.尽量不要与vue2.x配置混用\r\n\r\n​\t\tvue.x的配置可以访问setup中的属性、方法\r\n\r\n​\t\t但在setup中不能访问到Vue2.x配置（data、methos、computed...）\r\n\r\n​\t\t如有重名，setup优先\r\n\r\n​\t2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise,模版看不到return对象中的属性。（后期也可以返回一个promise实例，但需要suspense和异步组件的配合）\r\n\r\n\r\n\r\n#### 2.ref函数\r\n\r\n**作用：**定义一个响应式的数据\r\n\r\n**语法：**const xxx=ref(initValue)\r\n\r\n​\t\t创建一个包含响应式数据的**引用对象（reference对象,简称ref对象）**\r\n\r\n​\t\tJS中操作数据 xxx.value\r\n\r\n​\t\t模版中读取数据：不需要 .value , 直接： <div>{{xxx}}</div>\r\n\r\n**备注：**\r\n\t接收的数据可以是：基本类型，也可以是对象类型\r\n\r\n​\t基本类型的数据：响应式依然是靠 Object.defineProperty() 的get与set完成的\r\n\r\n​\t对象类型的数据：内部“求助”了Vue3.0中的一个新函数——reactive函数 \r\n\r\n\r\n\r\n#### 3.reactive函数\r\n\r\n作用：定义一个**对象类型**的响应式函数（基本类型不要用它，要用`ref`函数）\r\n\r\n语法：`const 代理对象 = reactive(源对象)`接收一个对象（或数组），返回一个**代理对象（proxy对象）**\r\n\r\nreactive定义的响应式数据是“深层次的”\r\n\r\n内部基于ES6的proxy实现，通过代理对象操作源对象内部数据进行操作\r\n\r\n\r\n\r\n#### 4. Vue3.0的响应式\r\n\r\n通过Proxy(代理)：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除\r\n\r\n通过Reflect(反射)：对被代理对象的属性进行操作\r\n\r\nMDN文档中描述的Proxy与Reflect\r\n\r\n\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"html //模拟Vue3中实现响应式     const p = new Proxy(person,{         // 有人读取p的某个属性时调用         get(target,propName){             console.log(有人读取p身上的${propName}属性)             return Reflect.get(target,propName)         },         // 有人修改p的某个属性、或给p追加某个属性时调用         set(target,propName,value){             console.log(有人修改p身上的${propName}属性,我要去更新界面了)             Reflect.set(target,propName,value)         },         // 有人删除p的某个属性时调用         deleteProperty(target,propName){             console.log(有人删除p身上的${propName}属性,我要去更新界面了)             return Reflect.deleteProperty(target,propName)         }     })","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n#### 5.reactive对比ref\r\n\r\n1.从定义数据角度对比：\r\n\r\n​\t\tref用来定义：基本类型数据\r\n\r\n​\t\treactive用来定义：对象（或数组）类型数据\r\n\r\n​\t\t备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象\r\n\r\n2.从原理角度对比：\r\n\t\tref通过object.defineProperty() 的get 与set来实现响应式（数据劫持）\r\n\r\n​\t\treactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据\r\n\r\n3.从使用角度对比：\r\n\r\n​\t\tref定义的数据：操作数据需要 .value,读取数据时模版中直接读取不需要.value\r\n\r\n​\t\treactive定义的数据：操作数据与读取数据：均不需要 .value\r\n\r\n\r\n\r\n#### 6.setup的两个注意点\r\n\r\n##### 1.setup执行的时机\r\n\r\n​\t\t在beforeCreate之前执行一次，this是undefined\r\n\r\n##### 2.setup参数\r\n\r\n​\t\tprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性\r\n\r\n​\t\tcontext:上下文对象\r\n\r\n​\t\t\t\t\tattrs:值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.$atters\r\n\r\n​\t\t\t\t\tslots:收到的插槽内容，相当于this.$slots\r\n\r\n​\t\t\t\t\temit:分发自定义事件的函数，相当于this.$emit\r\n\r\n\r\n\r\n#### 7.计算属性\r\n\r\n##### 1.computed函数\r\n\r\n与Vue2.x中computed配置功能一致\r\n\r\n写法：\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js import {computed} from 'vue'","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"setup(){     ... \t//计算属性——简写     let fullName = computed(()=>{         return person.firstName + '-' + person.lastName     })     //计算属性——完整     let fullName = computed({         get(){             return person.firstName + '-' + person.lastName         },         set(value){             const nameArr = value.split('-')             person.firstName = nameArr[0]             person.lastName = nameArr[1]         }     }) }","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 2.watch函数\r\n\r\n**与Vue2.x中watch配置功能一致**\r\n\r\n**两个小“坑”：**\r\n\r\n​\t1.监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\r\n\r\n​\t2.监视reactive定义的响应式数据中某个属性时：deep配置有效。\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js //情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=>{ \tconsole.log('sum变化了',newValue,oldValue) },{immediate:true})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=>{ \tconsole.log('sum或msg变化了',newValue,oldValue) }) ","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"/* 情况三：监视reactive定义的响应式数据 \t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ \t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视  */ watch(person,(newValue,oldValue)=>{ \tconsole.log('person变化了',newValue,oldValue) },{immediate:true,deep:false}) //此处的deep配置不再奏效","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//情况四：监视reactive定义的响应式数据中的某个属性 watch(()=>person.job,(newValue,oldValue)=>{ \tconsole.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) ","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//情况五：监视reactive定义的响应式数据中的某些属性 watch([()=>person.job,()=>person.name],(newValue,oldValue)=>{ \tconsole.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true})","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"//特殊情况 watch(()=>person.job,(newValue,oldValue)=>{     console.log('person的job变化了',newValue,oldValue) },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"\r\n\r\n\r\n##### 3.watchEffect函数\r\n\r\nwatch的套路是：既要指明监视的属性，也要指明监视的回调。\r\n\r\nwatchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\r\n\r\nwatchEffect有点像computed：\r\n\r\n​\t\t但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\r\n\r\n​\t\t而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。\r\n","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"js //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=>{     const x1 = sum.value     const x2 = person.age     console.log('watchEffect配置的回调执行了') }) ```","category":"page"},{"location":"Front-end/前端笔记/#.生命周期","page":"前端笔记","title":"8.生命周期","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"(Image: 组件生命周期图示)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\nVue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：\nbeforeCreate===>setup()\ncreated=======>setup()\nbeforeMount ===>onBeforeMount\nmounted=======>onMounted\nbeforeUpdate===>onBeforeUpdate\nupdated =======>onUpdated\nbeforeUnmount ==>onBeforeUnmount\nunmounted =====>onUnmounted","category":"page"},{"location":"Front-end/前端笔记/#.自定义hook函数","page":"前端笔记","title":"9.自定义hook函数","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"类似于vue2.x中的mixin。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。","category":"page"},{"location":"Front-end/前端笔记/#.toRef","page":"前端笔记","title":"10.toRef","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"语法：const name = toRef(person,'name')","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"应用: 要将响应式对象中的某个属性单独提供给外部使用时。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)","category":"page"},{"location":"Front-end/前端笔记/#.其它-Composition-API","page":"前端笔记","title":"3.其它 Composition API","text":"","category":"section"},{"location":"Front-end/前端笔记/#.shallowReactive-与-shallowRef","page":"前端笔记","title":"1.shallowReactive 与 shallowRef","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"shallowReactive：只处理对象最外层属性的响应式（浅响应式）。\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n什么时候使用?\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===> shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===> shallowRef。","category":"page"},{"location":"Front-end/前端笔记/#.readonly-与-shallowReadonly","page":"前端笔记","title":"2.readonly 与 shallowReadonly","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"readonly: 让一个响应式数据变为只读的（深只读）。\nshallowReadonly：让一个响应式数据变为只读的（浅只读）。\n应用场景: 不希望数据被修改时。","category":"page"},{"location":"Front-end/前端笔记/#.toRaw-与-markRaw","page":"前端笔记","title":"3.toRaw 与 markRaw","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"toRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。","category":"page"},{"location":"Front-end/前端笔记/#.customRef","page":"前端笔记","title":"4.customRef","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"实现防抖效果：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```vue   <template>   \t<input type=\"text\" v-model=\"keyword\">   \t<h3>{{keyword}}</h3>   </template>","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"<script>   \timport {ref,customRef} from 'vue'   \texport default {   \t\tname:'Demo',   \t\tsetup(){   \t\t\t// let keyword = ref('hello') //使用Vue准备好的内置ref   \t\t\t//自定义一个myRef   \t\t\tfunction myRef(value,delay){   \t\t\t\tlet timer   \t\t\t\t//通过customRef去实现自定义   \t\t\t\treturn customRef((track,trigger)=>{   \t\t\t\t\treturn{   \t\t\t\t\t\tget(){   \t\t\t\t\t\t\ttrack() //告诉Vue这个value值是需要被“追踪”的   \t\t\t\t\t\t\treturn value   \t\t\t\t\t\t},   \t\t\t\t\t\tset(newValue){   \t\t\t\t\t\t\tclearTimeout(timer)   \t\t\t\t\t\t\ttimer = setTimeout(()=>{   \t\t\t\t\t\t\t\tvalue = newValue   \t\t\t\t\t\t\t\ttrigger() //告诉Vue去更新界面   \t\t\t\t\t\t\t},delay)   \t\t\t\t\t\t}   \t\t\t\t\t}   \t\t\t\t})   \t\t\t}   \t\t\tlet keyword = myRef('hello',500) //使用程序员自定义的ref   \t\t\treturn {   \t\t\t\tkeyword   \t\t\t}   \t\t}   \t}   </script>   ```","category":"page"},{"location":"Front-end/前端笔记/#.provide-与-inject","page":"前端笔记","title":"5.provide 与 inject","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"作用：实现祖与后代组件间通信","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"具体写法：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"祖组件中：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":" ```js\r\n setup(){\r\n     ......\r\n     let car = reactive({name:'奔驰',price:'40万'})\r\n     provide('car',car)\r\n     ......\r\n }\r\n ```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"后代组件中：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":" ```js\r\n setup(props,context){\r\n     ......\r\n     const car = inject('car')\r\n     return {car}\r\n     ......\r\n }\r\n ```","category":"page"},{"location":"Front-end/前端笔记/#.响应式数据的判断","page":"前端笔记","title":"6.响应式数据的判断","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"isRef: 检查一个值是否为一个 ref 对象\nisReactive: 检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly: 检查一个对象是否是由 readonly 创建的只读代理\nisProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理","category":"page"},{"location":"Front-end/前端笔记/#.Composition-API-的优势","page":"前端笔记","title":"4.Composition API 的优势","text":"","category":"section"},{"location":"Front-end/前端笔记/#.Options-API-存在的问题","page":"前端笔记","title":"1.Options API 存在的问题","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"(Image: img)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"(Image: img)","category":"page"},{"location":"Front-end/前端笔记/#.Composition-API-的优势-2","page":"前端笔记","title":"2.Composition API 的优势","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"(Image: img)","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"(Image: img)","category":"page"},{"location":"Front-end/前端笔记/#.新的组件","page":"前端笔记","title":"5.新的组件","text":"","category":"section"},{"location":"Front-end/前端笔记/#.Fragment","page":"前端笔记","title":"1.Fragment","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"在Vue2中: 组件必须有一个根标签\n在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中\n好处: 减少标签层级, 减小内存占用","category":"page"},{"location":"Front-end/前端笔记/#.Teleport","page":"前端笔记","title":"2.Teleport","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"vue   <teleport to=\"移动位置\">   \t<div v-if=\"isShow\" class=\"mask\">   \t\t<div class=\"dialog\">   \t\t\t<h3>我是一个弹窗</h3>   \t\t\t<button @click=\"isShow = false\">关闭弹窗</button>   \t\t</div>   \t</div>   </teleport>","category":"page"},{"location":"Front-end/前端笔记/#.Suspense","page":"前端笔记","title":"3.Suspense","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"等待异步组件时渲染一些额外内容，让应用有更好的用户体验","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"使用步骤：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"异步引入组件","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```js\r\nimport {defineAsyncComponent} from 'vue'\r\nconst Child = defineAsyncComponent(()=>import('./components/Child.vue'))\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"使用Suspense包裹组件，并配置好default 与 fallback","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```vue\r\n<template>\r\n    <div class=\"app\">\r\n        <h3>我是App组件</h3>\r\n        <Suspense>\r\n            <template v-slot:default>\r\n                <Child/>\r\n            </template>\r\n            <template v-slot:fallback>\r\n                <h3>加载中.....</h3>\r\n            </template>\r\n        </Suspense>\r\n    </div>\r\n</template>\r\n```","category":"page"},{"location":"Front-end/前端笔记/#.其他","page":"前端笔记","title":"6.其他","text":"","category":"section"},{"location":"Front-end/前端笔记/#.全局API的转移","page":"前端笔记","title":"1.全局API的转移","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Vue 2.x 有许多全局 API 和配置。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"例如：注册全局组件、注册全局指令等。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```js\r\n//注册全局组件\r\nVue.component('MyButton', {\r\n  data: () => ({\r\n    count: 0\r\n  }),\r\n  template: '<button @click=\"count++\">Clicked {{ count }} times.</button>'\r\n})\r\n\r\n//注册全局指令\r\nVue.directive('focus', {\r\n  inserted: el => el.focus()\r\n}\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Vue3.0中对这些API做出了调整：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"将全局的API，即：Vue.xxx调整到应用实例（app）上","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"![image-20230924172504984](C:\\Users\\ccchhhddd\\Desktop\\image-20230924172504984.png)","category":"page"},{"location":"Front-end/前端笔记/#.其他改变","page":"前端笔记","title":"2.其他改变","text":"","category":"section"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"data选项应始终被声明为一个函数。","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"过度类名的更改：","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Vue2.x写法","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```css\r\n.v-enter,\r\n.v-leave-to {\r\n  opacity: 0;\r\n}\r\n.v-leave,\r\n.v-enter-to {\r\n  opacity: 1;\r\n}\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"Vue3.x写法","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```css\r\n.v-enter-from,\r\n.v-leave-to {\r\n  opacity: 0;\r\n}\r\n\r\n.v-leave-from,\r\n.v-enter-to {\r\n  opacity: 1;\r\n}\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"移除v-on.native修饰符","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"父组件中绑定事件","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```vue\r\n<my-component\r\n  v-on:close=\"handleComponentEvent\"\r\n  v-on:click=\"handleNativeClickEvent\"\r\n/>\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"子组件中声明自定义事件","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"```vue\r\n<script>\r\n  export default {\r\n    emits: ['close']\r\n  }\r\n</script>\r\n```","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"移除过滤器（filter）","category":"page"},{"location":"Front-end/前端笔记/","page":"前端笔记","title":"前端笔记","text":"过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。","category":"page"}]
}
