<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>前端笔记 · study-note</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/notes.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">study-note</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/优化问题1/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>前端笔记</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>前端笔记</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ccchhhddd/study-note/blob/main/docs/src/Front-end/前端笔记.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="前端笔记"><a class="docs-heading-anchor" href="#前端笔记">前端笔记</a><a id="前端笔记-1"></a><a class="docs-heading-anchor-permalink" href="#前端笔记" title="Permalink"></a></h1><h2 id=".说说console"><a class="docs-heading-anchor" href="#.说说console">0.说说console</a><a id=".说说console-1"></a><a class="docs-heading-anchor-permalink" href="#.说说console" title="Permalink"></a></h2><p>console语法     console是前端开发人员经常使用的调试工具，可以在控制台输出各种信息，以便快速地调试JavaScript代码。console语法与使用方法是入门前端开发中的必备技能之一。在本文中，将分步骤阐述console语法的基本知识。     1. console.log()         console.log()是console语法中最常用的方法。它可以在控制台输出任何类型的变量，如字符串、数字、数组、对象等。例如，下面的代码演示了如何使用console.log()方法输出一个字符串变量：</p><pre><code class="nohighlight hljs">const greeting = &quot;Hello World!&quot;;
console.log(greeting);
    ```
</code></pre><pre><code class="nohighlight hljs">当我们运行这段代码时，控制台将输出字符串&quot;Hello World!&quot;。通过console.log()方法，我们可以在控制台查看程序运行时的变量值，以便有效地调试代码。
2. console.error()
console.error()可以在控制台输出错误信息。它的输出会被标记为红色，以便开发者快速地定位问题。例如，下面的代码演示了如何使用console.error()方法输出一个错误信息：</code></pre><pre><code class="nohighlight hljs">
const num1 = 10;
const num2 = &quot;ABC&quot;;
if (isNaN(num1) || isNaN(num2)) {
  console.error(&quot;One or both variables are not numbers!&quot;);
}
</code></pre><pre><code class="nohighlight hljs">当我们运行这段代码时，控制台将输出错误信息&quot;One or both variables are not numbers!&quot;。通过使用console.error()方法，我们可以迅速识别程序中的错误，并排除故障。
3. console.warn()
console.warn()可以在控制台上输出警告信息，以便开发者识别可能存在的问题，但不一定需要处理。例如，下面的代码演示了如何使用console.warn()方法：</code></pre><pre><code class="nohighlight hljs">
const array = [1, 2, 3];
const index = 3;
if (index &gt; array.length - 1) {
  console.warn(&quot;Index out of range!&quot;);
}
</code></pre><pre><code class="nohighlight hljs">在这个例子中，当我们运行这段代码时，控制台会在index超出array长度范围时输出警告信息&quot;Index out of range!&quot;。通过使用console.warn()方法，我们可以识别问题并采取适当的行动，以避免产生更严重的后果。
4. console.group()
console.group()可用于将控制台信息分组显示，并便于开发者快速识别不同部分的输出。例如，下面的代码演示了如何使用console.group()方法：</code></pre><pre><code class="nohighlight hljs">
console.group(&quot;UI Components&quot;);
console.log(&quot;Header&quot;);
console.log(&quot;Navigation Bar&quot;);
console.groupEnd();
    console.group(&quot;Functions&quot;);
console.log(&quot;CalculateTax()&quot;);
console.log(&quot;CalculateInterest()&quot;);
console.groupEnd();
</code></pre><pre><code class="nohighlight hljs">在这个例子中，控制台中的输出将分成两个组：一个是UI组件，另一个是函数。通过使用console.group()方法，我们可以让控制台输出更整洁，并增强代码的可读性。
总之，console语法是前端开发的重要组成部分，学习和掌握它可以帮助我们更快地、更高效地调试代码。通过本文的介绍，我们了解了console语法中常用的一些方法和用法，包括console.log()、console.error()、console.warn()和console.group()。当我们在开发JavaScript应用程序时，应该善于利用这些工具来使我们的代码更加健壮和可靠。</code></pre><pre><code class="nohighlight hljs">








## 1.ES （EcmaScript）

简介：脚本语言的规范。javascript是ES的一种实现。1.语法简洁2.框架开发应用3.前端开发职位要求





ES6前端发展趋势，就业必备技能



## 2.JavaScript

语法大全网站地址： https://blog.csdn.net/qq_51657072/article/details/128831333

const ——设置常量
</code></pre><p>javascript ##JavaScript const todos=[ {     id:1,     text:&quot;go on&quot;,     isCompleted : true, }, {     id:2,     text:&quot;fly away&quot;,     isCompleted : true, }, {     id:3,     text:&quot;try it out&quot;,     isCompleted : true, }, ]; const todoJSON = JSON.stringify(todos) for (let todo of todos){ console.log(todo.text); } alert(&quot;验证正确&quot;);//弹窗显示 document.write(todos[0].text);//网页显示</p><p>&lt;!–html里注释是这样写的–&gt; /<em>js和css里的多行注释这样写</em>/ //单行注释</p><pre><code class="nohighlight hljs">


### 正则表达

1.限定符 ？ *  + {...}

2.或 |运算符

3.字符类 元字符

4.贪婪与懒惰匹配



正则表达表单网站：

https://r2coding.com/#/README?id=%e5%b8%b8%e7%94%a8%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e7%a4%ba%e4%be%8b





## 3.Vue2笔记

nodejs

node express

webpack

### 1.Vue核心+组件化编程

#### 1.初识Vue：

要点：

1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；

2.root容器里的代码符合html规范，只不过混入了一些特殊得Vue语法

3.root容器里的代码被称为[vue模版]

4.容器和实例一一对应

5.注意区分js表达式和js代码（语句）

**表达式：**一个表达式会产生一个值，可以放在任何一个需要值的地方

(1).a

(2)a+b

(3)demo(1)

(4)x===y?&#39;a&#39;:&#39;b&#39;    [三目表达式]

**js代码（语句）**

(1)if(){}

(2)for(){}





#### 2.模版语法

v-bind ====&gt;简写为   ：

vue 模版语法有2大类：

**1.插值语法：**

功能：用于解析标签体内容

写法：{{xxx}},xxx是js表达式，且可以直接读取到data中的所有属性。

**2.指令语法：**

功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）

举例：v-bind:href=&quot;xxx&quot;或简写为  :href=&quot;xxx&quot;，xxx同样要写js表达式且可以直接读取到data中的所有属性

备注：Vue中有很多的指令，且形式都是：v-????,此处我们只是拿v-bind举例子
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;模版语法&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id=&quot;root&quot;&gt;     &lt;h1&gt;插值语法&lt;/h1&gt;     &lt;h3&gt;你好，{{name}}&lt;/h3&gt;     &lt;hr/&gt;     &lt;h1&gt;指令语法&lt;/h1&gt;     &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot;&gt;点我去百度&lt;/a&gt;     &lt;a :href=&quot;school.url&quot;&gt;点我又去百度&lt;/a&gt;     &lt;/div&gt;</p><pre><code class="nohighlight hljs">&lt;script type=&quot;text/javascript&quot;&gt;
new Vue({
    el:&quot;#root&quot;,
    data:{
        name:&#39;chd&#39;,
        school:{
            name:&quot;chdchd&quot;,
            url:&quot;https://www.baidu.com/?tn=15007414_20_dg&quot;

        }
        
    }
})
&lt;/script&gt;</code></pre><p>&lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 3.数据绑定

Vue中有2种数据绑定方式：

1.单项绑定（v-bind）：数据只能从data流向页面。

2.双向绑定（v-model）:数据不仅能从data流向页面，还能从页面流向data

备注：

​	1.双向绑定一般都应用在表单类元素上（如：input、select等）

​	2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;数据绑定&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;!– 普通写法 –&gt;         单项数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;         双项数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt;</p><pre><code class="nohighlight hljs">    &lt;!-- 简写 --&gt;
    单项数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;
    双项数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;
    
    &lt;!-- 如下代码是错误的,因为v-model只能应用在表单类元素(输入类元素)上
    &lt;h2 v-model:x=&quot;name&quot;&gt;nihao&lt;/h2&gt; --&gt;
&lt;/div&gt;</code></pre><p>&lt;/body&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             name:&quot;chd&quot;         }</p><pre><code class="nohighlight hljs">})</code></pre><p>&lt;/script&gt;     &lt;/html&gt;</p><pre><code class="nohighlight hljs">




#### 4.el与data的两种写法

data与el的2种写法

##### 1.el有2种写法

（1) new Vue时候配置el属性

（2）先创建Vue实例，随后再通过vm.$mount(&#39;#root&#39;)指定el的值

##### 2.data有两种写法

（1）对象式

（2）函数式

如何选择：组件运用时要用函数式

##### 3.一个重要的原则：

由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;h1&gt;你好，{{name}}&lt;/h1&gt;     &lt;/div&gt;</p><p>&lt;/body&gt;</p><pre><code class="nohighlight hljs">&lt;script type=&quot;text/javascript&quot;&gt;
    // const v = new Vue({
    //     //el:&#39;#root&#39;,//第一种写法
    //     data:{
    //         name:&#39;chd&#39;
    //     }
    // })
    // console.log(v)
    // v.$mount(&#39;#root&#39;)//第二种写法
    // 定时器演示
    // console.log(v)
    // setTimeout(() =&gt; {
    //     v.$mount(&#39;#root&#39;)
    // },1000);
new Vue({
    el:&#39;#root&#39;,
    // //data的第一种写法：对象式
    // data:{
    //     name:&#39;hello&#39;
    // }
    
    //data的第二种写法：函数式（组件时必须使用）
    data:function(){
        console.log(&#39;@@@&#39;,this)
        return{
            name:&#39;chhd&#39;
        }
    }
})
&lt;/script&gt;</code></pre><p>&lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 5.理解MVVM

**vue的设计受到了MVVM的启发**

**MVVM模型：**

1.M:模型（Model）:对应data中的数据

2.V：试图（View）:模版

3.VM：视图模型（ViewModel）:Vue实例对象

**观察发现**

1.data中所有的属性，最后都出现在vm上

2.vm身上所有的属性，以及Vue原型上所有属性，在Vue模版中都可以直接使用
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt;         &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt;           &lt;h1&gt;测试一下1:{{1+1}}&lt;/h1&gt;         &lt;h1&gt;测试一下1:{{_c}}&lt;/h1&gt;         &lt;!– VIEW –&gt;     &lt;/div&gt;</p><p>&lt;/body&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     vm = new Vue({//VIEWMODEL         el:&#39;#root&#39;,         data:{             name:&#39;hello&#39;,             address:&#39;beijing&#39; //MODEL         }     })     console.log(vm) &lt;/script&gt;     &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 6.数据代理

**1.回顾Object.defineProperty方法**
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;回顾Object.defineProperty方法&lt;/title&gt;     &lt;!– &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; –&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;</p><pre><code class="nohighlight hljs">&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     let number =20     let person = {         name:&#39;ss&#39;,         sex:&#39;nan&#39;,</p><pre><code class="nohighlight hljs">}

Object.defineProperty(person,&#39;age&#39;,{
    // value:18,
    // enumerable:true,//可枚举
    // writable:true,//可修改
    // configurable:true, //控制属性是否被删除 
    
    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
    get:function(){
        return number
    },


    //当有人修改person的age属性时，set函数（setter）就会被调用，且会收到修改的具体值
    set(value){
        console.log(&#39;sss&#39;,value)
        number=value
    }
})  
console.log(Object.keys(person))
console.log(person)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


**2.何为数据代理**

数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;何为数据代理&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!– 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） –&gt; &lt;script type=&quot;text/javascript&quot;&gt;     let obj={x:100}     let obj2={y:200}</p><pre><code class="nohighlight hljs">Object.defineProperty(obj2,&#39;x&#39;,{
  get(){
    return obj.x
  },
  set(value){
    obj.x = value
  }
  //简单来说就是通过改变obj2.x里的数改变了obj的x。这就是一个简单的数据代理
})</code></pre><p>&lt;/script&gt; &lt;/body&gt;   &lt;/html&gt;</p><pre><code class="nohighlight hljs">


**3.Vue中的数据代理**
</code></pre><p>数据代理就好比右图中的实线部分，实现的功能好比就是将data里的name和address放在vm里。这样在编写代码时更为方便，不用vm._data.name这样的写法，而直接vm.name即可。背后的逻辑也是实现了getter()和setter()的这样一个过程，也就是通过Object.defineProperty进行的实现。</p><pre><code class="nohighlight hljs">
![image-20230803195743858](C:\Users\ccchhhddd\Desktop\image-20230803195743858.png)
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;         &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm =new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;ccchhhddd&#39;,             address:&#39;beijing&#39;         }         //埋一个数据劫持的坑     }) &lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 7.事件处理

##### **1.事件的基本使用：**

1.使用v-on：xxx 或 @xxx 绑定事件，其中xxx是事件名；

2.事件的回调需要配置在methods对象中，最终会在vm上；

3.methods中配置的函数，不要用箭头函数：否则this就不是vm了

4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；

5.@click=&quot;demo&quot; 和@click=&quot;demo&quot;($event)效果一致，但后者可以传参；
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;h2&gt;{{name}}欢迎你&lt;/h2&gt;         &lt;button v-on:click=&quot;showInfo1&quot;&gt;点我提示信息（不传参）&lt;/button&gt;         &lt;button v-on:click=&quot;showInfo2(66,event)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;</p><pre><code class="nohighlight hljs">const vm=new Vue({
    el:&#39;#root&#39;,
    data:{
        name:&#39;Beijing&#39;
    },
    methods:{
        showInfo1(event){
            console.log(event.target)
            alert(&#39;nihao&#39;)
        },
        showInfo2(number,event){//最好别放在data里，会进行无意义的数据代理，这个东西只是用来被别人调用的
            console.log(number,event)
            alert(number)
        }
    }
})</code></pre><p>&lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;</p><pre><code class="nohighlight hljs">


**补充概念：JavaScript事件的冒泡**

##### 事件冒泡的概念

事件冒泡是指当一个元素触发了某个事件（例如点击事件），该事件将从最内层的元素开始，逐级向外传播到父元素，直到传播到文档根节点。这种事件传播的过程就是事件冒泡。

##### 事件冒泡的处理方式

在处理事件冒泡时，有两种常用的方式：停止事件冒泡和使用事件委托。

##### 停止事件冒泡

通过停止事件冒泡，可以阻止事件继续向父元素传播。在事件处理函数中，可以使用event.stopPropagation()方法来停止事件冒泡。调用该方法后，事件将不再传播到父元素。



##### 2.事件修饰符

vue中的事件修饰符：

1.prevent:阻止默认事件（常用）

2.stop:阻止事件冒泡（常用）

3.once:事件只触发一次（常用）

4.capture：使用事件的捕获模式 

5.self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生

6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;     &lt;style&gt;         /*  通配符*  */         *{             margin-top :20px;         }         .demo1{             height: 50px;             background-color: aqua;         }         .box1{             padding: 5px;             background-color: skyblue;         }         .box2{             padding: 5px;             background-color: orange;         }         .list{             width:200px;             height: 200px;             background-color: peru;             overflow: auto;         }         li{            height: 100px;          }     &lt;/style&gt;</p><p>&lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;!– prevent:阻止默认事件（常用） –&gt;         &lt;a href=&quot;https://www.baidu.com/?tn=15007414<em>20</em>dg&quot; @click.prevent=&quot;showInfo&quot;&gt;点击去{{name}}&lt;/a&gt;         &lt;!–stop:阻止事件冒泡（常用） –&gt;     &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;         &lt;button @click.stop=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;     &lt;/div&gt;</p><pre><code class="nohighlight hljs">&lt;!--once:事件只触发一次（常用）  --&gt;
&lt;button @click.once=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;</code></pre><p>&lt;/br&gt;     &lt;!– capture：使用事件的捕获模式 –&gt;     &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;         div1         &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;         div2            &lt;/div&gt;     &lt;/div&gt;</p><pre><code class="nohighlight hljs">&lt;!-- self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生 --&gt;
&lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
&lt;button @click=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;
&lt;/div&gt;
&lt;!-- passive:事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;
&lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;百度&#39;         },     methods:{         showInfo(e){             // e.stopPropagation()             alert(&#39;同学你好&#39;)             //console.log(e.target)         },</p><pre><code class="nohighlight hljs">    showMsg(msg){
        console.log(msg)
    },
    demo(){
        for (let i=0;i&lt;100000;i++){
            console.log(&#39;#&#39;)
        }
        console.log(&#39;wanle&#39;)
    }
}
})</code></pre><p>&lt;/script&gt;  &lt;/body&gt;  &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 3.键盘事件

**1.vue中常用的按键别名：**

回车=&gt;enter

删除=&gt;delete(捕获“删除”和“退格键”)

退出=&gt;esc

空格=&gt;space

换行=&gt;tab

上=&gt;up

下=&gt;down

左=&gt;left

右=&gt;right

**2.Vue未提供别名的按键，**可以使用按键原始的key值去绑定，但注意要转为kebab-case(短横线命名)



**3.系统修饰键（用法特殊）**：ctrl、alt、shift、meta

​	(1)配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发

（2）配合keydown使用：正常触发事件



**4.也可以使用keyCode去指定具体的按键（不推荐）**

**5.Vue.config.keyCodes.自定义键名=键码，可以去定制按键别名** （  直接关机键绑事件  【狗头】）



##### 4.事件总结

修饰符可以连写

例如：@keyup.ctrl.y   或者@click.stop.prevent







#### 8.计算属性

**计算属性：**

1.定义：要用的属性不存在，要通过已有属性计算得来

2.原理：底层借助了Object.defineproperty方法提供的getter和setter

3.get函数什么时候执行？

（1）初次读取时会执行一次

（2）当依赖的数据发生变化时会被再次调用

4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。

5.备注：

​	1.计算属性最终会出现在vm上，直接读取使用即可

​	2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。

​	
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         姓：&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;&lt;br/&gt;&lt;br/&gt;         名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;&lt;br/&gt;&lt;br/&gt;         测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm = new Vue({         el:&#39;#root&#39;,         data:{             firstname:&#39;张&#39;,             lastname:&#39;三&#39;,             x:&#39;你好&#39;         },         computed:{             fullname:{             //get有什么作用？当有人读取fullname时，get就会被调用，且返回值就作为fullname的值             //get什么时候调用？1.初次读取fullname时2.所依赖的数据发生变化时             get() {                 console.log(&#39;get被调用&#39;)                 //console.log(this)//此处的this=vm                 return this.firstname +&#39;-&#39;+ this.lastname             },             //set什么时候调用？当fullName被修改时             set(value){                 console.log(&#39;set被调用&#39;,value)                     const arr = value.split(&#39;-&#39;)                 this.firstname = arr[0]                 this.lastname = arr[1]             }              }         }</p><pre><code class="nohighlight hljs">})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 9.监视属性

##### 1.监视属性watch:

1.当被监视的属性变化时，回调函数自动调用，进行相关操作

2.监视的属性必须存在，才能进行监视

3.监视的两种写法;

（1）new Vue时传入watch配置

（2）通过vm.$watch监视
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;        &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm = new Vue({         el:&#39;#root&#39;,         data:{             isHot:true,         },         computed:{             info(){                 return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视的两个方法         // watch:{         //     isHot:{         //     immediate:true,//初始化时让handler调用一下         //     //handler什么时候调用？当isHot发生改变时。         //     handler(newvalue,oldvalue){         //         console.log(&#39;info被修改了&#39;,newvalue,oldvalue)         //     }             //     }         // }</p><pre><code class="nohighlight hljs">})
vm.$watch(&#39;isHot&#39;,{
    immediate:true,//初始化时让handler调用一下
        //handler什么时候调用？当isHot发生改变时。
        handler(newvalue,oldvalue){
            console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
        } 

})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 2.深度监视

**要点：**

（1）Vue中的watch默认不监测对象内部值的改变（一层）

（2）配置deep:true可以监测对象内部值改变（多层）

**注：**

（1）Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以

（2）使用watch时根据数据的具体结构。决定是否采用深度监测
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;        &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;     &lt;hr/&gt;     &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt;     &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;     &lt;h3&gt;a的值是:{{numbers.b}}&lt;/h3&gt;     &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;     &lt;button @click=&quot;numbers = {a:666,b:888}&quot;&gt;彻底更换numbers&lt;/button&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm = new Vue({         el:&#39;#root&#39;,         data:{             isHot:true,             numbers:{              a:1,              b:1               }         },         computed:{             info(){                 return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视有两个方法         //方法一         watch:{             isHot:{             immediate:true,//初始化时让handler调用一下             //handler什么时候调用？当isHot发生改变时。             handler(newvalue,oldvalue){                 console.log(&#39;info被修改了&#39;,newvalue,oldvalue)             }         },              // 监视多级结构中某个属性的变化               &#39;numbers.a&#39;:{                 deep:true,                 handler(){                     console.log(&#39;a被改变了&#39;)                 }             }         }</p><pre><code class="nohighlight hljs">    //监视多级结构中所有属性的变化
    // numbers:{
    //         deep:true,
    //         handler(){
    //             console.log(&#39;numbers中有属性被改变了&#39;)
    //         }
    //     }   
    // }
    

})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 3.监视属性_简写
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;        &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm = new Vue({         el:&#39;#root&#39;,         data:{             isHot:true,         },         computed:{             info(){                 return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;             }         },         methods: {             cw(){                 this.isHot = ! this.isHot             }         },         //监视有两个方法         //方法一         watch:{             // isHot:{             // //正常写法             // immediate:true,//初始化时让handler调用一下             // //handler什么时候调用？当isHot发生改变时。             // //deep:true ,//深度监视             // handler(newvalue,oldvalue){             //     console.log(&#39;info被修改了&#39;,newvalue,oldvalue)             //         }             //     }         //简写         // isHot(newvalue,oldvalue){         //     console.log(&quot;isHot被修改&quot;,newvalue,oldvalue)         // }         }})         //正常写法         // vm.watch(&#39;isHot&#39;,{immediate:true,//初始化时让handler调用一下         //     // //handler什么时候调用？当isHot发生改变时。         //     // //deep:true ,//深度监视         //      handler(newvalue,oldvalue){         //          console.log(&#39;info被修改了&#39;,newvalue,oldvalue)         //              }         //          }</p><pre><code class="nohighlight hljs">    // )
    //简写 
    vm.$watch(&#39;isHot&#39;,function(newvalue,oldvalue){
        console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
    })</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 4.计算属性和监视属性的区别（computed和watch）

1.computed能完成的功能，watch都可以完成

2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作



##### **重要原则：**

1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象

2.所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数、promise回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。


</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;姓名案例_watch实现&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         姓：&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;&lt;br/&gt;&lt;br/&gt;         名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;&lt;br/&gt;&lt;br/&gt;         姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm = new Vue({         el:&#39;#root&#39;,         data:{             firstname:&#39;张&#39;,             lastname:&#39;三&#39;,             fullname:&quot;张-三&quot;//初始值需要自己设定         },         watch:{             firstname(newvalue){                 setTimeout(() =&gt; {//这个地方要写成箭头函数，括号里，没写东西，所以就往外找，this就指定为vm。否则指定为Windows，由js引擎帮忙调用                     this.fullname = newvalue +&#39;-&#39; +this.lastname                 }, 1000);</p><pre><code class="nohighlight hljs">        },
        lastname(newvalue){
            this.fullname = this.firstname+&#39;-&#39; + newvalue
        },
        
        }
    }

       
    
    
)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 10.绑定样式
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;style&gt;         .basic{             width: 400px;             height: 100px;             border: 1px solid black;         }         .sad{             border-color: green;             background-color: gray;         }         .happy{             border-color: red;             background-color: yellow;         }         .normal{             border-color: blue;             background-color: brown;         }         .chd1{             font-style: oblique;         }         .chd2{             font-size: 30px;                    }         .chd3{             border-color: skyblue;         }     &lt;/style&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;!– 绑定class样式–字符串写法，适用于：样式的类别不确定，需要动态指定 –&gt;     &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;change&quot;&gt;{{name}}&lt;/div&gt;     &lt;/br&gt;&lt;/br&gt;     &lt;!– 绑定class样式–数组写法，适用于：适用于要样式个数不确定，名字也不确定 –&gt;     &lt;div class=&quot;basic&quot; :class=&quot;arr&quot; &gt;{{name}}&lt;/div&gt;     &lt;/br&gt;&lt;/br&gt;     &lt;!– 绑定class样式–数组写法，适用于：适用于要绑定样式个数确定，名字也确定，但要动态决定用不用 –&gt;     &lt;div class=&quot;basic&quot; :class=&quot;classobj&quot;&gt;{{name}}&lt;/div&gt;     &lt;/br&gt;&lt;/br&gt;     &lt;!– 绑定style样式–对象写法 –&gt;     &lt;div class=&quot;basic&quot; :style=&quot;styleobj&quot;&gt;{{name}}&lt;/div&gt;</p><pre><code class="nohighlight hljs">&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     const vm=new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;ccchhhddd&#39;,             mood:&quot;basic&quot;,             arr:[&#39;chd1&#39;,&#39;chd2&#39;,&#39;chd3&#39;],             classobj:{                 chd1:false,                 chd2:false,             },             styleobj:{                 fontSize:&#39;40px&#39;,                 color: &#39;red&#39;,                 backgroundColor:&#39;green&#39;             }         },         methods: {             change(){                 const arr =[&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;]                 const index = Math.floor(Math.random()*3)                 this.mood = arr[index]             }</p><pre><code class="nohighlight hljs">    },
})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 11.条件渲染

##### **1.v-if**

写法：

（1）v-if=&quot;表达式&quot;

（2）v-else-if=&quot;表达式&quot;

（3）v-else=&quot;表达式&quot;

适用于：切换频率较低的场景

特点：不展示的DOM元素直接被移除

注意：v-if可以和：v-else-if和v-else 一起使用。但要求结构不能被”打断“



##### **2.v-show**

写法：v-show=&quot;表达式&quot;

适用于：切换频率较高的场景

特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉



##### **3.备注:**

使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;         &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;         &lt;!– 使用v-show做条件渲染 –&gt;         &lt;!– &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到{{name}}&lt;/h2&gt;     –&gt;</p><pre><code class="nohighlight hljs">    &lt;!-- 使用v-if做条件渲染 --&gt;
    &lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到{{name}}&lt;/h2&gt; --&gt;

    &lt;!-- 注意： v-if和v-else-if这组结构中间不允许被打断 --&gt;
    &lt;div v-if=&quot;n===1&quot;&gt;angular&lt;/div&gt;
    &lt;div v-else-if=&quot;n===2&quot;&gt;react&lt;/div&gt;
    &lt;div v-else-if=&quot;n===3&quot;&gt;Vue&lt;/div&gt;
    &lt;div v-else&gt;hhh&lt;/div&gt;
    

    &lt;!-- v-if和template的配合使用（不能和v-show） --&gt;
    &lt;template v-if=&quot;n===1&quot;&gt;
        &lt;h2&gt;你好&lt;/h2&gt;
        &lt;h2&gt;chd&lt;/h2&gt;
        &lt;h2&gt;hhh&lt;/h2&gt;
    &lt;/template&gt;

&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;chd&#39;,             n:0         }     }) &lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 12.列表渲染

##### 1.基本列表

###### v-for指令：

1.用于展示列表数据

2.语法：v-for=&quot;(item,index) in xxx&quot; :key=&#39;yyy&#39;

3.可遍历：数组、对象、字符串、指定次数
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;         &lt;!– 遍历数组(用的最多) –&gt;     &lt;h2&gt;人员列表&lt;/h2&gt;     &lt;ul&gt;         &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;             {{p.name}}-{{p.age}}         &lt;/li&gt;     &lt;/ul&gt;</p><pre><code class="nohighlight hljs">&lt;!-- 遍历对象 --&gt;
&lt;h2&gt;汽车信息&lt;/h2&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;
        {{k}}-{{value}}
    &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 遍历字符串 --&gt;
&lt;h2&gt;测试遍历字符串&lt;/h2&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;
        {{index}}-{{char}}
    &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 遍历指定次数 --&gt;
&lt;h2&gt;测试遍历字符串&lt;/h2&gt;
&lt;ul&gt;
    &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;
        {{index}}-{{number}}
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             persons:[                 {id:&quot;001&quot;,name:&#39;张三&#39;,age:18},                 {id:&#39;002&#39;,name:&#39;李四&#39;,age:19},                 {id:&#39;003&#39;,name:&#39;王五&#39;,age:20}             ],             car:{                 name:&#39;奥迪A8&#39;,                 price:&#39;70万&#39;,                 color:&#39;red&#39;             },             str:&#39;hello&#39;</p><pre><code class="nohighlight hljs">    }
})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">




##### 2.Vue面试重点题：vue中的key有什么作用？（key的内部原理）

###### 1.虚拟DOM中key的作用：

​		key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：



###### 2.对比规则;

(1)旧虚拟DOM 中找到了与新虚拟DOM相同的key:

​		1)若虚拟DOM中的内容没变，直接使用之前的真实DOM

​		2）若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

（2）旧虚拟DOM中未找到与新虚拟DOM相同的key:

​		创建新的真实DOM，随后渲染到页面



###### 3.用index作为key可能会引发的问题：

​		1）若对数据进行：逆序添加、逆序删除等破坏顺序操作：

​					会产生没有必要的真实DOM更新===》 界面效果没问题，但效率低



​		2）如果结构中还包含输入类的DOM：

​				会产生错误DOM更新 ===》界面有问题



###### 4.开发中如何选择key?

​		1.最好使用每条数据的唯一标识作为key,比如 id、手机号、身份证号、学号等唯一标识

​		2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。



##### 3.列表过滤
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;列表过滤&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;人员列表&lt;/h2&gt;     &lt;input type=&quot;text&quot; placeholder=&quot;输入名字&quot; v-model=&quot;keyword&quot;&gt;     &lt;ul&gt;         &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;index&quot;&gt;             {{p.name}}-{{p.age}}-{{p.sex}}         &lt;/li&gt;     &lt;/ul&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     // 用watch实现     // new Vue({     //     el:&#39;#root&#39;,     //     data:{     //         keyword:&#39;&#39;,     //         persons:[     //             {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},     //             {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},     //             {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},     //             {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;},     //         ],     //         filPersons:[]</p><pre><code class="nohighlight hljs">//     },
//     watch:{
//         keyword:{
//             immediate:true,
//             handler(val){
//                 this.filPersons = this.persons.filter((p)=&gt;{
//                 return p.name.indexOf(val) !==-1
//             })
            
//         }
//         }
//     }
// })

new Vue({
    el:&#39;#root&#39;,
    data:{
        keyword:&#39;&#39;,
        persons:[
            {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
            {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
            {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
            {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;},
         ],
    },
    computed:{
        filPersons(){
           return this.persons.filter((p)=&gt;{
             return p.name.indexOf(this.keyword) !==-1   
            })
        }
    }          
    }
)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 4.列表排序
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;列表过滤&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;人员列表&lt;/h2&gt;     &lt;input type=&quot;text&quot; placeholder=&quot;输入名字&quot; v-model=&quot;keyword&quot;&gt;     &lt;button @click=&quot;sortType=2&quot;&gt;年龄升序&lt;/button&gt;     &lt;button @click=&quot;sortType=1&quot;&gt;年龄降序&lt;/button&gt;     &lt;button @click=&quot;sortType=0&quot;&gt;原顺序&lt;/button&gt;     &lt;ul&gt;         &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;             {{p.name}}-{{p.age}}-{{p.sex}}         &lt;/li&gt;     &lt;/ul&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt; // 列表排序用computed实现     new Vue({         el:&#39;#root&#39;,         data:{             keyword:&#39;&#39;,             sortType:0,//0原顺序，1降序，2升序             persons:[                 {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:12,sex:&#39;女&#39;},                 {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:11,sex:&#39;女&#39;},                 {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:28,sex:&#39;男&#39;},                 {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:50,sex:&#39;男&#39;},              ],         },         computed:{             filPersons(){                const arr= this.persons.filter((p)=&gt;{                  return p.name.indexOf(this.keyword) !==-1                    })</p><pre><code class="nohighlight hljs">            if(this.sortType){
                arr.sort((p1,p2)=&gt;{
                    return this.sortType ===1 ? p2.age-p1.age :p1.age-p2.age
                })
            }

            return arr
        }
    }          
    }
)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 5.vue监测数据改变的原理



data里的每一项数据（包括细分的数据）都有对应的getter和setter,以这样的方式实现数据的监测和修改

**如下图所示：**

![image-20230808092841959](C:\Users\ccchhhddd\Desktop\image-20230808092841959.png)
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;     &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt; // 列表排序用computed实现     const vm =new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;chd&#39;,             address:&quot;beijing&quot;,             student:{                 name:&#39;tom&#39;,                 age:{                     sage:20,                     tage:18                 }             }                     },                        }     ) &lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 6.Vue.set的使用

**用法**：

向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property

 (比如 `this.myObject.newProperty = &#39;hi&#39;`)

**注意：**

对象不能是 Vue 实例，或者 Vue 实例的根数据对象。
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;     &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;     &lt;hr/&gt;     &lt;h1&gt;学生信息&lt;/h1&gt;     &lt;button @click=&quot;addsex&quot;&gt;添加一个性别信息&lt;/button&gt;     &lt;h2&gt;学生姓名：{{student.name}}&lt;/h2&gt;     &lt;h2&gt;学生年龄：真实{{student.age.rage}},对外{{student.age.sage}}&lt;/h2&gt;     &lt;h2 v-if=&quot;student.sex&quot;&gt;性别:{{student.sex}}&lt;/h2&gt;     &lt;h2&gt;朋友们&lt;/h2&gt;     &lt;ul&gt;         &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;             {{f.name}}–-{{f.age}}         &lt;/li&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt; // 列表排序用computed实现     const vm =new Vue({         el:&#39;#root&#39;,         data:{             name:&#39;chd&#39;,             address:&quot;beijing&quot;,             student:{                 name:&#39;tom&#39;,                 age:{                     sage:20,                     rage:18                 },                 friends:[                     {name:&#39;eecc&#39;,age:30},                     {name:&#39;eveve&#39;,age:14}                 ]</p><pre><code class="nohighlight hljs">        }            
    },
    methods: {
        addsex(){
            Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
            // this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
        }
    },               
    }
)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 7.Vue监测数据改变的原理

Vue 将被侦听的数组的变更方法进行了**包裹**，所以它们也将会触发视图更新。这些被包裹过的方法包括：

- `push()`	
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

你可以打开控制台，然后对前面例子的 `items` 数组尝试调用变更方法。比如 `example1.items.push({ message: &#39;Baz&#39; })`



##### 8.总结Vue数据监测

Vue监视数据的原理：

**1.Vue会监视data中所有层次的数据**

**2.如何监测对象的数据？**

​	通过setter实现监视，且要在new Vue时就传入要检测的数据

（1）对象中后追加的属性，Vue默认不做响应式处理

（2）如需给后添加的属性做响应式，请使用如下API:
			Vue.set(targer,propertyName,value)或

​			vm.$set(target,propertyName/index,value)



**3.如何监测数组中的数据？**

​		通过包裹数组更新元素的方法实现，本质就是做了两件事：

​	（1）调用原生对应的方法对数组进行更新

​	（2）重新解析模版，进行更新页面



**4.在Vue修改数组中的某个元素一定要用如下方法：**

​	（1）使用这些API：push()  、pop() 、shift()  、unshift()  、splice()

​		(2)Vue.set()  或 vm.$set()



**注意：**Vue.set() 和vm.$set() 不能给vm或vm的根数据对象 添加属性！！！
</code></pre><p>vue spilce() 的一个用法 this.student.hobby.splice(0,1,&#39;xc&#39;) //Vue.set(this.student.hobby.0,&#39;xc&#39;) //this.set(this.student.hobby,0,&#39;xc&#39;)</p><pre><code class="nohighlight hljs">


#### 13.收集表单数据

**若：&lt;input type=&#39;text&#39;/&gt;**则v-model收集的是value值。用户输入就是value的值

**若：&lt;input type=&#39;radio&#39;/&gt;**,则v-model收集的是value值，且要给标签配置value值

**若：&lt;input type=&#39;checkbox&#39;/&gt;**

​	1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是bool值）

​	2.v-model 的初始值是数组，那么收集的是value组成的数组

**备注：v-model的三个修饰符：**

​	lazy:失去焦点再收集数据

​	number:输入字符串转为有效数字

​	trim:输入收尾空格过滤
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;       &lt;form @submit.prevent=&quot;demo&quot;&gt;</p><pre><code class="nohighlight hljs">    账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt;&lt;br/&gt;&lt;br/&gt;
    密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt;&lt;br/&gt;&lt;br/&gt;
    年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;&lt;br/&gt;&lt;br/&gt;
    性别：
    男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
    女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt;&lt;br/&gt;&lt;br/&gt;
    爱好：
    学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
    打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;play&quot;&gt;
    唱歌&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;sing&quot;&gt;&lt;br/&gt;&lt;br/&gt;
    所属校区
    &lt;select v-model=&quot;userInfo.city&quot;&gt;
        &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
        &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
        &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
        &lt;option value=&quot;nanjing&quot;&gt;深圳&lt;/option&gt;
    &lt;/select&gt;&lt;br/&gt;&lt;br/&gt;
    其他信息： 
    &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.baidu.com&quot;&gt;《用户协议》&lt;/a&gt;
    &lt;button&gt;提交&lt;/button&gt;
&lt;/form&gt;
&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             userInfo:{             account:&#39;&#39;,             password:&#39;&#39;,             sex:&#39;&#39;,             age:&#39;&#39;,             hobby:[],             city:&#39;&#39;,             other:&#39;&#39;,             agree:&#39;&#39;         }</p><pre><code class="nohighlight hljs">    },
    methods: {
        demo(){
           console.log(JSON.stringify(this.userInfo))
        }
    },
})</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 14.过滤器

定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑得处理）

语法:

​	1.注册过滤器： Vue.filter(name,callback) 或 new Vue(filters:{})

​	2.使用过滤器：{{ xxx | 过滤器名}}  或 v-bind: 属性 = ‘xxx |过滤器名’

备注：

​	1.过滤器也可以接受额外参数，多个过滤器也可以串联

​	2.并没有改变原本的数据，是产生新的对应的数据


</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/cdn.bootcdn.net<em>ajax</em>libs<em>dayjs</em>1.11.7_dayjs.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;       &lt;!–计算属性实现  –&gt;     &lt;h3&gt; 1现在是:{{fmtTime}}&lt;/h3&gt;</p><pre><code class="nohighlight hljs">&lt;!--methods实现 --&gt;
&lt;h3&gt; 2现在是:{{getfmtTime()}}&lt;/h3&gt;

&lt;!--过滤器实现 --&gt;
&lt;h3&gt; 3现在是:{{time | timeFormater}}&lt;/h3&gt;

&lt;!--过滤器实现(传参+串联) --&gt;
&lt;h3&gt; 4现在是:{{time | timeFormater(&#39;YYYY-MM-DD&#39;) | mySlice}}&lt;/h3&gt;
&lt;/div&gt;</code></pre><p>&lt;script type=&quot;text/javascript&quot;&gt;     //全局过滤器     // Vue.filters(&#39;mySlice&#39;,function(value){     //     return value.slice(0,4)     // })     new Vue({         el:&#39;#root&#39;,         data:{             time:1621561377603,//时间戳         },         computed:{             fmtTime(){                 return dayjs(this.time).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)             }         },         methods: {             getfmtTime(){                 return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)             }         },         //局部的过滤器         filters:{             timeFormater(value,str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;){                 return dayjs(value).format(str)             },             mySlice(value){                 return value.slice(0,4)             }         }     }                 ) &lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 15.内置指令

**v-bind :** 单向绑定解析表达式，可简写为： xxx

**v-model :** 双向数据绑定

**v-for :** 遍历数组/对象/字符串

**v-on ：** 绑定事件监听，可简写为@

**v-if :** 条件渲染（动态控制节点是否存在）

**v-else :** 条件渲染（动态控制节点是否存在）

**v-show :** 条件渲染（动态控制节点是否展示）



**v-text指令：**

​	1.作用：向其所在的节点中渲染文本内容

​	2.与差值语法的区别：v-text会替换掉节点中的内容，{{xx}}不会



**v-html指令：**

1.作用：向指定节点中渲染包含html结构的内容

2.与差值语法的区别：

​	（1）v-html会替换掉节点中所有的内容，{{xx}}不会

​	（2）v-html可以识别html结构

3.严重注意：v-html有安全性问题

​	（1）在网站上动态渲染任意html是非常危险的，容易导致XSS攻击

​	（2）一定要在可信的内容上使用v-html。永远不要在用户提交的内容上用v-html



**补充cookie:**

![image-20230811103728403](C:\Users\ccchhhddd\Desktop\image-20230811103728403.png)

![image-20230811103835634](C:\Users\ccchhhddd\Desktop\image-20230811103835634.png)



**v-clock指令**（没有值）：

​	1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-clock属性

​	2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。

**v-once指令：**

​	1.v-once所在节点在初次渲染后，被视为静态内容了

​	2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能

**v-pre指令：**

​	1.跳过其所在节点的编译过程

​	2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译



#### 16.自定义指令

总结：

一、定义语法：

（1）局部指令：

​		new Vue({

​	directives:{指令名：配置对象}

})

或

new Vue({

​	directives{指令名：回调函数}

})

（2）全局指令

​	Vue.directive{指令名，配置对象） 或Vue.directive(指令名，回调函数)



二、配置对象中常用的3个回调：

​		（1）bind:指令与元素成功绑定时调用

​		（2）inserted:指令所在元素被插入页面时调用

​		（3）update:指令所在模版结构被重新解析时调用



三、备注：

​		1.指令定义时不加v-,但使用时要加v-;

​		2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名（驼峰命名法）。


</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!– 需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍          需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。 –&gt;     &lt;div id =&quot;root&quot;&gt;      &lt;h2&gt;当前的n值是:&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;      &lt;h2&gt;放大10倍后的n值是:&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;      &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;      &lt;hr/&gt;      &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     new Vue({         el:&#39;#root&#39;,         data:{             n:1,         },         directives:{             //big函数何时会被调用？1.指令与元素成功绑定时（一上来）2.指令所在的模版被重新解析时             big(element,binding){                 element.innerText = binding.value*10                 //console.log(element,binding.value)             },             fbind:{                 //指令与元素成功绑定时（一上来）                bind(element,binding){                 element.value =binding.value                },                //指令所在元素被插入页面时                 inserted(element,binding){                     element.focus()                 },                 //指令所在的模版被重新解析时                 update(element,binding){                     element.value =binding.value                  },             }             }         }</p><pre><code class="nohighlight hljs">)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


#### 17.生命周期

**生命周期：**

1.又名：生命周期回调函数、生命周期函数、生命周期钩子

2.是什么：Vue在关键时刻帮助我们调用的一些特殊名称的函数

3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的

4.生命周期函数中的this指向是vm或组件实例对象	



**常用的生命周期钩子：**

1.mounted:发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】

2.beforeDestroy:清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】



**关于销毁Vue实例：**

1.销毁后借助Vue开发者工具看不到任何信息

2.销毁后自定义事件会失效，但原生DOM事件依然有效

3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。





**图示：**

![Vue 实例生命周期](https://v2.cn.vuejs.org/images/lifecycle.png)

#### 18.组件化编程

![image-20230816160242109](C:\Users\ccchhhddd\Desktop\image-20230816160242109.png)

##### **1.Vue中使用组件的三大步骤：**

1.定义组件（创建组件）

2.注册组件

3.使用组件



##### **一、如何定义一个组件？**

使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但区别如下：

1.el不要写，为什么？

——最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器

2.data必须写成函数，为什么？

——避免组件被复用，数据存在引用关系

备注：使用template可以配置组件结构



##### **二、如何注册组件？**

1.局部注册：靠new Vue的时候传入components选项

2.全局注册：靠Vue.component(&#39;组件名&#39;，组件)



##### **三、编写注册组件：**

&lt;school&gt;&lt;/school&gt;



**1.基本使用.html**
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!– 准备好一个容器 –&gt;     &lt;div id =&quot;root&quot;&gt;    &lt;!– 第三步:编写组件标签 –&gt;     &lt;school&gt;&lt;/school&gt;      &lt;hr&gt;     &lt;student&gt;&lt;/student&gt;     &lt;/div&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     //第一步：创建school组件     const a =Vue.extend({         //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理         template:<code>&lt;div&gt;         &lt;h2&gt;学校名称：{{schoolname}}&lt;/h2&gt;         &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;         &lt;button @click=&#39;showname&#39;&gt;点我提示学校名&lt;/button&gt;         &lt;/div&gt;</code>,         data(){//函数式             return{             schoolname:&#39;jiaoda&#39;,             address:&#39;xian&#39;,              }},             methods: {                 showname(){                     alert(this.schoolname)                 }             },</p><pre><code class="nohighlight hljs">    }
)
//第二步：创建student组件
const b =Vue.extend({
    
    //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理
    template:`
    &lt;div&gt;
    &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
    &lt;/div&gt;
    `,
    data(){
        return{
        name:&#39;chd&#39;,
        age:20, 
        }}     
    }
)


//创建vm
new Vue({
    el:&#39;#root&#39;,
    //第二步：注册组件（局部注册）
    components:{
        school:a,//组件名在这里定
        student:b
    }  }            
)</code></pre><p>&lt;/script&gt;  &lt;/body&gt; &lt;/html&gt;</p><pre><code class="nohighlight hljs">


##### 2.几个注意的要点

**1.关于组件名：**

一个单词组成：

​	第一种写法（首字母小写）：school

​	第二种写法（首字母大写）：School

多个单词组成：

​	第一种写法（kebab-case命名）：my-school

​	第二种写法（CamelCase命名）：MySchool(需要Vue脚手架支持)

备注:

​	(1)组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行

（2）可以使用name配置项指定组件在开发者工具中呈现的名字



**2.关于组件标签**

​	第一种写法：&lt;school&gt;&lt;/school&gt;

​	第二种写法：&lt;school/&gt;

​	备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。



**3.一个简写方式：**

 const school =Vue.extend(options) 可简写为：const school = options



##### 3.VueComponent

 关于VueComponent:

​	1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。

​	2.我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)

​	3.特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent !!!

​	4.关于this指向：

​		(1)组件配置中：

​				data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】

​	（2）new Vue(options)配置中：

​			data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】

​	5.VueComponent的实例对象、以后简称vc（也可称之为：组件实例对象）

Vue的实例对象，以后简称vm

​	6.因为组件是可复用的 Vue 实例，所以它们与 `new Vue` 接收相同的选项，例如 `data`、`computed`、`watch`、`methods` 以及生命周期钩子等。仅有的例外是像 `el` 这样根实例特有的选项。（vm和vc的异同）



##### 4.一个重要的内置关系

1.一个重要的内置关系：VueComponent.prototype.__proto__ ===Vue.prototype

2.为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性、方法

![image-20230829121059619](C:\Users\ccchhhddd\Desktop\image-20230829121059619.png)
</code></pre><p>html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;UTF-8&quot;&gt;     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;     &lt;title&gt;&lt;/title&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;!– 准备好一个容器 –&gt;     &lt;div id =&quot;root&quot;&gt;     &lt;school&gt;&lt;/school&gt;     &lt;/div&gt; &lt;/body&gt;</p><p>&lt;script type=&quot;text/javascript&quot;&gt;     Vue.prototype.x=99//得益于VueComponent.prototype.<strong>proto</strong> === Vue.prototype这个内置重要关系    const school =Vue.extend({         name:&#39;school&#39;,         //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理         template:<code>&lt;div&gt;         &lt;h2&gt;学校名称：{{schoolname}}&lt;/h2&gt;         &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;         &lt;button @click=&#39;showX&#39;&gt;点我输出X&lt;/button&gt;           &lt;/div&gt;</code>,         data(){//函数式             return{             schoolname:&#39;jiaoda&#39;,             address:&#39;xian&#39;,              }},         methods: {             showX(){             console.log(this.x)             },         },     })    const vm=new Vue({     el:&#39;#root&#39;,     data:{         msg:&#39;你好&#39;     },     components:{         school     }    })    //console.log(school.prototype.<strong>proto</strong> === Vue.prototype)     // function Demo(){     //     this.a=1     //     this.b=2     // }     // //创建一个Demo的实例对象     // const d= new Demo()</p><pre><code class="nohighlight hljs">// console.log(Demo.prototype) //显示原型属性
// console.log(d.__proto__)//隐式原型属性

// //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99
// Demo.prototype.x = 99

// console.log(&#39;@&#39;,d)</code></pre><p>&lt;/script&gt; </p><p>&lt;/html&gt;</p><pre><code class="nohighlight hljs">
### 2.使用Vue脚手架

#### 1.单文件组件+脚手架简介+相关函数+相关配置

xxxxx.Vue

**1.webpack**

**2.脚手架  Vue CLI  动能：浏览器不能直接识别并运行Vue文件，需要通过脚手架的环境配置的支持**

1. Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）。
2. 最新的版本是 4.x。
3. 文档: https://cli.vuejs.org/zh/

**3.模版目录框架**

├── node_modules

 ├── public 

│ ├── favicon.ico: 页签图标

 │ └── index.html: 主页面

 ├── src

 │ ├── assets: 存放静态资源 

│ │└── logo.png 

│ │── component: 存放组件

 │ │ └── HelloWorld.vue

 │ │── App.vue: 汇总所有组件

 │ │── main.js: 入口文件

 ├── .gitignore: git 版本管制忽略的配置

 ├── babel.config.js: babel 的配置文件

 ├── package.json: 应用包配置文件

 ├── README.md: 应用描述文件

 ├── package-lock.json：包版本控制文件



**4.render函数**

关于不同版本的Vue：

​	1.vue.js与vue.runtime.xxx.js的区别：

​		（1）vue.js是完整版的Vue  包含：核心功能+模版解析器

​		（2） vue.runtime.xxx.js是运行版的Vue ,只包含：核心功能，没有模版解析器

​	2.因为vue.runtime.xxx.js没有模版解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。
</code></pre><p>javascript main.js文件 //该文件是整个项目的入口文件 //引入Vue（注意：这里引入的vue只是大的文件夹，并没有指定到核心的vue.js，所以仍需要在下方引入render函数，做模版解析） import Vue from &#39;vue&#39; //引入App组件，它是所有组件的父组件 import App from &#39;./App.vue&#39; //关闭Vue的生产提示 Vue.config.productionTip = false</p><p>// 创建Vue的实例对象–-vm new Vue({   el:&#39;#app&#39;,   // 完成功能：将App组件放入容器中   render: h =&gt; h(App),  //render函数只用在这里写一遍 })</p><pre><code class="nohighlight hljs">
**5.vue.config.js配置文件**

使用vue inspect  &gt; output.js 可以查看到Vue脚手架的默认配置

使用vue.config.js可以对脚手架进行**个性化定制**，详情见：https://cli.vuejs.org/zh/config/#vue-config-js



**6.ref属性**

1.被用来给元素或子组件注册引用信息（id的替代者）

2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）

3.使用方式：

​		打标识：&lt;h1 ref=&#39;xxx&#39;&gt;.....&lt;/h1&gt;或&lt;School ref=&#39;xxx&#39;&gt;&lt;/SChool&gt;

​		获取：this.$refs.xxx



**7.配置项props**

​	功能：让组件接收外部传来的数据

​		（1）传递数据：

​			&lt;Demo name =&#39;xxx&#39;/&gt;

​		（2）接收数据：

​			第一种方式（只接收）：		
</code></pre><p>javascript  props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]//简单声明接收。 这里写了，data里就不能有了 </p><pre><code class="nohighlight hljs">
​			第二种方式（限制类型）：		
</code></pre><p>javascript // 接收的同时对数据进行类型限制         // props:{         //     name:String,         //     age:Number,         //     sex:String         // }</p><pre><code class="nohighlight hljs">
​				第三种方式（限制类型、限制必要性、指定默认值）：		
</code></pre><p>javascript props:{             name:{                 type:String, //name的类型是字符串                 required:true //name是必要的             },             age:{                 type:Number,                 default:99 //默认值             },             sex:{                 type:String,                 require:true             }         }</p><pre><code class="nohighlight hljs">
**备注：**props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。

如下是一个名叫Student.vue的文件例子
</code></pre><p>javascript &lt;template&gt;         &lt;div&gt;         &lt;h1&gt;{{ msg }}&lt;/h1&gt;         &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;         &lt;h2&gt;学生年龄：{{Myage}}&lt;/h2&gt;         &lt;button @click=&quot;chageage&quot;&gt;点我年龄++&lt;/button&gt;         &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;         &lt;/div&gt;        &lt;/template&gt;</p><p>&lt;script&gt;</p><pre><code class="nohighlight hljs">export default {
    name:&#39;MyStudent&#39;,   
    data(){//函数式
        return{
        msg:&#39;我是一名学生&#39;,
        Myage:this.age//这里利用的是props的优先级比data高实现的，也就是说程序先去扫描props里的数据。
        
        }},
        methods:{
            chageage(){
                this.Myage++
            }
        },
    // props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]//简单声明接收。 这里写了，data里就不能有了  

    // 接收的同时对数据进行类型限制
    // props:{
    //     name:String,
    //     age:Number,
    //     sex:String
    // }

    // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制
    props:{
        name:{
            type:String, //name的类型是字符串
            required:true //name是必要的
        },
        age:{
            type:Number,
            default:99 //默认值
        },
        sex:{
            type:String,
            require:true
        }
    }}</code></pre><p>&lt;/script&gt;</p><p>&lt;style&gt; &lt;/style&gt;</p><pre><code class="nohighlight hljs">
**8.mixin(混入)**

**功能：**可以把多个组件共用的配置提取成一个混入对象

**使用方法：**

​		第一步定义混合，例如：

{

data(){....},

methods:{....}

....

}

​	第二步使用混入，例如：

（1）全局混入：Vue.mixin(xxx)

（2）局部混入：mixins:[&#39;xxx&#39;]





**9.插件**

**功能：**用于增强Vue

**本质：**包含install方法的一个对象，install的第一个参数是Vue,第二个以后得参数是插件使用者传递的数据

**定义插件：**
</code></pre><p>javascript export default{     install(Vue,x,y,z){         console.log(x,y,z)</p><pre><code class="nohighlight hljs">//全局过滤器
Vue.filter(&#39;mySlice&#39;,function(value){
    return value.slice(0,4)
})
//定义全局指令
Vue.directive(&#39;fbind&#39;,{
    //指令与元素成功绑定时（一上来）
    bind(element,binding){
        element.value = binding.value
    },
//指令所在元素被插入页面时
inserted(element){
    element.focus()
},
//指令所在的模版被重新解析时
update(element,binding){
    element.value = binding.value
}
})

//定义混入
Vue.mixin({
    data(){
        return{
            x:100,
            y:200
        }
    }
})
//给Vue原型上添加一个方法
Vue.prototype.hello = ()=&gt;{alert(&#39;nihaoya&#39;)}
//添加实例方法
Vue.prototype.$myMethod = function(){...}
Vue.prototype.$myProperty = xxxx</code></pre><p>} }</p><pre><code class="nohighlight hljs">
**使用插件：**Vue.use()



#### 2.scoped样式

作用：让样式在局部生效，防止冲突

写法：&lt;style scoped&gt;
</code></pre><p>vue &lt;template&gt;         &lt;div class=&quot;demo&quot;&gt;         &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;         &lt;h2 class=&quot;qwe&quot;&gt;学生性别：{{sex}}&lt;/h2&gt;</p><pre><code class="nohighlight hljs">    &lt;/div&gt;</code></pre><p>&lt;/template&gt;</p><p>&lt;script&gt;         export default {         name:&#39;MyStudent&#39;,           data(){//函数式             return{             name:&#39;cccchhhhddd&#39;,             sex:&#39;男&#39;             }},</p><pre><code class="nohighlight hljs">    }</code></pre><p>&lt;/script&gt;</p><p>&lt;!– 要用less 要安装less-loader 指令：npm i less-loader –&gt; &lt;!– 用less的好处：可以嵌套着写 –&gt; &lt;style lang=&quot;less&quot; scoped&gt; // 不写lang就默认是CSS /* 加入scoped .demo就不担心存在重复的情况了,但此时demo只能在School组件里使用 */ .demo{   background-color:pink;   .qwe{     font-size:40px;   } } &lt;/style&gt;</p><pre><code class="nohighlight hljs">


#### 3.Todo-list案例

**组件化编码流程（通用）**

 1.实现静态组件：抽取组件，使用组件实现静态页面效果 

2.展示动态数据： 2.1. 数据的类型、名称是什么？ 2.2. 数据保存在哪个组件？ 

3.交互——从绑定事件监听开始



**注：**父亲给儿子可以传函数、数组.....在此基础上儿子调用先前父亲给儿子传的函数方法，儿子也可以给父亲传数据

![image-20230904180524916](C:\Users\ccchhhddd\Desktop\image-20230904180524916.png)



##### **总结todolist案例：**

##### 1.组件化编码流程：

​	（1）拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。

​	（2）实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：

​			1）一个组件再用：放在组件自身即可。

​			2)一些组件在用，放在他们共同的父组件上（&lt;span style=&#39;color:red&#39;&gt;状态提升&lt;/span&gt;）

​	（3）实现交互：从绑定事件开始

##### 2.props适用于：

​	(1)父组件==&gt;子组件 通信

​	(2)子组件===&gt;父组件 通信 （要求父先给子一个函数）

##### 3.使用v-model时要切记：

v-model绑定的值不能是props传过来的值，因为props是不可以修改的！

##### 4.props传过来的若是对象类型的值：

修改对象中的属性时Vue不会报错，但不推荐这样做



#### 4.webStorage（浏览器存储）

1.存储大小一般支持5MB左右（不同浏览器不一样）

2.浏览器通过Window.sessionStorage和Window.localStorage 属性来实现本地存储机制

3.相关API
</code></pre><ol><li>xxxxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;);</li></ol><p>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果建名存在，则更新其对应的值 2.xxxxxxStorage.getItem(&#39;person&#39;); 该方法接受一个建名作为参数，返回键名对应的值 3.xxxxxxStorage.removeItem(&#39;key&#39;); 该方法接受一个建名作为参数，并把该建名从存储中删除 4.xxxxxxStorage.clear() 该方法会清空存储中的所有数据</p><pre><code class="nohighlight hljs">
4.备注：
</code></pre><p>1.SessionStorage存储的内容会随着浏览器窗口关闭而消失 2.LocalStorage存储的内容，需要手动清除才会消失 3.xxxxxxStorage.getItem(xxxx) 如果xxx对应的value获取不到，那么getItem的返回值是null 4.JSON.parse(null)的结果依然是null</p><pre><code class="nohighlight hljs">


#### 5.组件的自定义事件

​	1.一种组件间通信的方式，适用于： 子组件==&gt;父组件

​	2.使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）

​	3.绑定自定义事件：

​		1.第一种方式，在父组件中：&lt;Demo @atguigu=&#39;test&#39;/&gt;  或&lt;Demo v-on:atguigu=&#39;test&#39;/&gt;

​		2.第二种方式，在父组件中：
</code></pre><p>vue &lt;Demo ref=&#39;demo&#39;/&gt; ...... mounted(){ this.<span>$refs.xxx.$</span>on(&#39;atguigu&#39;,this.test) }</p><pre><code class="nohighlight hljs">
​		3.若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法

4.触发自定义事件：this.$emit(&#39;atguigu&#39;,数据)

5.解绑自定义事件 this.$off(&#39;atguigu&#39;)

6.组件上也可以绑定原生DOM事件，需要使用native修饰符

7.注意：通过 this.$refs.xxx.$on(&#39;atguigu&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题。【直接用function,this指的是xxx组件】



#### 6.全局事件总线

1.一种组件间通信的方式，适用于任意组件间通信

2.安装全局事件总线：
</code></pre><p>new Vue({ 	...... 	boforeCreate(){ 		Vue.prototype.<span>$bus = this //安装全局事件总线，$</span>bus就是当前应用的vm         },     ..... })</p><pre><code class="nohighlight hljs">
3.使用事件总线：

​	1.接受数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身
</code></pre><p>javascript methods(){ 	demo(data){....} } ...... mounted(){ 	this.<span>$bus.$</span>on(&#39;xxxx&#39;,this.demo) }</p><pre><code class="nohighlight hljs">
​	2.提供数据：this.$bus.$emit(&#39;xxxx&#39;,数据)

4.最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件







**原理图：**

![image-20230906160131275](C:\Users\ccchhhddd\Desktop\image-20230906160131275.png)





#### 7.消息订阅与发布（pubsub）

1.一种组件间通信的方式，适用于任意组件间通信

2.使用步骤：

​	1.安装pubsub：npm i pubsub-js

​	2.引入： import pubsub from &#39;pubsub-js&#39;

​	3.接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身
</code></pre><p>vue methods(){ demo(data){....} } ...... mounted(){ this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息 }</p><pre><code class="nohighlight hljs">
​	4.提供数据： pubsub.publish(&#39;xxx&#39;,数据)

​	5.最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去&lt;span style=&#39;color:red&#39;&gt;取消订阅。&lt;/span&gt;



**原理图：**

![image-20230906221035052](C:\Users\ccchhhddd\Desktop\image-20230906221035052.png)



#### 8.nextTick

**1.语法：** this.$nextTick(回调函数)

**2.作用：** 在下一次DOM更新结束后执行其指定的回调

**3.什么时候用：**当改变数据后，要**基于更新后的新DOM进行某些操作时**，要在nextTick所指定的回调函数中执行
</code></pre><p>javascript handleEdit(todo){</p><pre><code class="nohighlight hljs">        if(&#39;isEdit&#39;== undefined){
            todo.isEdit = true
        }
        else{
            this.$set(todo,&#39;isEdit&#39;,true)
        }
        // 若没有外包一个东西的话，下面这行代码会执行，但是input还未出现，所以并没有显示相应的结果
        // 这是Vue在考虑效率时设置的形式。 异步？
        // $nextTick官方写法:
        this.$nextTick(function(){
            this.$refs.inputtitle.focus()
        })
        //或者 setTimeout(()=&gt;{
        // this.$refs.inputtitle.focus()
        // })
       },</code></pre><pre><code class="nohighlight hljs">


#### 9.Vue封装的过度与动画

1.作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。

2.图示：

![image-20230914195315215](C:\Users\ccchhhddd\Desktop\image-20230914195315215.png)

3.写法：

1.准备好样式：

​			元素进入的样式：

​					1.v-enter :进入的起点

​					2.v-enter-active:进入过程中

​					3.v-enter-to:进入的终点

​			元素离开时的样式：

​					1.v-leave:离开的起点

​					2.v-leave-active:离开过程中

​					3.v-leave-to:离开的终点

2.使用&lt;transition&gt;包裹要过度的元素，并配置name属性：
</code></pre><p>vue &lt;transition name=&quot;hello&quot;&gt; 	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt; &lt;/transition&gt;</p><pre><code class="nohighlight hljs">
3.备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;,且每个元素都要指定key值



例子：
</code></pre><p>vue &lt;template&gt;   &lt;div&gt;     &lt;button @click=&quot;isShow = !isShow&quot;&gt; 显示/隐藏&lt;/button&gt;     &lt;!–引入第三方动画 –&gt;     &lt;transition-group     appear      name=&quot;animate<strong>animated animate</strong>bounce&quot;       enter-active-class=&quot;animate<strong>rubberBand&quot;     leave-active-class=&quot;animate</strong>backOutUp&quot;     &gt;         &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好哈哈哈哈！&lt;/h1&gt;         &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;ccchhhddd&lt;/h1&gt;     &lt;/transition-group&gt;   &lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; import &#39;animate.css&#39; export default {     name:&#39;MyTest3&#39;,     data(){         return{             isShow:true         }     } } &lt;/script&gt;</p><p>&lt;style scoped&gt;     h1{         background-color: orange;     }</p><p>&lt;/style&gt;</p><pre><code class="nohighlight hljs">
### 3.Vue中的ajax

#### 1.前端服务器相关文章与视频

##### 1.用Node.js搭建一个简单Web服务器

https://blog.csdn.net/m0_46171043/article/details/132033934

##### 2.【笔记】 node.js - 开启本地服务器，返回json数据

https://blog.csdn.net/LawssssCat/article/details/103459796

##### 3.FeHelper前端助手浏览器插件 chrome插件-Web开发者助手 FeHelper

https://blog.csdn.net/A598853607/article/details/124118482

可以直接在谷歌应用商店里下载

##### 4.【原生Ajax】全面了解xhr的概念与使用

http://www.shouxieziti.cn/29383.html

xhr、jQuery现阶段用的比较少了，随着Vue和react框架的兴起axios用到比较多了

##### 5.尚硅谷Web前端axios入门与源码解析（视频链接）

https://www.bilibili.com/video/BV1wr4y1K7tq/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ab1c31a8db0c1b9114896077df5b64aa



#### 2.解决跨域问题

协议、域名、端口号都对的上即不存在跨域问题

方法1：cors

方法2：jsonp(需要前后端配合，很巧妙)

方法3：配置代理服务器

1.nginx

2.vue-cli(下面用到的)

##### 方法一：在vue.config.js中添加如下配置
</code></pre><p>js devServer: {     proxy: &#39;http://localhost:5000&#39;</p><pre><code class="nohighlight hljs">
说明：

1.优点：配置简单，请求资源时直接发给前端（8080）即可。

2.缺点：不能配置多个代理，不能灵活的控制请求是否走代理

3.工作方式：若按照上述的代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）



方法二：编写vue.config.js配置具体代理规则：
</code></pre><p>js module.exports = defineConfig({   // 开启代理服务器(方式2)   devServer: {     proxy: {       &#39;/chd&#39;: {         target: &#39;http://localhost:5000&#39;,         pathRewrite:{&#39;^/chd&#39;:&#39;&#39;},         ws: true,//用于支持websocket         // changeOrigin: true //用于控制请求头中的host值        },       &#39;/demo&#39;: {         target: &#39;http://localhost:5001&#39;,         pathRewrite:{&#39;^/demo&#39;:&#39;&#39;},         // ws: true,//用于支持websocket         // changeOrigin: true //用于控制请求头中的host值        },     }   }     // changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000   // changeOrigin设置为fasle时，服务器收到的请求头中的host为：localhost:8080   // changeOrigin默认值为true })</p><pre><code class="nohighlight hljs">
说明：

1.优点：可以配置多个代理，且可以灵活的控制请求是否走代理

2.缺点：配置略微繁琐，请求资源时必须加前缀



#### 3.vue_github搜索案例

https://blog.csdn.net/liaoai/article/details/123431352

上面链接里的案例没有用到main.js自身作为$bus的全局事件总线

我后面进行了部分的简化可以省去不少的内容



#### 4.插槽

认识Vue中组件利器-插槽Slot-案例介绍

https://blog.csdn.net/JackieDYH/article/details/124481953



##### 1.作用：

让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件==&gt;子组件

##### 2.分类：

默认插槽、具名插槽、作用域插槽

##### 3.使用方式：

###### 		1.默认插槽
</code></pre><p>vue 父组件： &lt;template&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;Category title=&quot;美食&quot;&gt;       &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;     &lt;/Category&gt;</p><pre><code class="nohighlight hljs">&lt;Category title=&quot;游戏&quot; &gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/Category&gt;

&lt;Category title=&quot;电影&quot;&gt;
  &lt;video controls src=&#39;./assets/shengqi.mp4&#39;&gt;&lt;/video&gt;
&lt;/Category&gt;</code></pre><p>&lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; import Category from &#39;./components/Category.vue&#39; export default {   name: &quot;App&quot;,   components: { Category },   data(){     return{       foods:[&#39;火锅&#39;,&#39;烧烤&#39;,&#39;小龙虾&#39;,&#39;牛排&#39;],       games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],       films:[&#39;《教父》&#39;,&#39;《星际穿越》&#39;,&#39;《变形金刚》&#39;,&#39;《盗梦空间》&#39;]</p><pre><code class="nohighlight hljs">}</code></pre><p>} }; &lt;/script&gt;</p><p>子组件： &lt;template&gt;   &lt;div class=&quot;category&quot;&gt;     &lt;h3&gt;{{ title }}分类&lt;/h3&gt;     &lt;!– 定义一个插槽（挖个坑，等着组件的使用者进行填充） –&gt;     &lt;slot&gt;我是默认插槽，没有传递具体结构时，我会出现&lt;/slot&gt;   &lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; export default {     name:&#39;MyCategory&#39;,     props:[&#39;title&#39;] } &lt;/script&gt;</p><pre><code class="nohighlight hljs">
###### 		2.具名插槽
</code></pre><p>vue 父组件： &lt;template&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;Category title=&quot;美食&quot;&gt;       &lt;img slot=&quot;center&quot;  src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;       &lt;a class=&quot;foot&quot;  slot=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt;     &lt;/Category&gt;</p><pre><code class="nohighlight hljs">&lt;Category title=&quot;游戏&quot; &gt;
  &lt;ul slot=&quot;center&quot;&gt;
    &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class=&quot;foot&quot; slot=&quot;footer&quot;&gt;
    &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;单机游戏&lt;/a&gt;
    &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;网络游戏&lt;/a&gt;
  &lt;/div&gt;      
&lt;/Category&gt;

&lt;Category title=&quot;电影&quot;&gt;
  &lt;video  slot=&quot;center&quot; controls src=&#39;./assets/shengqi.mp4&#39;&gt;&lt;/video&gt;
  &lt;template v-slot:footer&gt;
    &lt;div class=&quot;foot&quot;&gt;
    &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;经典&lt;/a&gt;
    &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;热门&lt;/a&gt;
    &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;推荐&lt;/a&gt;
  &lt;/div&gt;
  &lt;h4&gt;欢迎前来观影&lt;/h4&gt;
  &lt;/template&gt;
  
&lt;/Category&gt;</code></pre><p>&lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; import Category from &#39;./components/Category.vue&#39; export default {   name: &quot;App&quot;,   components: { Category },   data(){     return{       foods:[&#39;火锅&#39;,&#39;烧烤&#39;,&#39;小龙虾&#39;,&#39;牛排&#39;],       games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],       films:[&#39;《教父》&#39;,&#39;《星际穿越》&#39;,&#39;《变形金刚》&#39;,&#39;《盗梦空间》&#39;]</p><pre><code class="nohighlight hljs">}</code></pre><p>} }; &lt;/script&gt;</p><p>子组件： &lt;template&gt;   &lt;div class=&quot;category&quot;&gt;     &lt;h3&gt;{{ title }}分类&lt;/h3&gt;     &lt;!– 定义一个插槽（挖个坑，等着组件的使用者进行填充） –&gt;     &lt;slot name=&quot;center&quot;&gt;我是默认插槽，没有传递具体结构时，我会出现1&lt;/slot&gt;     &lt;slot name=&quot;footer&quot;&gt;我是默认插槽，没有传递具体结构时，我会出现2&lt;/slot&gt;   &lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; export default {     name:&#39;MyCategory&#39;,     props:[&#39;title&#39;] } &lt;/script&gt;</p><pre><code class="nohighlight hljs">
###### 		3.作用域插槽：

​			1.理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。

​			（games数据在category组件中，但使用数据所遍历出来的结构由App组件决定）

​			2.编码：	
</code></pre><p>vue 父组件: &lt;template&gt;   &lt;div class=&quot;container&quot;&gt;     &lt;Category title=&quot;游戏&quot; &gt;       &lt;template scope=&quot;duixiang&quot;&gt;         &lt;ul slot=&quot;center&quot;&gt;           &lt;li v-for=&quot;(g,index) in duixiang.games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;         &lt;/ul&gt;       &lt;/template&gt;          &lt;/Category&gt;</p><pre><code class="nohighlight hljs">&lt;Category title=&quot;游戏&quot; &gt;
  &lt;!-- 解构赋值{} --&gt;
  &lt;template scope=&quot;{games}&quot;&gt;
    &lt;ol&gt;
      &lt;li style=&quot;color: red&quot; v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/template&gt;     
&lt;/Category&gt;

&lt;Category title=&quot;游戏&quot; &gt;
  &lt;!-- 解构赋值{} --&gt;
  &lt;template slot-scope=&quot;{games}&quot;&gt;
    &lt;h4 v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/h4&gt;     
  &lt;/template&gt;     
&lt;/Category&gt;</code></pre><p>&lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; import Category from &#39;./components/Category.vue&#39; export default {   name: &quot;App&quot;,   components: { Category },</p><p>}; &lt;/script&gt;</p><p>子组件： &lt;template&gt;   &lt;div class=&quot;category&quot;&gt;     &lt;h3&gt;{{ title }}分类&lt;/h3&gt;     &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;   &lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; export default {     name:&#39;MyCategory&#39;,     props:[&#39;title&#39;],     data(){     return{       games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],     }   } } &lt;/script&gt;</p><pre><code class="nohighlight hljs">


### 4.Vuex



#### 	1 .vuex 是什么? 

1. 概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信。 
2. Github 地址: https://github.com/vuejs/vuex 

#### 	2 .什么时候使用Vuex?

1. 多个组件依赖于同一状态
2. 来自不同组件的行为需要变更同一状态

#### 3.逻辑图：

![vuex](https://vuex.vuejs.org/vuex.png)

#### 4.基本使用

1.具体案例
</code></pre><p>js //index.js</p><p>// 该文件用于创建Vuex中最为核心的store</p><p>import Vue from &#39;vue&#39; // 引入Vuex import Vuex from &#39;vuex&#39; Vue.use(Vuex) // 准备actions——用于相应组件中的动作 // 业务逻辑写在action里面 const actions = {     // jia(context,value){     //     context.commit(&#39;JIA&#39;,value)     // },     // jian(context,value){     //     context.commit(&#39;JIAN&#39;,value)     // },     oddjia(context,value){         // console.log(state,context,value)         if(context.state.sum % 2 == 1){         context.commit(&#39;ODDJIA&#39;,value)         }     },     timejia(context,value){         setTimeout(()=&gt;{             context.commit(&#39;TIMEJIA&#39;,value)         },500)     } } // 准备mutations——用于操作数据（state） const mutations = {     JIA(state,value){         state.sum += value     },     JIAN(state,value){         state.sum -= value     },     ODDJIA(state,value){         state.sum += value     },     TIMEJIA(state,value){         state.sum += value     } } // 准备state——用于存储数据 const state = {     sum:0 //当前的和 }</p><p>// 创建store export default new Vuex.Store({     actions,     mutations,     state })</p><pre><code class="nohighlight hljs"></code></pre><p>vue //组件Count.vue</p><p>&lt;template&gt;   &lt;div&gt;     &lt;h1&gt; 当前求和为{{ store.state.sum }}&lt;/h1&gt;     &lt;select v-model=&quot;n&quot;&gt;         &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt;         &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt;         &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt;     &lt;/select&gt;     &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;     &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;     &lt;button @click=&quot;incrementodd&quot;&gt;当前求和为奇数再加&lt;/button&gt;     &lt;button @click=&quot;incrementwait&quot;&gt;等一等再加&lt;/button&gt;   &lt;/div&gt; &lt;/template&gt;</p><p>&lt;script&gt; export default {     name:&#39;MyCount&#39;,     data(){         return{             n:1,//用户选择的数字</p><pre><code class="nohighlight hljs">    }
},
methods:{
    increment(){
        // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit
        this.$store.commit(&#39;JIA&#39;,this.n)
    },
    decrement(){
        this.$store.commit(&#39;JIAN&#39;,this.n)
    },
    incrementodd(){
        this.$store.dispatch(&#39;oddjia&#39;,this.n)  
    },
    incrementwait(){
        this.$store.dispatch(&#39;timejia&#39;,this.n)     
    }
},</code></pre><p>} &lt;/script&gt;</p><pre><code class="nohighlight hljs">
2.组件中读取vuex中的数据：$store.state.sum

3.组件中修改vuex中的数据：$store.dispatch(&#39;action中的方法名&#39;，数据)或$store.commit(&#39;mutations中的方法名&#39;，数据)



#### 5.getters的使用

1.概念：当state中的数据需要经过加工后再使用时，可以使用getters加工

2.在store.js中追加getters配置
</code></pre><p>js const getters = {     bigsum(state){         return state.sum*10     } }</p><p>// 创建并暴露store export default new Vuex.Store({     ...     getters</p><p>})</p><pre><code class="nohighlight hljs">
3.组件中读取数据：$store.getters.bigsum



#### 6.四个map方法的使用

###### 1.mapState方法：

帮我们映射state中的数据为计算属性
</code></pre><p>vue computed:{         // 1.靠程序员自己写的代码         // he(){         //     return this.<span>$store.state.sum         // },         // xuexiao(){         //     return this.$</span>store.state.subject         // },         // xueke(){         //     return this.store.state.school         // },</p><pre><code class="nohighlight hljs">    // 2.借助mapState生成计算属性，从state中读取数据。（对象写法）
    // ...mapState({sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;}),

    // 3.借助mapState生成计算属性，从state中读取数据。（数组写法）
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
    }</code></pre><pre><code class="nohighlight hljs">
###### 2.mapGetters方法：

用于帮助我们映射getters中的数据为计算属性
</code></pre><p>vue computed:{		 		// 1.靠程序员自己写的代码         // bigsum(){         //     return this.store.getters.bigsum          // },         // 2.借助mapGetters生成计算属性，从getters中读取数据。（数组写法）         ...mapGetters([&#39;bigsum&#39;])         }</p><pre><code class="nohighlight hljs">
###### 3.mapActions方法：

用于帮助我们生成与actions对话的方法，即包含$store.dispatch（xxx）的函数
</code></pre><p>vue methods:{ 		// 1.程序员手写法         // incrementodd(){         //     this.<span>$store.dispatch(&#39;oddjia&#39;,this.n)           // },         // incrementwait(){         //     this.$</span>store.dispatch(&#39;timejia&#39;,this.n)              // }</p><pre><code class="nohighlight hljs">    // 2.借助mapActions生成的方法，方法会调用dispatch去联系actions(对象写法)
    ...mapActions({incrementodd:&#39;oddjia&#39;,incrementwait:&#39;timejia&#39;})</code></pre><p>}</p><pre><code class="nohighlight hljs">
###### 4.mapMutations方法：

用于帮助我们生成与mutations对话的方法，即包含$store.commit(xxx)的函数
</code></pre><p>vue 	methods:{	 		// 1.程序员手写         // increment(){         //     // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit         //     this.<span>$store.commit(&#39;JIA&#39;,this.n)         // },         // decrement(){         //     this.$</span>store.commit(&#39;JIAN&#39;,this.n)         // },</p><pre><code class="nohighlight hljs">    // 2.借助mapMutations生成对应的方法，方法会调用commit去联系mutations(对象写法)
    ...mapMutations({increment:&#39;JIA&#39;,decrement:&#39;JIA&#39;}),
    }</code></pre><pre><code class="nohighlight hljs">


#### 7.模块化+命名空间

**1.目的：**让代码更好维护，让更多数据分类更加明确

**2.修改`store.js`**
</code></pre><p>// 求和相关配置 const countOptions= {     namespaced:true,     mutations:{...},     getters:{         bigsum(state){             return state.sum*10         }     } }</p><p>// 人员相关配置 const personOptions= {     namespaced:true,     actions:{...},     mutations:{...},     }</p><p>// 创建并暴露store export default new Vuex.Store({     modules:{       a:countOptions,       b:personOptions     } })</p><pre><code class="nohighlight hljs">
**3.开启命名空间后，组件中读取state数据：**
</code></pre><p>vue //1.自己直接读取 this.store.state.a.list //2.借助mapState读取 ...mapState(&#39;a&#39;,[&#39;sum&#39;,&#39;school&#39;])</p><pre><code class="nohighlight hljs">
**4.开启命名空间后，组件中读取getters数据：**
</code></pre><p> //1.自己直接读取  this.store.getters[&#39;b/fisrtpersonname&#39;]  //2.借助mapGetters读取  ...mapGetters(&#39;a&#39;,[&#39;bigsum&#39;])</p><pre><code class="nohighlight hljs">
**5.开启命名空间后，组件中调用dispatch**
</code></pre><p> //1.自己直接读取  this.store.dispatch[&#39;b/addpersonwang&#39;,person]  //2.借助mapActions;  ...mapActions(&#39;a&#39;,{increment:&#39;oddjia&#39;,incrementwait:&#39;timejia&#39;})</p><pre><code class="nohighlight hljs">
**6.开启命名空间后，组件中调用commit**
</code></pre><p> //1.自己直接commit  this.store.commit[&#39;b/ADDPERSON&#39;,person]  //2.借助mapMutations:  ...mapMutations(&#39;a&#39;,{increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;})</p><pre><code class="nohighlight hljs">


### 5.vue-router

#### 1.相关理解

##### 1.vue-router 的理解 

vue 的一个插件库，专门用来实现 **SPA 应用** 

##### 2.对 SPA 应用的理解 

1.单页 Web 应用（single page web application，SPA）。 

2.整个应用只有**一个完整的页面**。 

3.点击页面中的导航链接不会刷新页面，只会做页面的**局部更新**。

 4. 数据需要通过 ajax 请求获取

##### 3.路由的理解

###### 1.什么是路由?

​	1.一个路由就是一组映射关系（key - value） 

​	2.key 为路径, value 可能是 function 或 component 

###### 2.路由分类

1.后端路由：

​	1.理解：value 是 function, 用于处理客户端提交的请求。

 	2.工作过程：服务器接收到一个请求时, 根据**请求路径**找到匹配的**函数**来处理请求, 返回响应数据。

2.前端路由：

​	1.理解：value 是 component，用于展示页面内容。

 	2.工作过程：当浏览器的路径改变时, 对应的组件就会显示。



#### 2.基本路由

##### 1.基本使用

1.安装vue-router ,命令：npm i vue-router

2.应用插件：Vue.use(VueRouter)

3.编写router配置项：
</code></pre><p>js // 该文件专门用于创建整个应用的路由器 import VueRouter from &#39;vue-router&#39;</p><p>// 引入组件 import About from &#39;../pages/About&#39; import Home from &#39;../pages/Home&#39;</p><p>// 创建并暴露一个路由器 export default new VueRouter({     routes:[       {         path:&#39;/about&#39;,         component:About       },       {         path:&#39;/home&#39;,         component:Home       },      ] })</p><pre><code class="nohighlight hljs">
4.实现切换（active-class 可配置高亮样式）
</code></pre><p>js &lt;router-link active-class=&#39;active&#39; to=&#39;/about&#39;&gt;About&lt;/router-link&gt;</p><pre><code class="nohighlight hljs">
5.指定展示位置
</code></pre><p>js &lt;router-view&gt;&lt;/router-view&gt;</p><pre><code class="nohighlight hljs">


##### 2.几个注意点

​	1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹

​	2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载

​	3.每个组件都有自己的$route属性，里面存储着自己的路由信息。

​	4.整个应用只有一个router,可以通过组件的$router属性获取到。



#### 3.嵌套路由

1.配置路由规则，使用children配置项
</code></pre><p>js // 创建并暴露一个路由器 export default new VueRouter({     routes:[       {         path:&#39;/about&#39;,         component:About       },       {         path:&#39;/home&#39;,         component:Home,         children:[           {             // 这里不用加斜杠             path:&#39;news&#39;,             component:News,           },           {             path:&#39;message&#39;,             component:Message,           },         ]       },      ] })</p><pre><code class="nohighlight hljs">
2.跳转（要写完整路径）
</code></pre><p>vue &lt;router-link to=&#39;/home/news&#39;&gt;News&lt;/router-link&gt;</p><pre><code class="nohighlight hljs">


#### 4.路由的query参数

​	1.传递参数
</code></pre><p>vue &lt;li v-for=&quot;m in messagelist&quot; :key=&quot;m.id&quot;&gt;             &lt;!– 跳转路由并携带query参数，to的字符串写法 –&gt;             &lt;!– &lt;router-link :to=&quot;<code>/home/message/detail?id=${m.id}&amp;title=${m.title}</code>&quot;&gt;{{ m.title }}&lt;/router-link&gt;&amp;nbsp;&amp;nbsp; –&gt;</p><pre><code class="nohighlight hljs">        &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;
        &lt;router-link :to=&quot;{
            path:&#39;/home/message/detail&#39;,
            query:{
               id:m.id,
               title:m.title                     
            }
        }&quot;&gt;
            {{ m.title }}
        &lt;/router-link&gt;
        &amp;nbsp;&amp;nbsp;
    &lt;/li&gt;</code></pre><pre><code class="nohighlight hljs">
2.接收参数：
</code></pre><p>vue  route.query.id   route.query.title </p><pre><code class="nohighlight hljs">


#### 5.命名路由

1.作用：可以简化路由的跳转

2.如何使用

​	1.给路由命名：
</code></pre><p>js export default new VueRouter({     routes:[       {         name:&#39;guanyu&#39;,         path:&#39;/about&#39;,         component:About       },       {         path:&#39;/home&#39;,         component:Home,         children:[           {             // 这里不用加斜杠             path:&#39;news&#39;,             component:News,           },           {             path:&#39;message&#39;,             component:Message,             children:[               {                 name:&#39;xiangqing&#39;,                 path:&#39;detail&#39;,                 component:Detail               }             ]           },         ]       },      ] })</p><pre><code class="nohighlight hljs">
2.简化跳转：
</code></pre><p>vue //1.简化前写完整路径 &lt;router-link :to=&quot;{                 path:/home/message/detail&#39;,                 query:{                    id:m.id,                    title:m.title                                      }             }&quot;&gt; //2.简化后直接通过名字跳转 &lt;router-link :to=&quot;{                 name:&#39;xiangqing&#39;,                 query:{                    id:m.id,                    title:m.title                                      }             }&quot;&gt;</p><pre><code class="nohighlight hljs">


#### 6.路由的params参数

1.配置路由，声明接收params参数

2.传递参数

注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！

3.接收参数
</code></pre><p>vue route.params.id route.params.title</p><pre><code class="nohighlight hljs">


#### 7.路由的props配置

作用：让路由组件更方便的收到参数
</code></pre><p>js {                 name:&#39;xiangqing&#39;,                 path:&#39;detail&#39;,                 component:Detail,         // props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件         // props:{a:1,b:&#39;hello&#39;}</p><pre><code class="nohighlight hljs">   // props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件。
   // props:true

  // props的第三种写法，值为函数,该函数返回的对象中每一组key-value都会通过props传给Detail组件
            props($route){
              return {
                id:$route.query.id,
                title:$route.query.title,
              }
          }
      }</code></pre><pre><code class="nohighlight hljs">


#### 8.router-link 的replace属性

​	1.作用：控制路由跳转时操作浏览器历史记录的模式

​	2.浏览器的历史记录有两种写入方式：分别为push和replace,push是追加历史记录，replace是替换当前记录。路由跳转时默认为push

​	3.如何开启replace模式：

​	&lt;router-link replace =&#39;true&#39;&gt;News&lt;/router-link&gt;



#### 9.编程式路由导航

​	1.作用：不借助router-link实现路由跳转，让路由跳转更加灵活

​	2.具体编码：
</code></pre><p>js //<span>$router的5个API this.$</span>router.push this.<span>$router.replace this.$</span>router.forward //前进 this.<span>$router.back	//后退 this.$</span>router.go		//可前进可后退</p><pre><code class="nohighlight hljs">


#### 10.缓存路由组件

1.作用：让不展示的路由组件保持挂载，不被销毁

2.具体编码：
</code></pre><p>vue &lt;keep-alive include=&quot;MyNews&quot;&gt;             &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;</p><pre><code class="nohighlight hljs">


#### 11.两个新的生命周期钩子

1.作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。

2.具体名字：

​		1.`activated` 路由组件被激活时触发。

​		2.`deactivated` 路由组件失活时触发。



#### 12.路由守卫

##### 1.作用：

对路由进行权限控制

##### 2.分类：

全局守卫、独享守卫、组件内守卫

##### 3.全局守卫：
</code></pre><p>js // 全局前置路由守卫——初始化的时候被调用、每次路由切换之前被调用 router.beforeEach((to,from,next)=&gt;{   console.log(to,from)   // 这里用to.name===&#39;xinwen&#39; ||to.name=&#39;xiaoxi&#39;   if(to.meta.isAuth){       if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){     next()   }else{       alert(&#39;学校名不对，无权限查看!&#39;)}   }else{     next()   } })</p><p>// 全局后置路由守卫————初始化的时候被调用，每次路由切换之后被调用 router.afterEach((to,from)=&gt;{   console.log(from)   document.title = to.meta.title  || &#39;网页页面&#39; })</p><pre><code class="nohighlight hljs">
##### 4.独享守卫
</code></pre><p>js  beforeEnter:(to,from,next)=&gt;{               console.log(to,from)               // 这里用to.name===&#39;xinwen&#39; ||to.name=&#39;xiaoxi&#39;               if(to.meta.isAuth){                   if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){                 next()               }else{                   alert(&#39;学校名不对，无权限查看!&#39;)}               }else{                 next()               }     }}</p><pre><code class="nohighlight hljs">
独享守卫可以和全局路由后置守卫配合使用，但是独享守卫不可以与全局路由前置守卫一起使用，会发生覆盖的情况。

##### 5.组件内守卫
</code></pre><p>js // 通过路由规则，进入该组件时被调用     beforeRouteEnter(to,from,next){       console.log(to,from)     if(to.meta.isAuth){         if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){       next()     }else{       alert(&#39;学校名不对，无权限查看!&#39;)}     }else{       next()     }     },</p><p>// 通过路由规则，离开该组件时被调用     beforeRouteLeave(to,from,next){       next()     }</p><pre><code class="nohighlight hljs">


#### 13.路由器的两种工作模式

1.对于一个url来说，什么是hash值？——#及其后面的内容就是hsah值

2.hsah值不会包含在HTTP请求中，即：hash值不会带给服务器。

3.hash模式：

​	1.地址中永远带着#好，不美观

​	2.若以后将地址通过第三方手机app分享，若app校验合格，则地址会被标记为不合法。

​	3.兼容性较好

4.history模式：

​	1.地址干净，美观

​	2.兼容性和hash模式相比略差

​	3.应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。



### 6.Vue UI组件库

该部分无需笔记，直接看官方文档即可

#### 1 .移动端常用 UI 组件库 

​	1.Vant https://youzan.github.io/vant 

​	2.Cube UI https://didi.github.io/cube-ui 

​	3.Mint UI http://mint-ui.github.io 



#### 2 .PC 端常用 UI 组件库 

1. Element UI https://element.eleme.cn 

2. IView UI https://www.iviewui.co



## 4.Vue3笔记

### 0.引言

#### 1.    3.0发布的地址：

https://github.com/vuejs/core/releases/tag/v3.0.0

#### 2.     各个版本地址：

https://github.com/vuejs/core/tags

#### 3.vue3提升的方面

##### 1.性能提升

渲染更快，内存更小

##### 2.源码升级

1.使用Proxy代替defineProperty实现响应式

2.重写虚拟 DOM的实现和Tree-Shanking

##### 3.拥抱TypeScript

Vue3更好支持TypeScript    

TS是未来前端所驱

##### 4.新的特性

###### 1.composition API(组合API)

setup配置

ref与reactive

watch与watchEffect

provide与inject

###### 2.新的内置组件

Fragment

teleport

suspense

###### 3.其他改变

新的生命周期钩子

data选项应始终被声明为一个函数

移除keyCode支持作为v-on的修饰符



### 1.创建Vue3.0工程

#### 1.使用脚手架vue-cli创建

官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create



#### 2.使用vite创建

官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite

vite官网：https://vitejs.cn

**vite**------新一代前端**构建工具**（grunt、gulp、webpack）

优势：1.开发环境中，无需打包操作，可快速冷启动

​			2.轻量快速的热重载（HMR）

​			3.真正的按需编译，不再等待整个应用编译完成。

![image-20230922163244812](C:\Users\ccchhhddd\Desktop\Vue\image-20230922163244812.png)
</code></pre><h2 id="创建工程"><a class="docs-heading-anchor" href="#创建工程">创建工程</a><a id="创建工程-1"></a><a class="docs-heading-anchor-permalink" href="#创建工程" title="Permalink"></a></h2><p>npm init vite-app &lt;project-name&gt;</p><h2 id="进入工程目录"><a class="docs-heading-anchor" href="#进入工程目录">进入工程目录</a><a id="进入工程目录-1"></a><a class="docs-heading-anchor-permalink" href="#进入工程目录" title="Permalink"></a></h2><p>cd &lt;project-name&gt;</p><h2 id="安装依赖"><a class="docs-heading-anchor" href="#安装依赖">安装依赖</a><a id="安装依赖-1"></a><a class="docs-heading-anchor-permalink" href="#安装依赖" title="Permalink"></a></h2><p>npm install</p><h2 id="运行"><a class="docs-heading-anchor" href="#运行">运行</a><a id="运行-1"></a><a class="docs-heading-anchor-permalink" href="#运行" title="Permalink"></a></h2><p>npm run dev</p><pre><code class="nohighlight hljs">


### 2.常见Composition（组合式） API



#### 1.拉开序幕的setup

**1.理解：**Vue3.0中一个新的配置项，值为一个函数

**2.setup是所有Composition API(组合API)&quot;表演的舞台&quot;**

**3.组件中所用到的：**数据、方法等等，均要配置在setup中

**4.setup函数的两种返回值：**

​	1.若返回一个对象，则对象中的属性、方法，在模版中均可以直接使用。（重点关注！）

​	2.若返回一个渲染函数：则可以自定义渲染内容（了解）

**5.注意点：**

​	1.尽量不要与vue2.x配置混用

​		vue.x的配置可以访问setup中的属性、方法

​		但在setup中不能访问到Vue2.x配置（data、methos、computed...）

​		如有重名，setup优先

​	2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise,模版看不到return对象中的属性。（后期也可以返回一个promise实例，但需要suspense和异步组件的配合）



#### 2.ref函数

**作用：**定义一个响应式的数据

**语法：**const xxx=ref(initValue)

​		创建一个包含响应式数据的**引用对象（reference对象,简称ref对象）**

​		JS中操作数据 xxx.value

​		模版中读取数据：不需要 .value , 直接： &lt;div&gt;{{xxx}}&lt;/div&gt;

**备注：**
	接收的数据可以是：基本类型，也可以是对象类型

​	基本类型的数据：响应式依然是靠 Object.defineProperty() 的get与set完成的

​	对象类型的数据：内部“求助”了Vue3.0中的一个新函数——reactive函数 



#### 3.reactive函数

作用：定义一个**对象类型**的响应式函数（基本类型不要用它，要用`ref`函数）

语法：`const 代理对象 = reactive(源对象)`接收一个对象（或数组），返回一个**代理对象（proxy对象）**

reactive定义的响应式数据是“深层次的”

内部基于ES6的proxy实现，通过代理对象操作源对象内部数据进行操作



#### 4. Vue3.0的响应式

通过Proxy(代理)：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除

通过Reflect(反射)：对被代理对象的属性进行操作

MDN文档中描述的Proxy与Reflect


</code></pre><p>html //模拟Vue3中实现响应式     const p = new Proxy(person,{         // 有人读取p的某个属性时调用         get(target,propName){             console.log(<code>有人读取p身上的${propName}属性</code>)             return Reflect.get(target,propName)         },         // 有人修改p的某个属性、或给p追加某个属性时调用         set(target,propName,value){             console.log(<code>有人修改p身上的${propName}属性,我要去更新界面了</code>)             Reflect.set(target,propName,value)         },         // 有人删除p的某个属性时调用         deleteProperty(target,propName){             console.log(<code>有人删除p身上的${propName}属性,我要去更新界面了</code>)             return Reflect.deleteProperty(target,propName)         }     })</p><pre><code class="nohighlight hljs">


#### 5.reactive对比ref

1.从定义数据角度对比：

​		ref用来定义：基本类型数据

​		reactive用来定义：对象（或数组）类型数据

​		备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象

2.从原理角度对比：
		ref通过object.defineProperty() 的get 与set来实现响应式（数据劫持）

​		reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据

3.从使用角度对比：

​		ref定义的数据：操作数据需要 .value,读取数据时模版中直接读取不需要.value

​		reactive定义的数据：操作数据与读取数据：均不需要 .value



#### 6.setup的两个注意点

##### 1.setup执行的时机

​		在beforeCreate之前执行一次，this是undefined

##### 2.setup参数

​		props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性

​		context:上下文对象

​					attrs:值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.$atters

​					slots:收到的插槽内容，相当于this.$slots

​					emit:分发自定义事件的函数，相当于this.$emit



#### 7.计算属性

##### 1.computed函数

与Vue2.x中computed配置功能一致

写法：
</code></pre><p>js import {computed} from &#39;vue&#39;</p><p>setup(){     ... 	//计算属性——简写     let fullName = computed(()=&gt;{         return person.firstName + &#39;-&#39; + person.lastName     })     //计算属性——完整     let fullName = computed({         get(){             return person.firstName + &#39;-&#39; + person.lastName         },         set(value){             const nameArr = value.split(&#39;-&#39;)             person.firstName = nameArr[0]             person.lastName = nameArr[1]         }     }) }</p><pre><code class="nohighlight hljs">


##### 2.watch函数

**与Vue2.x中watch配置功能一致**

**两个小“坑”：**

​	1.监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。

​	2.监视reactive定义的响应式数据中某个属性时：deep配置有效。
</code></pre><p>js //情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;{ 	console.log(&#39;sum变化了&#39;,newValue,oldValue) },{immediate:true})</p><p>//情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;{ 	console.log(&#39;sum或msg变化了&#39;,newValue,oldValue) }) </p><p>/* 情况三：监视reactive定义的响应式数据 			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视  */ watch(person,(newValue,oldValue)=&gt;{ 	console.log(&#39;person变化了&#39;,newValue,oldValue) },{immediate:true,deep:false}) //此处的deep配置不再奏效</p><p>//情况四：监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{ 	console.log(&#39;person的job变化了&#39;,newValue,oldValue) },{immediate:true,deep:true}) </p><p>//情况五：监视reactive定义的响应式数据中的某些属性 watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{ 	console.log(&#39;person的job变化了&#39;,newValue,oldValue) },{immediate:true,deep:true})</p><p>//特殊情况 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{     console.log(&#39;person的job变化了&#39;,newValue,oldValue) },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</p><pre><code class="nohighlight hljs">


##### 3.watchEffect函数

watch的套路是：既要指明监视的属性，也要指明监视的回调。

watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。

watchEffect有点像computed：

​		但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。

​		而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。
</code></pre><p>js //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=&gt;{     const x1 = sum.value     const x2 = person.age     console.log(&#39;watchEffect配置的回调执行了&#39;) }) ```</p><h4 id=".生命周期"><a class="docs-heading-anchor" href="#.生命周期">8.生命周期</a><a id=".生命周期-1"></a><a class="docs-heading-anchor-permalink" href="#.生命周期" title="Permalink"></a></h4><p><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="组件生命周期图示"/></p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h4 id=".自定义hook函数"><a class="docs-heading-anchor" href="#.自定义hook函数">9.自定义hook函数</a><a id=".自定义hook函数-1"></a><a class="docs-heading-anchor-permalink" href="#.自定义hook函数" title="Permalink"></a></h4><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p><p>类似于vue2.x中的mixin。</p><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p><h4 id=".toRef"><a class="docs-heading-anchor" href="#.toRef">10.toRef</a><a id=".toRef-1"></a><a class="docs-heading-anchor-permalink" href="#.toRef" title="Permalink"></a></h4><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p><p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p><h3 id=".其它-Composition-API"><a class="docs-heading-anchor" href="#.其它-Composition-API">3.其它 Composition API</a><a id=".其它-Composition-API-1"></a><a class="docs-heading-anchor-permalink" href="#.其它-Composition-API" title="Permalink"></a></h3><h4 id=".shallowReactive-与-shallowRef"><a class="docs-heading-anchor" href="#.shallowReactive-与-shallowRef">1.shallowReactive 与 shallowRef</a><a id=".shallowReactive-与-shallowRef-1"></a><a class="docs-heading-anchor-permalink" href="#.shallowReactive-与-shallowRef" title="Permalink"></a></h4><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h4 id=".readonly-与-shallowReadonly"><a class="docs-heading-anchor" href="#.readonly-与-shallowReadonly">2.readonly 与 shallowReadonly</a><a id=".readonly-与-shallowReadonly-1"></a><a class="docs-heading-anchor-permalink" href="#.readonly-与-shallowReadonly" title="Permalink"></a></h4><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h4 id=".toRaw-与-markRaw"><a class="docs-heading-anchor" href="#.toRaw-与-markRaw">3.toRaw 与 markRaw</a><a id=".toRaw-与-markRaw-1"></a><a class="docs-heading-anchor-permalink" href="#.toRaw-与-markRaw" title="Permalink"></a></h4><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h4 id=".customRef"><a class="docs-heading-anchor" href="#.customRef">4.customRef</a><a id=".customRef-1"></a><a class="docs-heading-anchor-permalink" href="#.customRef" title="Permalink"></a></h4><ul><li>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</li></ul><ul><li>实现防抖效果：</li></ul><p>```vue   &lt;template&gt;   	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;   	&lt;h3&gt;{{keyword}}&lt;/h3&gt;   &lt;/template&gt;</p><p>&lt;script&gt;   	import {ref,customRef} from &#39;vue&#39;   	export default {   		name:&#39;Demo&#39;,   		setup(){   			// let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref   			//自定义一个myRef   			function myRef(value,delay){   				let timer   				//通过customRef去实现自定义   				return customRef((track,trigger)=&gt;{   					return{   						get(){   							track() //告诉Vue这个value值是需要被“追踪”的   							return value   						},   						set(newValue){   							clearTimeout(timer)   							timer = setTimeout(()=&gt;{   								value = newValue   								trigger() //告诉Vue去更新界面   							},delay)   						}   					}   				})   			}   			let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref   			return {   				keyword   			}   		}   	}   &lt;/script&gt;   ```</p><h4 id=".provide-与-inject"><a class="docs-heading-anchor" href="#.provide-与-inject">5.provide 与 inject</a><a id=".provide-与-inject-1"></a><a class="docs-heading-anchor-permalink" href="#.provide-与-inject" title="Permalink"></a></h4><ul><li>作用：实现<strong>祖与后代组件间</strong>通信</li></ul><ul><li>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</li></ul><ul><li>具体写法：</li></ul><ol><li>祖组件中：</li></ol><pre><code class="nohighlight hljs"> ```js
 setup(){
     ......
     let car = reactive({name:&#39;奔驰&#39;,price:&#39;40万&#39;})
     provide(&#39;car&#39;,car)
     ......
 }
 ```</code></pre><ol><li>后代组件中：</li></ol><pre><code class="nohighlight hljs"> ```js
 setup(props,context){
     ......
     const car = inject(&#39;car&#39;)
     return {car}
     ......
 }
 ```</code></pre><h4 id=".响应式数据的判断"><a class="docs-heading-anchor" href="#.响应式数据的判断">6.响应式数据的判断</a><a id=".响应式数据的判断-1"></a><a class="docs-heading-anchor-permalink" href="#.响应式数据的判断" title="Permalink"></a></h4><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h3 id=".Composition-API-的优势"><a class="docs-heading-anchor" href="#.Composition-API-的优势">4.Composition API 的优势</a><a id=".Composition-API-的优势-1"></a><a class="docs-heading-anchor-permalink" href="#.Composition-API-的优势" title="Permalink"></a></h3><h4 id=".Options-API-存在的问题"><a class="docs-heading-anchor" href="#.Options-API-存在的问题">1.Options API 存在的问题</a><a id=".Options-API-存在的问题-1"></a><a class="docs-heading-anchor-permalink" href="#.Options-API-存在的问题" title="Permalink"></a></h4><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" alt="img"/></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" alt="img"/></p><h4 id=".Composition-API-的优势-2"><a class="docs-heading-anchor" href="#.Composition-API-的优势-2">2.Composition API 的优势</a><a class="docs-heading-anchor-permalink" href="#.Composition-API-的优势-2" title="Permalink"></a></h4><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" alt="img"/></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" alt="img"/></p><h3 id=".新的组件"><a class="docs-heading-anchor" href="#.新的组件">5.新的组件</a><a id=".新的组件-1"></a><a class="docs-heading-anchor-permalink" href="#.新的组件" title="Permalink"></a></h3><h4 id=".Fragment"><a class="docs-heading-anchor" href="#.Fragment">1.Fragment</a><a id=".Fragment-1"></a><a class="docs-heading-anchor-permalink" href="#.Fragment" title="Permalink"></a></h4><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h4 id=".Teleport"><a class="docs-heading-anchor" href="#.Teleport">2.Teleport</a><a id=".Teleport-1"></a><a class="docs-heading-anchor-permalink" href="#.Teleport" title="Permalink"></a></h4><ul><li>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><p><code>vue   &lt;teleport to=&quot;移动位置&quot;&gt;   	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;   		&lt;div class=&quot;dialog&quot;&gt;   			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;   			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;   		&lt;/div&gt;   	&lt;/div&gt;   &lt;/teleport&gt;</code></p><h4 id=".Suspense"><a class="docs-heading-anchor" href="#.Suspense">3.Suspense</a><a id=".Suspense-1"></a><a class="docs-heading-anchor-permalink" href="#.Suspense" title="Permalink"></a></h4><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</li></ul><ul><li>使用步骤：</li></ul><ul><li>异步引入组件</li></ul><pre><code class="nohighlight hljs">```js
import {defineAsyncComponent} from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))
```</code></pre><ul><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul><pre><code class="nohighlight hljs">```vue
&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;h3&gt;我是App组件&lt;/h3&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt;
                &lt;h3&gt;加载中.....&lt;/h3&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;
    &lt;/div&gt;
&lt;/template&gt;
```</code></pre><h3 id=".其他"><a class="docs-heading-anchor" href="#.其他">6.其他</a><a id=".其他-1"></a><a class="docs-heading-anchor-permalink" href="#.其他" title="Permalink"></a></h3><h4 id=".全局API的转移"><a class="docs-heading-anchor" href="#.全局API的转移">1.全局API的转移</a><a id=".全局API的转移-1"></a><a class="docs-heading-anchor-permalink" href="#.全局API的转移" title="Permalink"></a></h4><ul><li>Vue 2.x 有许多全局 API 和配置。</li></ul><ul><li>例如：注册全局组件、注册全局指令等。</li></ul><pre><code class="nohighlight hljs">```js
//注册全局组件
Vue.component(&#39;MyButton&#39;, {
  data: () =&gt; ({
    count: 0
  }),
  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;&#39;
})

//注册全局指令
Vue.directive(&#39;focus&#39;, {
  inserted: el =&gt; el.focus()
}
```</code></pre><ul><li>Vue3.0中对这些API做出了调整：</li></ul><ul><li>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</li></ul><pre><code class="nohighlight hljs">![image-20230924172504984](C:\Users\ccchhhddd\Desktop\image-20230924172504984.png)</code></pre><h4 id=".其他改变"><a class="docs-heading-anchor" href="#.其他改变">2.其他改变</a><a id=".其他改变-1"></a><a class="docs-heading-anchor-permalink" href="#.其他改变" title="Permalink"></a></h4><ul><li>data选项应始终被声明为一个函数。</li></ul><ul><li>过度类名的更改：</li></ul><ul><li>Vue2.x写法</li></ul><pre><code class="nohighlight hljs">```css
.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
```</code></pre><ul><li>Vue3.x写法</li></ul><pre><code class="nohighlight hljs">```css
.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
```</code></pre><ul><li><strong>移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></li></ul><ul><li><strong>移除</strong><code>v-on.native</code>修饰符</li></ul><ul><li>父组件中绑定事件</li></ul><pre><code class="nohighlight hljs">```vue
&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
```</code></pre><ul><li>子组件中声明自定义事件</li></ul><pre><code class="nohighlight hljs">```vue
&lt;script&gt;
  export default {
    emits: [&#39;close&#39;]
  }
&lt;/script&gt;
```</code></pre><ul><li><strong>移除</strong>过滤器（filter）</li></ul><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 26 October 2023 15:22">Thursday 26 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
