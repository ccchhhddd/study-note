<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vuex · study notes</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/notes.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">study notes</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/1-第一个要解决的设计优化问题/">第一个要解决的设计优化问题</a></li></ul></li><li><span class="tocitem">Front_end</span><ul><li><a class="tocitem" href="../1-说说console/">说说console</a></li><li><a class="tocitem" href="../2-ES (EcmaScript)/">ES （EcmaScript）</a></li><li><a class="tocitem" href="../3-JavaScript/">JavaScript</a></li><li><a class="tocitem" href="../4-Vue2笔记/">Vue2笔记</a></li><li class="is-active"><a class="tocitem" href>Vuex</a><ul class="internal"><li><a class="tocitem" href="#.vuex-是什么?"><span>1.vuex 是什么?</span></a></li><li><a class="tocitem" href="#.什么时候使用Vuex?"><span>2.什么时候使用Vuex?</span></a></li><li><a class="tocitem" href="#.逻辑图："><span>3.逻辑图：</span></a></li><li><a class="tocitem" href="#.基本使用"><span>4.基本使用</span></a></li><li><a class="tocitem" href="#.vue-router"><span>5.vue-router</span></a></li><li><a class="tocitem" href="#.Vue-UI组件库"><span>6.Vue UI组件库</span></a></li></ul></li><li><a class="tocitem" href="../6-Vue3笔记/">Vue3笔记</a></li></ul></li><li><span class="tocitem">Mac_share</span><ul><li><a class="tocitem" href="../../Mac_share/1-Mac环境变量的配置/">Mac环境变量的配置</a></li></ul></li><li><span class="tocitem">Web_build</span><ul><li><a class="tocitem" href="../../Web_build/1-这个个人笔记网站是如何构建的/">如何构建这样的网站</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Front_end</a></li><li class="is-active"><a href>Vuex</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vuex</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ccchhhddd/study-notes/blob/main/docs/src/Front_end/5-Vuex.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Vuex"><a class="docs-heading-anchor" href="#Vuex">Vuex</a><a id="Vuex-1"></a><a class="docs-heading-anchor-permalink" href="#Vuex" title="Permalink"></a></h1><h2 id=".vuex-是什么?"><a class="docs-heading-anchor" href="#.vuex-是什么?">1.vuex 是什么?</a><a id=".vuex-是什么?-1"></a><a class="docs-heading-anchor-permalink" href="#.vuex-是什么?" title="Permalink"></a></h2><ol><li>概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信。 </li><li>Github 地址: https://github.com/vuejs/vuex </li></ol><h2 id=".什么时候使用Vuex?"><a class="docs-heading-anchor" href="#.什么时候使用Vuex?">2.什么时候使用Vuex?</a><a id=".什么时候使用Vuex?-1"></a><a class="docs-heading-anchor-permalink" href="#.什么时候使用Vuex?" title="Permalink"></a></h2><ol><li>多个组件依赖于同一状态</li><li>来自不同组件的行为需要变更同一状态</li></ol><h2 id=".逻辑图："><a class="docs-heading-anchor" href="#.逻辑图：">3.逻辑图：</a><a id=".逻辑图：-1"></a><a class="docs-heading-anchor-permalink" href="#.逻辑图：" title="Permalink"></a></h2><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"/></p><h2 id=".基本使用"><a class="docs-heading-anchor" href="#.基本使用">4.基本使用</a><a id=".基本使用-1"></a><a class="docs-heading-anchor-permalink" href="#.基本使用" title="Permalink"></a></h2><p>1.具体案例</p><pre><code class="nohighlight hljs">//index.js

// 该文件用于创建Vuex中最为核心的store

import Vue from &#39;vue&#39;
// 引入Vuex
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)
// 准备actions——用于相应组件中的动作
// 业务逻辑写在action里面
const actions = {
    // jia(context,value){
    //     context.commit(&#39;JIA&#39;,value)
    // },
    // jian(context,value){
    //     context.commit(&#39;JIAN&#39;,value)
    // },
    oddjia(context,value){
        // console.log(state,context,value)
        if(context.state.sum % 2 == 1){
        context.commit(&#39;ODDJIA&#39;,value)
        }
    },
    timejia(context,value){
        setTimeout(()=&gt;{
            context.commit(&#39;TIMEJIA&#39;,value)
        },500)
    }
}
// 准备mutations——用于操作数据（state）
const mutations = {
    JIA(state,value){
        state.sum += value
    },
    JIAN(state,value){
        state.sum -= value
    },
    ODDJIA(state,value){
        state.sum += value
    },
    TIMEJIA(state,value){
        state.sum += value
    }
}
// 准备state——用于存储数据
const state = {
    sum:0 //当前的和
}

// 创建store
export default new Vuex.Store({
    actions,
    mutations,
    state
})

//组件Count.vue

&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt; 当前求和为{{ $store.state.sum }}&lt;/h1&gt;
    &lt;select v-model=&quot;n&quot;&gt;
        &lt;option :value=&quot;1&quot;&gt;1&lt;/option&gt;
        &lt;option :value=&quot;2&quot;&gt;2&lt;/option&gt;
        &lt;option :value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementodd&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementwait&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    name:&#39;MyCount&#39;,
    data(){
        return{
            n:1,//用户选择的数字
            
        }
    },
    methods:{
        increment(){
            // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit
            this.$store.commit(&#39;JIA&#39;,this.n)
        },
        decrement(){
            this.$store.commit(&#39;JIAN&#39;,this.n)
        },
        incrementodd(){
            this.$store.dispatch(&#39;oddjia&#39;,this.n)  
        },
        incrementwait(){
            this.$store.dispatch(&#39;timejia&#39;,this.n)     
        }
    },

}
&lt;/script&gt;
</code></pre><p>2.组件中读取vuex中的数据：store.state.sum</p><p>3.组件中修改vuex中的数据：<span>$store.dispatch(&#39;action中的方法名&#39;，数据)或$</span>store.commit(&#39;mutations中的方法名&#39;，数据)</p><h3 id=".getters的使用"><a class="docs-heading-anchor" href="#.getters的使用">5.getters的使用</a><a id=".getters的使用-1"></a><a class="docs-heading-anchor-permalink" href="#.getters的使用" title="Permalink"></a></h3><p>1.概念：当state中的数据需要经过加工后再使用时，可以使用getters加工</p><p>2.在store.js中追加getters配置</p><pre><code class="nohighlight hljs">const getters = {
    bigsum(state){
        return state.sum*10
    }
}

// 创建并暴露store
export default new Vuex.Store({
    ...
    getters

})</code></pre><p>3.组件中读取数据：store.getters.bigsum</p><h3 id=".四个map方法的使用"><a class="docs-heading-anchor" href="#.四个map方法的使用">6.四个map方法的使用</a><a id=".四个map方法的使用-1"></a><a class="docs-heading-anchor-permalink" href="#.四个map方法的使用" title="Permalink"></a></h3><h5 id=".mapState方法："><a class="docs-heading-anchor" href="#.mapState方法：">1.mapState方法：</a><a id=".mapState方法：-1"></a><a class="docs-heading-anchor-permalink" href="#.mapState方法：" title="Permalink"></a></h5><p>帮我们映射state中的数据为计算属性</p><pre><code class="nohighlight hljs">computed:{
        // 1.靠程序员自己写的代码
        // he(){
        //     return this.$store.state.sum
        // },
        // xuexiao(){
        //     return this.$store.state.subject
        // },
        // xueke(){
        //     return this.$store.state.school
        // },

        // 2.借助mapState生成计算属性，从state中读取数据。（对象写法）
        // ...mapState({sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;}),

        // 3.借助mapState生成计算属性，从state中读取数据。（数组写法）
        ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
        }</code></pre><h5 id=".mapGetters方法："><a class="docs-heading-anchor" href="#.mapGetters方法：">2.mapGetters方法：</a><a id=".mapGetters方法：-1"></a><a class="docs-heading-anchor-permalink" href="#.mapGetters方法：" title="Permalink"></a></h5><p>用于帮助我们映射getters中的数据为计算属性</p><pre><code class="nohighlight hljs">computed:{    
    // 1.靠程序员自己写的代码
        // bigsum(){
        //     return this.$store.getters.bigsum 
        // },
        // 2.借助mapGetters生成计算属性，从getters中读取数据。（数组写法）
        ...mapGetters([&#39;bigsum&#39;])
        }</code></pre><h5 id=".mapActions方法："><a class="docs-heading-anchor" href="#.mapActions方法：">3.mapActions方法：</a><a id=".mapActions方法：-1"></a><a class="docs-heading-anchor-permalink" href="#.mapActions方法：" title="Permalink"></a></h5><p>用于帮助我们生成与actions对话的方法，即包含store.dispatch（xxx）的函数</p><pre><code class="nohighlight hljs">methods:{
    // 1.程序员手写法
        // incrementodd(){
        //     this.$store.dispatch(&#39;oddjia&#39;,this.n)  
        // },
        // incrementwait(){
        //     this.$store.dispatch(&#39;timejia&#39;,this.n)     
        // }

        // 2.借助mapActions生成的方法，方法会调用dispatch去联系actions(对象写法)
        ...mapActions({incrementodd:&#39;oddjia&#39;,incrementwait:&#39;timejia&#39;})

}</code></pre><h5 id=".mapMutations方法："><a class="docs-heading-anchor" href="#.mapMutations方法：">4.mapMutations方法：</a><a id=".mapMutations方法：-1"></a><a class="docs-heading-anchor-permalink" href="#.mapMutations方法：" title="Permalink"></a></h5><p>用于帮助我们生成与mutations对话的方法，即包含store.commit(xxx)的函数</p><pre><code class="nohighlight hljs">  methods:{ 
    // 1.程序员手写
        // increment(){
        //     // 这里直接跳过了action（中间没有牵扯业务逻辑），所以直接用commit
        //     this.$store.commit(&#39;JIA&#39;,this.n)
        // },
        // decrement(){
        //     this.$store.commit(&#39;JIAN&#39;,this.n)
        // },

        // 2.借助mapMutations生成对应的方法，方法会调用commit去联系mutations(对象写法)
        ...mapMutations({increment:&#39;JIA&#39;,decrement:&#39;JIA&#39;}),
        }</code></pre><h3 id=".模块化命名空间"><a class="docs-heading-anchor" href="#.模块化命名空间">7.模块化+命名空间</a><a id=".模块化命名空间-1"></a><a class="docs-heading-anchor-permalink" href="#.模块化命名空间" title="Permalink"></a></h3><p><strong>1.目的：</strong>让代码更好维护，让更多数据分类更加明确</p><p><strong>2.修改<code>store.js</code></strong></p><pre><code class="nohighlight hljs">// 求和相关配置
const countOptions= {
    namespaced:true,
    mutations:{...},
    getters:{
        bigsum(state){
            return state.sum*10
        }
    }
}

// 人员相关配置
const personOptions= {
    namespaced:true,
    actions:{...},
    mutations:{...},    
}

// 创建并暴露store
export default new Vuex.Store({
    modules:{
      a:countOptions,
      b:personOptions
    }
})</code></pre><p><strong>3.开启命名空间后，组件中读取state数据：</strong></p><pre><code class="nohighlight hljs">//1.自己直接读取
this.$store.state.a.list
//2.借助mapState读取
...mapState(&#39;a&#39;,[&#39;sum&#39;,&#39;school&#39;])</code></pre><p><strong>4.开启命名空间后，组件中读取getters数据：</strong></p><pre><code class="nohighlight hljs"> //1.自己直接读取
 this.$store.getters[&#39;b/fisrtpersonname&#39;]
 //2.借助mapGetters读取
 ...mapGetters(&#39;a&#39;,[&#39;bigsum&#39;])</code></pre><p><strong>5.开启命名空间后，组件中调用dispatch</strong></p><pre><code class="nohighlight hljs"> //1.自己直接读取
 this.$store.dispatch[&#39;b/addpersonwang&#39;,person]
 //2.借助mapActions;
 ...mapActions(&#39;a&#39;,{increment:&#39;oddjia&#39;,incrementwait:&#39;timejia&#39;})</code></pre><p><strong>6.开启命名空间后，组件中调用commit</strong></p><pre><code class="nohighlight hljs"> //1.自己直接commit
 this.$store.commit[&#39;b/ADDPERSON&#39;,person]
 //2.借助mapMutations:
 ...mapMutations(&#39;a&#39;,{increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;})</code></pre><h2 id=".vue-router"><a class="docs-heading-anchor" href="#.vue-router">5.vue-router</a><a id=".vue-router-1"></a><a class="docs-heading-anchor-permalink" href="#.vue-router" title="Permalink"></a></h2><h3 id=".相关理解"><a class="docs-heading-anchor" href="#.相关理解">1.相关理解</a><a id=".相关理解-1"></a><a class="docs-heading-anchor-permalink" href="#.相关理解" title="Permalink"></a></h3><h4 id=".vue-router-的理解"><a class="docs-heading-anchor" href="#.vue-router-的理解">1.vue-router 的理解</a><a id=".vue-router-的理解-1"></a><a class="docs-heading-anchor-permalink" href="#.vue-router-的理解" title="Permalink"></a></h4><p>vue 的一个插件库，专门用来实现 <strong>SPA 应用</strong> </p><h4 id=".对-SPA-应用的理解"><a class="docs-heading-anchor" href="#.对-SPA-应用的理解">2.对 SPA 应用的理解</a><a id=".对-SPA-应用的理解-1"></a><a class="docs-heading-anchor-permalink" href="#.对-SPA-应用的理解" title="Permalink"></a></h4><p>1.单页 Web 应用（single page web application，SPA）。 </p><p>2.整个应用只有<strong>一个完整的页面</strong>。 </p><p>3.点击页面中的导航链接不会刷新页面，只会做页面的<strong>局部更新</strong>。</p><ol><li>数据需要通过 ajax 请求获取</li></ol><h4 id=".路由的理解"><a class="docs-heading-anchor" href="#.路由的理解">3.路由的理解</a><a id=".路由的理解-1"></a><a class="docs-heading-anchor-permalink" href="#.路由的理解" title="Permalink"></a></h4><h5 id=".什么是路由?"><a class="docs-heading-anchor" href="#.什么是路由?">1.什么是路由?</a><a id=".什么是路由?-1"></a><a class="docs-heading-anchor-permalink" href="#.什么是路由?" title="Permalink"></a></h5><p>​	1.一个路由就是一组映射关系（key - value） </p><p>​	2.key 为路径, value 可能是 function 或 component </p><h5 id=".路由分类"><a class="docs-heading-anchor" href="#.路由分类">2.路由分类</a><a id=".路由分类-1"></a><a class="docs-heading-anchor-permalink" href="#.路由分类" title="Permalink"></a></h5><p>1.后端路由：</p><p>​	1.理解：value 是 function, 用于处理客户端提交的请求。</p><pre><code class="nohighlight hljs">2.工作过程：服务器接收到一个请求时, 根据**请求路径**找到匹配的**函数**来处理请求, 返回响应数据。</code></pre><p>2.前端路由：</p><p>​	1.理解：value 是 component，用于展示页面内容。</p><pre><code class="nohighlight hljs">2.工作过程：当浏览器的路径改变时, 对应的组件就会显示。</code></pre><h3 id=".基本路由"><a class="docs-heading-anchor" href="#.基本路由">2.基本路由</a><a id=".基本路由-1"></a><a class="docs-heading-anchor-permalink" href="#.基本路由" title="Permalink"></a></h3><h4 id=".基本使用-2"><a class="docs-heading-anchor" href="#.基本使用-2">1.基本使用</a><a class="docs-heading-anchor-permalink" href="#.基本使用-2" title="Permalink"></a></h4><p>1.安装vue-router ,命令：npm i vue-router</p><p>2.应用插件：Vue.use(VueRouter)</p><p>3.编写router配置项：</p><pre><code class="nohighlight hljs">// 该文件专门用于创建整个应用的路由器
import VueRouter from &#39;vue-router&#39;

// 引入组件
import About from &#39;../pages/About&#39;
import Home from &#39;../pages/Home&#39;

// 创建并暴露一个路由器
export default new VueRouter({
    routes:[
      {
        path:&#39;/about&#39;,
        component:About
      },
      {
        path:&#39;/home&#39;,
        component:Home
      }, 
    ]
})</code></pre><p>4.实现切换（active-class 可配置高亮样式）</p><pre><code class="nohighlight hljs">&lt;router-link active-class=&#39;active&#39; to=&#39;/about&#39;&gt;About&lt;/router-link&gt;</code></pre><p>5.指定展示位置</p><pre><code class="nohighlight hljs">&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h4 id=".几个注意点"><a class="docs-heading-anchor" href="#.几个注意点">2.几个注意点</a><a id=".几个注意点-1"></a><a class="docs-heading-anchor-permalink" href="#.几个注意点" title="Permalink"></a></h4><p>​	1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹</p><p>​	2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载</p><p>​	3.每个组件都有自己的route属性，里面存储着自己的路由信息。</p><p>​	4.整个应用只有一个router,可以通过组件的router属性获取到。</p><h3 id=".嵌套路由"><a class="docs-heading-anchor" href="#.嵌套路由">3.嵌套路由</a><a id=".嵌套路由-1"></a><a class="docs-heading-anchor-permalink" href="#.嵌套路由" title="Permalink"></a></h3><p>1.配置路由规则，使用children配置项</p><pre><code class="nohighlight hljs">// 创建并暴露一个路由器
export default new VueRouter({
    routes:[
      {
        path:&#39;/about&#39;,
        component:About
      },
      {
        path:&#39;/home&#39;,
        component:Home,
        children:[
          {
            // 这里不用加斜杠
            path:&#39;news&#39;,
            component:News,
          },
          {
            path:&#39;message&#39;,
            component:Message,
          },
        ]
      }, 
    ]
})
</code></pre><p>2.跳转（要写完整路径）</p><pre><code class="nohighlight hljs">&lt;router-link to=&#39;/home/news&#39;&gt;News&lt;/router-link&gt;</code></pre><h3 id=".路由的query参数"><a class="docs-heading-anchor" href="#.路由的query参数">4.路由的query参数</a><a id=".路由的query参数-1"></a><a class="docs-heading-anchor-permalink" href="#.路由的query参数" title="Permalink"></a></h3><p>​	1.传递参数</p><pre><code class="nohighlight hljs">&lt;li v-for=&quot;m in messagelist&quot; :key=&quot;m.id&quot;&gt;
            &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;
            &lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=${m.id}&amp;title=${m.title}`&quot;&gt;{{ m.title }}&lt;/router-link&gt;&amp;nbsp;&amp;nbsp; --&gt;
        
            &lt;!-- 跳转路由并携带query参数，to的对象写法 --&gt;
            &lt;router-link :to=&quot;{
                path:&#39;/home/message/detail&#39;,
                query:{
                   id:m.id,
                   title:m.title                     
                }
            }&quot;&gt;
                {{ m.title }}
            &lt;/router-link&gt;
            &amp;nbsp;&amp;nbsp;
        &lt;/li&gt;</code></pre><p>2.接收参数：</p><pre><code class="nohighlight hljs"> $route.query.id 
 $route.query.title </code></pre><h3 id=".命名路由"><a class="docs-heading-anchor" href="#.命名路由">5.命名路由</a><a id=".命名路由-1"></a><a class="docs-heading-anchor-permalink" href="#.命名路由" title="Permalink"></a></h3><p>1.作用：可以简化路由的跳转</p><p>2.如何使用</p><p>​	1.给路由命名：</p><pre><code class="nohighlight hljs">export default new VueRouter({
    routes:[
      {
        name:&#39;guanyu&#39;,
        path:&#39;/about&#39;,
        component:About
      },
      {
        path:&#39;/home&#39;,
        component:Home,
        children:[
          {
            // 这里不用加斜杠
            path:&#39;news&#39;,
            component:News,
          },
          {
            path:&#39;message&#39;,
            component:Message,
            children:[
              {
                name:&#39;xiangqing&#39;,
                path:&#39;detail&#39;,
                component:Detail
              }
            ]
          },
        ]
      }, 
    ]
})</code></pre><p>2.简化跳转：</p><pre><code class="nohighlight hljs">//1.简化前写完整路径
&lt;router-link :to=&quot;{
                path:/home/message/detail&#39;,
                query:{
                   id:m.id,
                   title:m.title                     
                }
            }&quot;&gt;
//2.简化后直接通过名字跳转
&lt;router-link :to=&quot;{
                name:&#39;xiangqing&#39;,
                query:{
                   id:m.id,
                   title:m.title                     
                }
            }&quot;&gt;</code></pre><h3 id=".路由的params参数"><a class="docs-heading-anchor" href="#.路由的params参数">6.路由的params参数</a><a id=".路由的params参数-1"></a><a class="docs-heading-anchor-permalink" href="#.路由的params参数" title="Permalink"></a></h3><p>1.配置路由，声明接收params参数</p><p>2.传递参数</p><p>注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p><p>3.接收参数</p><pre><code class="nohighlight hljs">$route.params.id
$route.params.title</code></pre><h3 id=".路由的props配置"><a class="docs-heading-anchor" href="#.路由的props配置">7.路由的props配置</a><a id=".路由的props配置-1"></a><a class="docs-heading-anchor-permalink" href="#.路由的props配置" title="Permalink"></a></h3><p>作用：让路由组件更方便的收到参数</p><pre><code class="nohighlight hljs">{
                name:&#39;xiangqing&#39;,
                path:&#39;detail&#39;,
                component:Detail,
        // props的第一种写法，值为对象，该对象中的所有key-value都会以props的形式传给Detail组件
        // props:{a:1,b:&#39;hello&#39;}

       // props的第二种写法，值为布尔值，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件。
       // props:true

      // props的第三种写法，值为函数,该函数返回的对象中每一组key-value都会通过props传给Detail组件
                props($route){
                  return {
                    id:$route.query.id,
                    title:$route.query.title,
                  }
              }
          }</code></pre><h3 id=".router-link-的replace属性"><a class="docs-heading-anchor" href="#.router-link-的replace属性">8.router-link 的replace属性</a><a id=".router-link-的replace属性-1"></a><a class="docs-heading-anchor-permalink" href="#.router-link-的replace属性" title="Permalink"></a></h3><p>​	1.作用：控制路由跳转时操作浏览器历史记录的模式</p><p>​	2.浏览器的历史记录有两种写入方式：分别为push和replace,push是追加历史记录，replace是替换当前记录。路由跳转时默认为push</p><p>​	3.如何开启replace模式：</p><p>​	&lt;router-link replace =&#39;true&#39;&gt;News&lt;/router-link&gt;</p><h3 id=".编程式路由导航"><a class="docs-heading-anchor" href="#.编程式路由导航">9.编程式路由导航</a><a id=".编程式路由导航-1"></a><a class="docs-heading-anchor-permalink" href="#.编程式路由导航" title="Permalink"></a></h3><p>​	1.作用：不借助router-link实现路由跳转，让路由跳转更加灵活</p><p>​	2.具体编码：</p><pre><code class="nohighlight hljs">//$router的5个API
this.$router.push
this.$router.replace
this.$router.forward //前进
this.$router.back //后退
this.$router.go   //可前进可后退</code></pre><h3 id=".缓存路由组件"><a class="docs-heading-anchor" href="#.缓存路由组件">10.缓存路由组件</a><a id=".缓存路由组件-1"></a><a class="docs-heading-anchor-permalink" href="#.缓存路由组件" title="Permalink"></a></h3><p>1.作用：让不展示的路由组件保持挂载，不被销毁</p><p>2.具体编码：</p><pre><code class="nohighlight hljs">&lt;keep-alive include=&quot;MyNews&quot;&gt;
            &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;</code></pre><h3 id=".两个新的生命周期钩子"><a class="docs-heading-anchor" href="#.两个新的生命周期钩子">11.两个新的生命周期钩子</a><a id=".两个新的生命周期钩子-1"></a><a class="docs-heading-anchor-permalink" href="#.两个新的生命周期钩子" title="Permalink"></a></h3><p>1.作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p><p>2.具体名字：</p><p>​		1.<code>activated</code> 路由组件被激活时触发。</p><p>​		2.<code>deactivated</code> 路由组件失活时触发。</p><h3 id=".路由守卫"><a class="docs-heading-anchor" href="#.路由守卫">12.路由守卫</a><a id=".路由守卫-1"></a><a class="docs-heading-anchor-permalink" href="#.路由守卫" title="Permalink"></a></h3><h4 id=".作用："><a class="docs-heading-anchor" href="#.作用：">1.作用：</a><a id=".作用：-1"></a><a class="docs-heading-anchor-permalink" href="#.作用：" title="Permalink"></a></h4><p>对路由进行权限控制</p><h4 id=".分类："><a class="docs-heading-anchor" href="#.分类：">2.分类：</a><a id=".分类：-1"></a><a class="docs-heading-anchor-permalink" href="#.分类：" title="Permalink"></a></h4><p>全局守卫、独享守卫、组件内守卫</p><h4 id=".全局守卫："><a class="docs-heading-anchor" href="#.全局守卫：">3.全局守卫：</a><a id=".全局守卫：-1"></a><a class="docs-heading-anchor-permalink" href="#.全局守卫：" title="Permalink"></a></h4><pre><code class="nohighlight hljs">// 全局前置路由守卫——初始化的时候被调用、每次路由切换之前被调用
router.beforeEach((to,from,next)=&gt;{
  console.log(to,from)
  // 这里用to.name===&#39;xinwen&#39; ||to.name=&#39;xiaoxi&#39;
  if(to.meta.isAuth){  
    if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){
    next()
  }else{
      alert(&#39;学校名不对，无权限查看!&#39;)}
  }else{
    next()
  }
})

// 全局后置路由守卫————初始化的时候被调用，每次路由切换之后被调用
router.afterEach((to,from)=&gt;{
  console.log(from)
  document.title = to.meta.title  || &#39;网页页面&#39;
})</code></pre><h4 id=".独享守卫"><a class="docs-heading-anchor" href="#.独享守卫">4.独享守卫</a><a id=".独享守卫-1"></a><a class="docs-heading-anchor-permalink" href="#.独享守卫" title="Permalink"></a></h4><pre><code class="nohighlight hljs"> beforeEnter:(to,from,next)=&gt;{
              console.log(to,from)
              // 这里用to.name===&#39;xinwen&#39; ||to.name=&#39;xiaoxi&#39;
              if(to.meta.isAuth){  
                if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){
                next()
              }else{
                  alert(&#39;学校名不对，无权限查看!&#39;)}
              }else{
                next()
              }
    }}</code></pre><p>独享守卫可以和全局路由后置守卫配合使用，但是独享守卫不可以与全局路由前置守卫一起使用，会发生覆盖的情况。</p><h4 id=".组件内守卫"><a class="docs-heading-anchor" href="#.组件内守卫">5.组件内守卫</a><a id=".组件内守卫-1"></a><a class="docs-heading-anchor-permalink" href="#.组件内守卫" title="Permalink"></a></h4><pre><code class="nohighlight hljs">// 通过路由规则，进入该组件时被调用
    beforeRouteEnter(to,from,next){
      console.log(to,from)
    if(to.meta.isAuth){  
      if(localStorage.getItem(&#39;school&#39;)===&#39;jiaoda&#39;){
      next()
    }else{
      alert(&#39;学校名不对，无权限查看!&#39;)}
    }else{
      next()
    }
    },

// 通过路由规则，离开该组件时被调用
    beforeRouteLeave(to,from,next){
      next()
    }</code></pre><h3 id=".路由器的两种工作模式"><a class="docs-heading-anchor" href="#.路由器的两种工作模式">13.路由器的两种工作模式</a><a id=".路由器的两种工作模式-1"></a><a class="docs-heading-anchor-permalink" href="#.路由器的两种工作模式" title="Permalink"></a></h3><p>1.对于一个url来说，什么是hash值？——#及其后面的内容就是hsah值</p><p>2.hsah值不会包含在HTTP请求中，即：hash值不会带给服务器。</p><p>3.hash模式：</p><p>​	1.地址中永远带着#好，不美观</p><p>​	2.若以后将地址通过第三方手机app分享，若app校验合格，则地址会被标记为不合法。</p><p>​	3.兼容性较好</p><p>4.history模式：</p><p>​	1.地址干净，美观</p><p>​	2.兼容性和hash模式相比略差</p><p>​	3.应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</p><h2 id=".Vue-UI组件库"><a class="docs-heading-anchor" href="#.Vue-UI组件库">6.Vue UI组件库</a><a id=".Vue-UI组件库-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue-UI组件库" title="Permalink"></a></h2><p>该部分无需笔记，直接看官方文档即可</p><h3 id=".移动端常用-UI-组件库"><a class="docs-heading-anchor" href="#.移动端常用-UI-组件库">1 .移动端常用 UI 组件库</a><a id=".移动端常用-UI-组件库-1"></a><a class="docs-heading-anchor-permalink" href="#.移动端常用-UI-组件库" title="Permalink"></a></h3><p>​	1.Vant https://youzan.github.io/vant </p><p>​	2.Cube UI https://didi.github.io/cube-ui </p><p>​	3.Mint UI http://mint-ui.github.io </p><h3 id=".PC-端常用-UI-组件库"><a class="docs-heading-anchor" href="#.PC-端常用-UI-组件库">2 .PC 端常用 UI 组件库</a><a id=".PC-端常用-UI-组件库-1"></a><a class="docs-heading-anchor-permalink" href="#.PC-端常用-UI-组件库" title="Permalink"></a></h3><ol><li>Element UI https://element.eleme.cn </li><li>IView UI https://www.iviewui.co</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../4-Vue2笔记/">« Vue2笔记</a><a class="docs-footer-nextpage" href="../6-Vue3笔记/">Vue3笔记 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 27 October 2023 15:34">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
