<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vue3笔记 · study notes</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/notes.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="study notes logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">study notes</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/1-第一个要解决的设计优化问题/">第一个要解决的设计优化问题</a></li></ul></li><li><span class="tocitem">Front_end</span><ul><li><a class="tocitem" href="../1-说说console/">说说console</a></li><li><a class="tocitem" href="../2-ES (EcmaScript)/">ES （EcmaScript）</a></li><li><a class="tocitem" href="../3-JavaScript/">JavaScript</a></li><li><a class="tocitem" href="../4-Vue2笔记/">Vue2笔记</a></li><li><a class="tocitem" href="../5-Vuex/">Vuex</a></li><li class="is-active"><a class="tocitem" href>Vue3笔记</a><ul class="internal"><li><a class="tocitem" href="#.引言"><span>1.引言</span></a></li><li><a class="tocitem" href="#.创建Vue3.0工程"><span>2.创建Vue3.0工程</span></a></li><li><a class="tocitem" href="#.常见Composition（组合式）-API"><span>3.常见Composition（组合式） API</span></a></li><li><a class="tocitem" href="#.其它-Composition-API"><span>4.其它 Composition API</span></a></li><li><a class="tocitem" href="#.Composition-API-的优势"><span>5.Composition API 的优势</span></a></li><li><a class="tocitem" href="#.新的组件"><span>6.新的组件</span></a></li><li><a class="tocitem" href="#.其他"><span>7.其他</span></a></li></ul></li></ul></li><li><span class="tocitem">Mac_share</span><ul><li><a class="tocitem" href="../../Mac_share/1-Mac环境变量的配置/">Mac环境变量的配置</a></li></ul></li><li><span class="tocitem">Web_build</span><ul><li><a class="tocitem" href="../../Web_build/1-这个个人笔记网站是如何构建的/">如何构建这样的网站</a></li></ul></li><li><span class="tocitem">Marxism_Principle</span><ul><li><a class="tocitem" href="../../Marxism_Principle/1-导言/">导言</a></li><li><a class="tocitem" href="../../Marxism_Principle/2-第一章 世界的物质性及发展规律/">第一章 世界的物质性及发展规律</a></li><li><a class="tocitem" href="../../Marxism_Principle/3-第二章 实践与认识及其发展规律/">第二章 实践与认识及其发展规律</a></li><li><a class="tocitem" href="../../Marxism_Principle/4-第三章 人类社会及其发展规律/">第三章 人类社会及其发展规律</a></li><li><a class="tocitem" href="../../Marxism_Principle/5-第四章 资本主义的本质及规律/">第四章 资本主义的本质及规律</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Front_end</a></li><li class="is-active"><a href>Vue3笔记</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vue3笔记</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ccchhhddd/study-notes/blob/main/docs/src/Front_end/6-Vue3笔记.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Vue3笔记"><a class="docs-heading-anchor" href="#Vue3笔记">Vue3笔记</a><a id="Vue3笔记-1"></a><a class="docs-heading-anchor-permalink" href="#Vue3笔记" title="Permalink"></a></h1><h2 id=".引言"><a class="docs-heading-anchor" href="#.引言">1.引言</a><a id=".引言-1"></a><a class="docs-heading-anchor-permalink" href="#.引言" title="Permalink"></a></h2><h3 id=".-3.0发布的地址："><a class="docs-heading-anchor" href="#.-3.0发布的地址：">1.  3.0发布的地址：</a><a id=".-3.0发布的地址：-1"></a><a class="docs-heading-anchor-permalink" href="#.-3.0发布的地址：" title="Permalink"></a></h3><p>https://github.com/vuejs/core/releases/tag/v3.0.0</p><h3 id=".-各个版本地址："><a class="docs-heading-anchor" href="#.-各个版本地址：">2.  各个版本地址：</a><a id=".-各个版本地址：-1"></a><a class="docs-heading-anchor-permalink" href="#.-各个版本地址：" title="Permalink"></a></h3><p>https://github.com/vuejs/core/tags</p><h3 id=".vue3提升的方面"><a class="docs-heading-anchor" href="#.vue3提升的方面">3.vue3提升的方面</a><a id=".vue3提升的方面-1"></a><a class="docs-heading-anchor-permalink" href="#.vue3提升的方面" title="Permalink"></a></h3><h4 id=".性能提升"><a class="docs-heading-anchor" href="#.性能提升">1.性能提升</a><a id=".性能提升-1"></a><a class="docs-heading-anchor-permalink" href="#.性能提升" title="Permalink"></a></h4><p>渲染更快，内存更小</p><h4 id=".源码升级"><a class="docs-heading-anchor" href="#.源码升级">2.源码升级</a><a id=".源码升级-1"></a><a class="docs-heading-anchor-permalink" href="#.源码升级" title="Permalink"></a></h4><p>1.使用Proxy代替defineProperty实现响应式</p><p>2.重写虚拟 DOM的实现和Tree-Shanking</p><h4 id=".拥抱TypeScript"><a class="docs-heading-anchor" href="#.拥抱TypeScript">3.拥抱TypeScript</a><a id=".拥抱TypeScript-1"></a><a class="docs-heading-anchor-permalink" href="#.拥抱TypeScript" title="Permalink"></a></h4><p>Vue3更好支持TypeScript    </p><p>TS是未来前端所驱</p><h4 id=".新的特性"><a class="docs-heading-anchor" href="#.新的特性">4.新的特性</a><a id=".新的特性-1"></a><a class="docs-heading-anchor-permalink" href="#.新的特性" title="Permalink"></a></h4><h5 id=".composition-API(组合API)"><a class="docs-heading-anchor" href="#.composition-API(组合API)">1.composition API(组合API)</a><a id=".composition-API(组合API)-1"></a><a class="docs-heading-anchor-permalink" href="#.composition-API(组合API)" title="Permalink"></a></h5><p>setup配置</p><p>ref与reactive</p><p>watch与watchEffect</p><p>provide与inject</p><h5 id=".新的内置组件"><a class="docs-heading-anchor" href="#.新的内置组件">2.新的内置组件</a><a id=".新的内置组件-1"></a><a class="docs-heading-anchor-permalink" href="#.新的内置组件" title="Permalink"></a></h5><p>Fragment</p><p>teleport</p><p>suspense</p><h5 id=".其他改变"><a class="docs-heading-anchor" href="#.其他改变">3.其他改变</a><a id=".其他改变-1"></a><a class="docs-heading-anchor-permalink" href="#.其他改变" title="Permalink"></a></h5><p>新的生命周期钩子</p><p>data选项应始终被声明为一个函数</p><p>移除keyCode支持作为v-on的修饰符</p><h2 id=".创建Vue3.0工程"><a class="docs-heading-anchor" href="#.创建Vue3.0工程">2.创建Vue3.0工程</a><a id=".创建Vue3.0工程-1"></a><a class="docs-heading-anchor-permalink" href="#.创建Vue3.0工程" title="Permalink"></a></h2><h3 id=".使用脚手架vue-cli创建"><a class="docs-heading-anchor" href="#.使用脚手架vue-cli创建">1.使用脚手架vue-cli创建</a><a id=".使用脚手架vue-cli创建-1"></a><a class="docs-heading-anchor-permalink" href="#.使用脚手架vue-cli创建" title="Permalink"></a></h3><p>官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</p><h3 id=".使用vite创建"><a class="docs-heading-anchor" href="#.使用vite创建">2.使用vite创建</a><a id=".使用vite创建-1"></a><a class="docs-heading-anchor-permalink" href="#.使用vite创建" title="Permalink"></a></h3><p>官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite</p><p>vite官网：https://vitejs.cn</p><p><strong>vite</strong>-新一代前端<strong>构建工具</strong>（grunt、gulp、webpack）</p><p>优势：1.开发环境中，无需打包操作，可快速冷启动</p><p>​			2.轻量快速的热重载（HMR）</p><p>​			3.真正的按需编译，不再等待整个应用编译完成。 <img src="../../assets/Front_end/image14.png" alt="img"/></p><pre><code class="nohighlight hljs">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev</code></pre><h2 id=".常见Composition（组合式）-API"><a class="docs-heading-anchor" href="#.常见Composition（组合式）-API">3.常见Composition（组合式） API</a><a id=".常见Composition（组合式）-API-1"></a><a class="docs-heading-anchor-permalink" href="#.常见Composition（组合式）-API" title="Permalink"></a></h2><h3 id=".拉开序幕的setup"><a class="docs-heading-anchor" href="#.拉开序幕的setup">1.拉开序幕的setup</a><a id=".拉开序幕的setup-1"></a><a class="docs-heading-anchor-permalink" href="#.拉开序幕的setup" title="Permalink"></a></h3><p><strong>1.理解：</strong>Vue3.0中一个新的配置项，值为一个函数</p><p><strong>2.setup是所有Composition API(组合API)&quot;表演的舞台&quot;</strong></p><p><strong>3.组件中所用到的：</strong>数据、方法等等，均要配置在setup中</p><p><strong>4.setup函数的两种返回值：</strong></p><p>​	1.若返回一个对象，则对象中的属性、方法，在模版中均可以直接使用。（重点关注！）</p><p>​	2.若返回一个渲染函数：则可以自定义渲染内容（了解）</p><p><strong>5.注意点：</strong></p><p>​	1.尽量不要与vue2.x配置混用</p><p>​		vue.x的配置可以访问setup中的属性、方法</p><p>​		但在setup中不能访问到Vue2.x配置（data、methos、computed...）</p><p>​		如有重名，setup优先</p><p>​	2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise,模版看不到return对象中的属性。（后期也可以返回一个promise实例，但需要suspense和异步组件的配合）</p><h3 id=".ref函数"><a class="docs-heading-anchor" href="#.ref函数">2.ref函数</a><a id=".ref函数-1"></a><a class="docs-heading-anchor-permalink" href="#.ref函数" title="Permalink"></a></h3><p><strong>作用：</strong>定义一个响应式的数据</p><p><strong>语法：</strong>const xxx=ref(initValue)</p><p>​		创建一个包含响应式数据的<strong>引用对象（reference对象,简称ref对象）</strong></p><p>​		JS中操作数据 xxx.value</p><p>​		模版中读取数据：不需要 .value , 直接： &lt;div&gt;{{xxx}}&lt;/div&gt;</p><p><strong>备注：</strong> 	接收的数据可以是：基本类型，也可以是对象类型</p><p>​	基本类型的数据：响应式依然是靠 Object.defineProperty() 的get与set完成的</p><p>​	对象类型的数据：内部“求助”了Vue3.0中的一个新函数——reactive函数 </p><h3 id=".reactive函数"><a class="docs-heading-anchor" href="#.reactive函数">3.reactive函数</a><a id=".reactive函数-1"></a><a class="docs-heading-anchor-permalink" href="#.reactive函数" title="Permalink"></a></h3><p>作用：定义一个<strong>对象类型</strong>的响应式函数（基本类型不要用它，要用<code>ref</code>函数）</p><p>语法：<code>const 代理对象 = reactive(源对象)</code>接收一个对象（或数组），返回一个<strong>代理对象（proxy对象）</strong></p><p>reactive定义的响应式数据是“深层次的”</p><p>内部基于ES6的proxy实现，通过代理对象操作源对象内部数据进行操作</p><h3 id=".-Vue3.0的响应式"><a class="docs-heading-anchor" href="#.-Vue3.0的响应式">4. Vue3.0的响应式</a><a id=".-Vue3.0的响应式-1"></a><a class="docs-heading-anchor-permalink" href="#.-Vue3.0的响应式" title="Permalink"></a></h3><p>通过Proxy(代理)：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除</p><p>通过Reflect(反射)：对被代理对象的属性进行操作</p><p>MDN文档中描述的Proxy与Reflect</p><pre><code class="language-html hljs">//模拟Vue3中实现响应式
    const p = new Proxy(person,{
        // 有人读取p的某个属性时调用
        get(target,propName){
            console.log(`有人读取p身上的${propName}属性`)
            return Reflect.get(target,propName)
        },
        // 有人修改p的某个属性、或给p追加某个属性时调用
        set(target,propName,value){
            console.log(`有人修改p身上的${propName}属性,我要去更新界面了`)
            Reflect.set(target,propName,value)
        },
        // 有人删除p的某个属性时调用
        deleteProperty(target,propName){
            console.log(`有人删除p身上的${propName}属性,我要去更新界面了`)
            return Reflect.deleteProperty(target,propName)
        }
    })</code></pre><h3 id=".reactive对比ref"><a class="docs-heading-anchor" href="#.reactive对比ref">5.reactive对比ref</a><a id=".reactive对比ref-1"></a><a class="docs-heading-anchor-permalink" href="#.reactive对比ref" title="Permalink"></a></h3><p>1.从定义数据角度对比：</p><p>​		ref用来定义：基本类型数据</p><p>​		reactive用来定义：对象（或数组）类型数据</p><p>​		备注：ref也可以用来定义对象（或数组）类型数据，它内部会自动通过reactive转为代理对象</p><p>2.从原理角度对比： 		ref通过object.defineProperty() 的get 与set来实现响应式（数据劫持）</p><p>​		reactive通过使用Proxy来实现响应式（数据劫持），并通过Reflect操作源对象内部的数据</p><p>3.从使用角度对比：</p><p>​		ref定义的数据：操作数据需要 .value,读取数据时模版中直接读取不需要.value</p><p>​		reactive定义的数据：操作数据与读取数据：均不需要 .value</p><h3 id=".setup的两个注意点"><a class="docs-heading-anchor" href="#.setup的两个注意点">6.setup的两个注意点</a><a id=".setup的两个注意点-1"></a><a class="docs-heading-anchor-permalink" href="#.setup的两个注意点" title="Permalink"></a></h3><h4 id=".setup执行的时机"><a class="docs-heading-anchor" href="#.setup执行的时机">1.setup执行的时机</a><a id=".setup执行的时机-1"></a><a class="docs-heading-anchor-permalink" href="#.setup执行的时机" title="Permalink"></a></h4><p>​		在beforeCreate之前执行一次，this是undefined</p><h4 id=".setup参数"><a class="docs-heading-anchor" href="#.setup参数">2.setup参数</a><a id=".setup参数-1"></a><a class="docs-heading-anchor-permalink" href="#.setup参数" title="Permalink"></a></h4><p>​		props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性</p><p>​		context:上下文对象</p><p>​					attrs:值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.atters</p><p>​					slots:收到的插槽内容，相当于this.slots</p><p>​					emit:分发自定义事件的函数，相当于this.emit</p><h3 id=".计算属性"><a class="docs-heading-anchor" href="#.计算属性">7.计算属性</a><a id=".计算属性-1"></a><a class="docs-heading-anchor-permalink" href="#.计算属性" title="Permalink"></a></h3><h4 id=".computed函数"><a class="docs-heading-anchor" href="#.computed函数">1.computed函数</a><a id=".computed函数-1"></a><a class="docs-heading-anchor-permalink" href="#.computed函数" title="Permalink"></a></h4><p>与Vue2.x中computed配置功能一致</p><p>写法：</p><pre><code class="language-js hljs">import {computed} from &#39;vue&#39;

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + &#39;-&#39; + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + &#39;-&#39; + person.lastName
        },
        set(value){
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}</code></pre><h4 id=".watch函数"><a class="docs-heading-anchor" href="#.watch函数">2.watch函数</a><a id=".watch函数-1"></a><a class="docs-heading-anchor-permalink" href="#.watch函数" title="Permalink"></a></h4><p><strong>与Vue2.x中watch配置功能一致</strong></p><p><strong>两个小“坑”：</strong></p><p>​	1.监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</p><p>​	2.监视reactive定义的响应式数据中某个属性时：deep配置有效。</p><pre><code class="language-js hljs">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log(&#39;sum变化了&#39;,newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
	console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log(&#39;person变化了&#39;,newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</code></pre><h4 id=".watchEffect函数"><a class="docs-heading-anchor" href="#.watchEffect函数">3.watchEffect函数</a><a id=".watchEffect函数-1"></a><a class="docs-heading-anchor-permalink" href="#.watchEffect函数" title="Permalink"></a></h4><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p><p>watchEffect有点像computed：</p><p>​		但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</p><p>​		而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</p><pre><code class="language-js hljs">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log(&#39;watchEffect配置的回调执行了&#39;)
})</code></pre><h3 id=".生命周期"><a class="docs-heading-anchor" href="#.生命周期">8.生命周期</a><a id=".生命周期-1"></a><a class="docs-heading-anchor-permalink" href="#.生命周期" title="Permalink"></a></h3><p><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="组件生命周期图示"/></p><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id=".自定义hook函数"><a class="docs-heading-anchor" href="#.自定义hook函数">9.自定义hook函数</a><a id=".自定义hook函数-1"></a><a class="docs-heading-anchor-permalink" href="#.自定义hook函数" title="Permalink"></a></h3><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p><p>类似于vue2.x中的mixin。</p><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p><h3 id=".toRef"><a class="docs-heading-anchor" href="#.toRef">10.toRef</a><a id=".toRef-1"></a><a class="docs-heading-anchor-permalink" href="#.toRef" title="Permalink"></a></h3><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p><p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p><h2 id=".其它-Composition-API"><a class="docs-heading-anchor" href="#.其它-Composition-API">4.其它 Composition API</a><a id=".其它-Composition-API-1"></a><a class="docs-heading-anchor-permalink" href="#.其它-Composition-API" title="Permalink"></a></h2><h3 id=".shallowReactive-与-shallowRef"><a class="docs-heading-anchor" href="#.shallowReactive-与-shallowRef">1.shallowReactive 与 shallowRef</a><a id=".shallowReactive-与-shallowRef-1"></a><a class="docs-heading-anchor-permalink" href="#.shallowReactive-与-shallowRef" title="Permalink"></a></h3><ul><li>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</li><li>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</li><li>什么时候使用?<ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h3 id=".readonly-与-shallowReadonly"><a class="docs-heading-anchor" href="#.readonly-与-shallowReadonly">2.readonly 与 shallowReadonly</a><a id=".readonly-与-shallowReadonly-1"></a><a class="docs-heading-anchor-permalink" href="#.readonly-与-shallowReadonly" title="Permalink"></a></h3><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h3 id=".toRaw-与-markRaw"><a class="docs-heading-anchor" href="#.toRaw-与-markRaw">3.toRaw 与 markRaw</a><a id=".toRaw-与-markRaw-1"></a><a class="docs-heading-anchor-permalink" href="#.toRaw-与-markRaw" title="Permalink"></a></h3><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h3 id=".customRef"><a class="docs-heading-anchor" href="#.customRef">4.customRef</a><a id=".customRef-1"></a><a class="docs-heading-anchor-permalink" href="#.customRef" title="Permalink"></a></h3><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><pre><code class="language-vue hljs">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from &#39;vue&#39;
	export default {
		name:&#39;Demo&#39;,
		setup(){
			// let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;</code></pre></li></ul><h3 id=".provide-与-inject"><a class="docs-heading-anchor" href="#.provide-与-inject">5.provide 与 inject</a><a id=".provide-与-inject-1"></a><a class="docs-heading-anchor-permalink" href="#.provide-与-inject" title="Permalink"></a></h3><ul><li><p>作用：实现<strong>祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><pre><code class="language-js hljs">setup(){
    ......
    let car = reactive({name:&#39;奔驰&#39;,price:&#39;40万&#39;})
    provide(&#39;car&#39;,car)
    ......
}</code></pre></li><li><p>后代组件中：</p><pre><code class="language-js hljs">setup(props,context){
    ......
    const car = inject(&#39;car&#39;)
    return {car}
    ......
}</code></pre></li></ol></li></ul><h3 id=".响应式数据的判断"><a class="docs-heading-anchor" href="#.响应式数据的判断">6.响应式数据的判断</a><a id=".响应式数据的判断-1"></a><a class="docs-heading-anchor-permalink" href="#.响应式数据的判断" title="Permalink"></a></h3><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id=".Composition-API-的优势"><a class="docs-heading-anchor" href="#.Composition-API-的优势">5.Composition API 的优势</a><a id=".Composition-API-的优势-1"></a><a class="docs-heading-anchor-permalink" href="#.Composition-API-的优势" title="Permalink"></a></h2><h3 id=".Options-API-存在的问题"><a class="docs-heading-anchor" href="#.Options-API-存在的问题">1.Options API 存在的问题</a><a id=".Options-API-存在的问题-1"></a><a class="docs-heading-anchor-permalink" href="#.Options-API-存在的问题" title="Permalink"></a></h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><p><img src="../../assets/Front_end/image1.image" alt="img"/></p><p><img src="../../assets/Front_end/image2.image" alt="img"/></p><h3 id=".Composition-API-的优势-2"><a class="docs-heading-anchor" href="#.Composition-API-的优势-2">2.Composition API 的优势</a><a class="docs-heading-anchor-permalink" href="#.Composition-API-的优势-2" title="Permalink"></a></h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><p><img src="../../assets/Front_end/image3.image" alt="img"/></p><p><img src="../../assets/Front_end/image4.image" alt="img"/></p><h2 id=".新的组件"><a class="docs-heading-anchor" href="#.新的组件">6.新的组件</a><a id=".新的组件-1"></a><a class="docs-heading-anchor-permalink" href="#.新的组件" title="Permalink"></a></h2><h3 id=".Fragment"><a class="docs-heading-anchor" href="#.Fragment">1.Fragment</a><a id=".Fragment-1"></a><a class="docs-heading-anchor-permalink" href="#.Fragment" title="Permalink"></a></h3><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id=".Teleport"><a class="docs-heading-anchor" href="#.Teleport">2.Teleport</a><a id=".Teleport-1"></a><a class="docs-heading-anchor-permalink" href="#.Teleport" title="Permalink"></a></h3><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</p><pre><code class="language-vue hljs">&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;</code></pre></li></ul><h3 id=".Suspense"><a class="docs-heading-anchor" href="#.Suspense">3.Suspense</a><a id=".Suspense-1"></a><a class="docs-heading-anchor-permalink" href="#.Suspense" title="Permalink"></a></h3><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><pre><code class="language-js hljs">import {defineAsyncComponent} from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))</code></pre></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><pre><code class="language-vue hljs">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;h3&gt;我是App组件&lt;/h3&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt;
                &lt;h3&gt;加载中.....&lt;/h3&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;
    &lt;/div&gt;
&lt;/template&gt;</code></pre></li></ul></li></ul><h2 id=".其他"><a class="docs-heading-anchor" href="#.其他">7.其他</a><a id=".其他-1"></a><a class="docs-heading-anchor-permalink" href="#.其他" title="Permalink"></a></h2><h3 id=".全局API的转移"><a class="docs-heading-anchor" href="#.全局API的转移">1.全局API的转移</a><a id=".全局API的转移-1"></a><a class="docs-heading-anchor-permalink" href="#.全局API的转移" title="Permalink"></a></h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><pre><code class="language-js hljs">//注册全局组件
Vue.component(&#39;MyButton&#39;, {
  data: () =&gt; ({
    count: 0
  }),
  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;&#39;
})

//注册全局指令
Vue.directive(&#39;focus&#39;, {
  inserted: el =&gt; el.focus()
})</code></pre></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</li></ul></li></ul><p><img src="../../assets/Front_end/image15.png" alt="img"/></p><h3 id=".其他改变-2"><a class="docs-heading-anchor" href="#.其他改变-2">2.其他改变</a><a class="docs-heading-anchor-permalink" href="#.其他改变-2" title="Permalink"></a></h3><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><pre><code class="language-css hljs">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}</code></pre></li><li><p>Vue3.x写法</p><pre><code class="language-css hljs">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}</code></pre></li></ul></li></ul><p><strong>移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p><p><strong>移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><pre><code class="language-vue hljs">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;</code></pre></li><li><p>子组件中声明自定义事件</p><pre><code class="language-vue hljs">&lt;script&gt;
  export default {
    emits: [&#39;close&#39;]
  }
&lt;/script&gt;</code></pre></li></ul><p><strong>移除</strong>过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../5-Vuex/">« Vuex</a><a class="docs-footer-nextpage" href="../../Mac_share/1-Mac环境变量的配置/">Mac环境变量的配置 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 29 October 2023 03:12">Sunday 29 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
