<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vue2笔记 · study-note</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/notes.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">study-note</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/1-第一个要解决的设计优化问题/">第一个要解决的设计优化问题</a></li></ul></li><li><span class="tocitem">Front_end</span><ul><li><a class="tocitem" href="../1-说说console/">说说console</a></li><li><a class="tocitem" href="../2-ES (EcmaScript)/">ES （EcmaScript）</a></li><li><a class="tocitem" href="../3-JavaScript/">JavaScript</a></li><li class="is-active"><a class="tocitem" href>Vue2笔记</a></li><li><a class="tocitem" href="../5-Vuex/">Vuex</a></li><li><a class="tocitem" href="../6-Vue3笔记/">Vue3笔记</a></li></ul></li><li><span class="tocitem">mac_share</span><ul><li><a class="tocitem" href="../../mac_share/1-Mac环境变量的配置/">Mac环境变量的配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Front_end</a></li><li class="is-active"><a href>Vue2笔记</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vue2笔记</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ccchhhddd/study-notes/blob/main/docs/src/Front_end/4-Vue2笔记.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Vue2笔记"><a class="docs-heading-anchor" href="#Vue2笔记">Vue2笔记</a><a id="Vue2笔记-1"></a><a class="docs-heading-anchor-permalink" href="#Vue2笔记" title="Permalink"></a></h1><p>nodejs</p><p>node express</p><p>webpack</p><h3 id=".Vue核心组件化编程"><a class="docs-heading-anchor" href="#.Vue核心组件化编程">1.Vue核心+组件化编程</a><a id=".Vue核心组件化编程-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue核心组件化编程" title="Permalink"></a></h3><h4 id=".初识Vue："><a class="docs-heading-anchor" href="#.初识Vue：">1.初识Vue：</a><a id=".初识Vue：-1"></a><a class="docs-heading-anchor-permalink" href="#.初识Vue：" title="Permalink"></a></h4><p>要点：</p><p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p><p>2.root容器里的代码符合html规范，只不过混入了一些特殊得Vue语法</p><p>3.root容器里的代码被称为[vue模版]</p><p>4.容器和实例一一对应</p><p>5.注意区分js表达式和js代码（语句）</p><p><strong>表达式：</strong>一个表达式会产生一个值，可以放在任何一个需要值的地方</p><p>(1).a</p><p>(2)a+b</p><p>(3)demo(1)</p><p>(4)x===y?&#39;a&#39;:&#39;b&#39;    [三目表达式]</p><p><strong>js代码（语句）</strong></p><p>(1)if(){}</p><p>(2)for(){}</p><h4 id=".模版语法"><a class="docs-heading-anchor" href="#.模版语法">2.模版语法</a><a id=".模版语法-1"></a><a class="docs-heading-anchor-permalink" href="#.模版语法" title="Permalink"></a></h4><p>v-bind ====&gt;简写为   ：</p><p>vue 模版语法有2大类：</p><p><strong>1.插值语法：</strong></p><p>功能：用于解析标签体内容</p><p>写法：{{xxx}},xxx是js表达式，且可以直接读取到data中的所有属性。</p><p><strong>2.指令语法：</strong></p><p>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）</p><p>举例：v-bind:href=&quot;xxx&quot;或简写为  :href=&quot;xxx&quot;，xxx同样要写js表达式且可以直接读取到data中的所有属性</p><p>备注：Vue中有很多的指令，且形式都是：v-????,此处我们只是拿v-bind举例子</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;模版语法&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;插值语法&lt;/h1&gt;
    &lt;h3&gt;你好，{{name}}&lt;/h3&gt;
    &lt;hr/&gt;
    &lt;h1&gt;指令语法&lt;/h1&gt;
    &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot;&gt;点我去百度&lt;/a&gt;
    &lt;a :href=&quot;school.url&quot;&gt;点我又去百度&lt;/a&gt;
    &lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&quot;#root&quot;,
        data:{
            name:&#39;chd&#39;,
            school:{
                name:&quot;chdchd&quot;,
                url:&quot;https://www.baidu.com/?tn=15007414_20_dg&quot;

            }
            
        }
    })
    &lt;/script&gt;
    
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".数据绑定"><a class="docs-heading-anchor" href="#.数据绑定">3.数据绑定</a><a id=".数据绑定-1"></a><a class="docs-heading-anchor-permalink" href="#.数据绑定" title="Permalink"></a></h4><p>Vue中有2种数据绑定方式：</p><p>1.单项绑定（v-bind）：数据只能从data流向页面。</p><p>2.双向绑定（v-model）:数据不仅能从data流向页面，还能从页面流向data</p><p>备注：</p><p>​	1.双向绑定一般都应用在表单类元素上（如：input、select等）</p><p>​	2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;数据绑定&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;!-- 普通写法 --&gt;
        单项数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;
        双项数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt;

        &lt;!-- 简写 --&gt;
        单项数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;
        双项数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;
        
        &lt;!-- 如下代码是错误的,因为v-model只能应用在表单类元素(输入类元素)上
        &lt;h2 v-model:x=&quot;name&quot;&gt;nihao&lt;/h2&gt; --&gt;
    &lt;/div&gt;
    
&lt;/body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&quot;chd&quot;
        }

    })
&lt;/script&gt;    
&lt;/html&gt;</code></pre><h4 id=".el与data的两种写法"><a class="docs-heading-anchor" href="#.el与data的两种写法">4.el与data的两种写法</a><a id=".el与data的两种写法-1"></a><a class="docs-heading-anchor-permalink" href="#.el与data的两种写法" title="Permalink"></a></h4><p>data与el的2种写法</p><h5 id=".el有2种写法"><a class="docs-heading-anchor" href="#.el有2种写法">1.el有2种写法</a><a id=".el有2种写法-1"></a><a class="docs-heading-anchor-permalink" href="#.el有2种写法" title="Permalink"></a></h5><p>（1） new Vue时候配置el属性</p><p>（2）先创建Vue实例，随后再通过vm.mount(&#39;#root&#39;)指定el的值</p><h5 id=".data有两种写法"><a class="docs-heading-anchor" href="#.data有两种写法">2.data有两种写法</a><a id=".data有两种写法-1"></a><a class="docs-heading-anchor-permalink" href="#.data有两种写法" title="Permalink"></a></h5><p>（1）对象式</p><p>（2）函数式</p><p>如何选择：组件运用时要用函数式</p><h5 id=".一个重要的原则："><a class="docs-heading-anchor" href="#.一个重要的原则：">3.一个重要的原则：</a><a id=".一个重要的原则：-1"></a><a class="docs-heading-anchor-permalink" href="#.一个重要的原则：" title="Permalink"></a></h5><p>由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;h1&gt;你好，{{name}}&lt;/h1&gt;
    &lt;/div&gt;
    
&lt;/body&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
        // const v = new Vue({
        //     //el:&#39;#root&#39;,//第一种写法
        //     data:{
        //         name:&#39;chd&#39;
        //     }
        // })
        // console.log(v)
        // v.$mount(&#39;#root&#39;)//第二种写法
        // 定时器演示
        // console.log(v)
        // setTimeout(() =&gt; {
        //     v.$mount(&#39;#root&#39;)
        // },1000);
    new Vue({
        el:&#39;#root&#39;,
        // //data的第一种写法：对象式
        // data:{
        //     name:&#39;hello&#39;
        // }
        
        //data的第二种写法：函数式（组件时必须使用）
        data:function(){
            console.log(&#39;@@@&#39;,this)
            return{
                name:&#39;chhd&#39;
            }
        }
    })
    &lt;/script&gt;
  
&lt;/html&gt;</code></pre><h4 id=".理解MVVM"><a class="docs-heading-anchor" href="#.理解MVVM">5.理解MVVM</a><a id=".理解MVVM-1"></a><a class="docs-heading-anchor-permalink" href="#.理解MVVM" title="Permalink"></a></h4><p><strong>vue的设计受到了MVVM的启发</strong></p><p><strong>MVVM模型：</strong></p><p>1.M:模型（Model）:对应data中的数据</p><p>2.V：试图（View）:模版</p><p>3.VM：视图模型（ViewModel）:Vue实例对象</p><p><strong>观察发现</strong></p><p>1.data中所有的属性，最后都出现在vm上</p><p>2.vm身上所有的属性，以及Vue原型上所有属性，在Vue模版中都可以直接使用</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt;
        &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt;  
        &lt;h1&gt;测试一下1:{{1+1}}&lt;/h1&gt;
        &lt;h1&gt;测试一下1:{{_c}}&lt;/h1&gt;
        &lt;!-- VIEW --&gt;
    &lt;/div&gt;
    
&lt;/body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    vm = new Vue({//VIEWMODEL
        el:&#39;#root&#39;,
        data:{
            name:&#39;hello&#39;,
            address:&#39;beijing&#39; //MODEL
        }
    })
    console.log(vm)
&lt;/script&gt;    
&lt;/html&gt;</code></pre><h4 id=".数据代理"><a class="docs-heading-anchor" href="#.数据代理">6.数据代理</a><a id=".数据代理-1"></a><a class="docs-heading-anchor-permalink" href="#.数据代理" title="Permalink"></a></h4><p><strong>1.回顾Object.defineProperty方法</strong></p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;回顾Object.defineProperty方法&lt;/title&gt;
    &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        
    &lt;/div&gt;
    
&lt;script type=&quot;text/javascript&quot;&gt;
    let number =20
    let person = {
        name:&#39;ss&#39;,
        sex:&#39;nan&#39;,
        
    }

    Object.defineProperty(person,&#39;age&#39;,{
        // value:18,
        // enumerable:true,//可枚举
        // writable:true,//可修改
        // configurable:true, //控制属性是否被删除 
        
        //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
        get:function(){
            return number
        },


        //当有人修改person的age属性时，set函数（setter）就会被调用，且会收到修改的具体值
        set(value){
            console.log(&#39;sss&#39;,value)
            number=value
        }
    })  
    console.log(Object.keys(person))
    console.log(person)
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><p><strong>2.何为数据代理</strong></p><p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;何为数据代理&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    let obj={x:100}
    let obj2={y:200}

    Object.defineProperty(obj2,&#39;x&#39;,{
      get(){
        return obj.x
      },
      set(value){
        obj.x = value
      }
      //简单来说就是通过改变obj2.x里的数改变了obj的x。这就是一个简单的数据代理
    })
&lt;/script&gt;
&lt;/body&gt;  
&lt;/html&gt;</code></pre><p><strong>3.Vue中的数据代理</strong></p><pre><code class="nohighlight hljs">数据代理就好比右图中的实线部分，实现的功能好比就是将data里的name和address放在vm里。这样在编写代码时更为方便，不用vm._data.name这样的写法，而直接vm.name即可。背后的逻辑也是实现了getter()和setter()的这样一个过程，也就是通过Object.defineProperty进行的实现。</code></pre><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm =new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;ccchhhddd&#39;,
            address:&#39;beijing&#39;
        }
        //埋一个数据劫持的坑
    })
&lt;/script&gt; 
&lt;/body&gt; 
&lt;/html&gt;</code></pre><h4 id=".事件处理"><a class="docs-heading-anchor" href="#.事件处理">7.事件处理</a><a id=".事件处理-1"></a><a class="docs-heading-anchor-permalink" href="#.事件处理" title="Permalink"></a></h4><h5 id="**1.事件的基本使用：**"><a class="docs-heading-anchor" href="#**1.事件的基本使用：**"><strong>1.事件的基本使用：</strong></a><a id="**1.事件的基本使用：**-1"></a><a class="docs-heading-anchor-permalink" href="#**1.事件的基本使用：**" title="Permalink"></a></h5><p>1.使用v-on：xxx 或 @xxx 绑定事件，其中xxx是事件名；</p><p>2.事件的回调需要配置在methods对象中，最终会在vm上；</p><p>3.methods中配置的函数，不要用箭头函数：否则this就不是vm了</p><p>4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；</p><p>5.@click=&quot;demo&quot; 和@click=&quot;demo&quot;(event)效果一致，但后者可以传参；</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;h2&gt;{{name}}欢迎你&lt;/h2&gt;
        &lt;button v-on:click=&quot;showInfo1&quot;&gt;点我提示信息（不传参）&lt;/button&gt;
        &lt;button v-on:click=&quot;showInfo2(66,$event)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;



    const vm=new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;Beijing&#39;
        },
        methods:{
            showInfo1(event){
                console.log(event.target)
                alert(&#39;nihao&#39;)
            },
            showInfo2(number,event){//最好别放在data里，会进行无意义的数据代理，这个东西只是用来被别人调用的
                console.log(number,event)
                alert(number)
            }
        }
    })
&lt;/script&gt; 
&lt;/body&gt; 
&lt;/html&gt;</code></pre><p><strong>补充概念：JavaScript事件的冒泡</strong></p><h5 id="事件冒泡的概念"><a class="docs-heading-anchor" href="#事件冒泡的概念">事件冒泡的概念</a><a id="事件冒泡的概念-1"></a><a class="docs-heading-anchor-permalink" href="#事件冒泡的概念" title="Permalink"></a></h5><p>事件冒泡是指当一个元素触发了某个事件（例如点击事件），该事件将从最内层的元素开始，逐级向外传播到父元素，直到传播到文档根节点。这种事件传播的过程就是事件冒泡。</p><h5 id="事件冒泡的处理方式"><a class="docs-heading-anchor" href="#事件冒泡的处理方式">事件冒泡的处理方式</a><a id="事件冒泡的处理方式-1"></a><a class="docs-heading-anchor-permalink" href="#事件冒泡的处理方式" title="Permalink"></a></h5><p>在处理事件冒泡时，有两种常用的方式：停止事件冒泡和使用事件委托。</p><h5 id="停止事件冒泡"><a class="docs-heading-anchor" href="#停止事件冒泡">停止事件冒泡</a><a id="停止事件冒泡-1"></a><a class="docs-heading-anchor-permalink" href="#停止事件冒泡" title="Permalink"></a></h5><p>通过停止事件冒泡，可以阻止事件继续向父元素传播。在事件处理函数中，可以使用event.stopPropagation()方法来停止事件冒泡。调用该方法后，事件将不再传播到父元素。</p><h5 id=".事件修饰符"><a class="docs-heading-anchor" href="#.事件修饰符">2.事件修饰符</a><a id=".事件修饰符-1"></a><a class="docs-heading-anchor-permalink" href="#.事件修饰符" title="Permalink"></a></h5><p>vue中的事件修饰符：</p><p>1.prevent:阻止默认事件（常用）</p><p>2.stop:阻止事件冒泡（常用）</p><p>3.once:事件只触发一次（常用）</p><p>4.capture：使用事件的捕获模式 </p><p>5.self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生</p><p>6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        /*  通配符*  */
        *{
            margin-top :20px;
        }
        .demo1{
            height: 50px;
            background-color: aqua;
        }
        .box1{
            padding: 5px;
            background-color: skyblue;
        }
        .box2{
            padding: 5px;
            background-color: orange;
        }
        .list{
            width:200px;
            height: 200px;
            background-color: peru;
            overflow: auto;
        }
        li{
           height: 100px; 
        }
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;!-- prevent:阻止默认事件（常用） --&gt;
        &lt;a href=&quot;https://www.baidu.com/?tn=15007414_20_dg&quot; @click.prevent=&quot;showInfo&quot;&gt;点击去{{name}}&lt;/a&gt;
        &lt;!--stop:阻止事件冒泡（常用） --&gt;
    &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
        &lt;button @click.stop=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;
    &lt;/div&gt;

    &lt;!--once:事件只触发一次（常用）  --&gt;
    &lt;button @click.once=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;
    &lt;!-- capture：使用事件的捕获模式 --&gt;
    &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt;
        div1
        &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt;
        div2   
        &lt;/div&gt;
    &lt;/div&gt;
   
    &lt;!-- self:只有event.target是当前操作的元素时才触发事件 这个案例相当于阻止了冒泡事件的发生 --&gt;
    &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt;
    &lt;button @click=&quot;showInfo&quot;&gt;点点试试&lt;/button&gt;
    &lt;/div&gt;
    &lt;!-- passive:事件的默认行为立即执行，无需等待事件回调执行完毕 --&gt;
    &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        &lt;li&gt;4&lt;/li&gt;
    &lt;/ul&gt;

    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;百度&#39;
        },
    methods:{
        showInfo(e){
            // e.stopPropagation()
            alert(&#39;同学你好&#39;)
            //console.log(e.target)
        },

        showMsg(msg){
            console.log(msg)
        },
        demo(){
            for (let i=0;i&lt;100000;i++){
                console.log(&#39;#&#39;)
            }
            console.log(&#39;wanle&#39;)
        }
    }
    })
&lt;/script&gt; 
&lt;/body&gt; 
&lt;/html&gt;</code></pre><h5 id=".键盘事件"><a class="docs-heading-anchor" href="#.键盘事件">3.键盘事件</a><a id=".键盘事件-1"></a><a class="docs-heading-anchor-permalink" href="#.键盘事件" title="Permalink"></a></h5><p><strong>1.vue中常用的按键别名：</strong></p><p>回车=&gt;enter</p><p>删除=&gt;delete(捕获“删除”和“退格键”)</p><p>退出=&gt;esc</p><p>空格=&gt;space</p><p>换行=&gt;tab</p><p>上=&gt;up</p><p>下=&gt;down</p><p>左=&gt;left</p><p>右=&gt;right</p><p><strong>2.Vue未提供别名的按键，</strong>可以使用按键原始的key值去绑定，但注意要转为kebab-case(短横线命名)</p><p><strong>3.系统修饰键（用法特殊）</strong>：ctrl、alt、shift、meta</p><p>​	(1)配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发</p><p>（2）配合keydown使用：正常触发事件</p><p><strong>4.也可以使用keyCode去指定具体的按键（不推荐）</strong></p><p><strong>5.Vue.config.keyCodes.自定义键名=键码，可以去定制按键别名</strong> （  直接关机键绑事件  【狗头】）</p><h5 id=".事件总结"><a class="docs-heading-anchor" href="#.事件总结">4.事件总结</a><a id=".事件总结-1"></a><a class="docs-heading-anchor-permalink" href="#.事件总结" title="Permalink"></a></h5><p>修饰符可以连写</p><p>例如：@keyup.ctrl.y   或者@click.stop.prevent</p><h4 id=".计算属性"><a class="docs-heading-anchor" href="#.计算属性">8.计算属性</a><a id=".计算属性-1"></a><a class="docs-heading-anchor-permalink" href="#.计算属性" title="Permalink"></a></h4><p><strong>计算属性：</strong></p><p>1.定义：要用的属性不存在，要通过已有属性计算得来</p><p>2.原理：底层借助了Object.defineproperty方法提供的getter和setter</p><p>3.get函数什么时候执行？</p><p>（1）初次读取时会执行一次</p><p>（2）当依赖的数据发生变化时会被再次调用</p><p>4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>5.备注：</p><p>​	1.计算属性最终会出现在vm上，直接读取使用即可</p><p>​	2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p><p>​	</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        测试：&lt;input type=&quot;text&quot; v-model=&quot;x&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue({
        el:&#39;#root&#39;,
        data:{
            firstname:&#39;张&#39;,
            lastname:&#39;三&#39;,
            x:&#39;你好&#39;
        },
        computed:{
            fullname:{
            //get有什么作用？当有人读取fullname时，get就会被调用，且返回值就作为fullname的值
            //get什么时候调用？1.初次读取fullname时2.所依赖的数据发生变化时
            get() {
                console.log(&#39;get被调用&#39;)
                //console.log(this)//此处的this=vm
                return this.firstname +&#39;-&#39;+ this.lastname
            },
            //set什么时候调用？当fullName被修改时
            set(value){
                console.log(&#39;set被调用&#39;,value)    
                const arr = value.split(&#39;-&#39;)
                this.firstname = arr[0]
                this.lastname = arr[1]
            } 
            }
        }
        
    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".监视属性"><a class="docs-heading-anchor" href="#.监视属性">9.监视属性</a><a id=".监视属性-1"></a><a class="docs-heading-anchor-permalink" href="#.监视属性" title="Permalink"></a></h4><h5 id=".监视属性watch:"><a class="docs-heading-anchor" href="#.监视属性watch:">1.监视属性watch:</a><a id=".监视属性watch:-1"></a><a class="docs-heading-anchor-permalink" href="#.监视属性watch:" title="Permalink"></a></h5><p>1.当被监视的属性变化时，回调函数自动调用，进行相关操作</p><p>2.监视的属性必须存在，才能进行监视</p><p>3.监视的两种写法;</p><p>（1）new Vue时传入watch配置</p><p>（2）通过vm.watch监视</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;   
    &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue({
        el:&#39;#root&#39;,
        data:{
            isHot:true,
        },
        computed:{
            info(){
                return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;
            }
        },
        methods: {
            cw(){
                this.isHot = ! this.isHot
            }
        },
        //监视的两个方法
        // watch:{
        //     isHot:{
        //     immediate:true,//初始化时让handler调用一下
        //     //handler什么时候调用？当isHot发生改变时。
        //     handler(newvalue,oldvalue){
        //         console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
        //     }    
        //     }
        // }

    })
    vm.$watch(&#39;isHot&#39;,{
        immediate:true,//初始化时让handler调用一下
            //handler什么时候调用？当isHot发生改变时。
            handler(newvalue,oldvalue){
                console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
            } 

    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".深度监视"><a class="docs-heading-anchor" href="#.深度监视">2.深度监视</a><a id=".深度监视-1"></a><a class="docs-heading-anchor-permalink" href="#.深度监视" title="Permalink"></a></h5><p><strong>要点：</strong></p><p>（1）Vue中的watch默认不监测对象内部值的改变（一层）</p><p>（2）配置deep:true可以监测对象内部值改变（多层）</p><p><strong>注：</strong></p><p>（1）Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以</p><p>（2）使用watch时根据数据的具体结构。决定是否采用深度监测</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;   
    &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;
    &lt;hr/&gt;
    &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt;
    &lt;button @click=&quot;numbers.a++&quot;&gt;点我让a+1&lt;/button&gt;
    &lt;h3&gt;a的值是:{{numbers.b}}&lt;/h3&gt;
    &lt;button @click=&quot;numbers.b++&quot;&gt;点我让b+1&lt;/button&gt;
    &lt;button @click=&quot;numbers = {a:666,b:888}&quot;&gt;彻底更换numbers&lt;/button&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue({
        el:&#39;#root&#39;,
        data:{
            isHot:true,
            numbers:{
             a:1,
             b:1  
            }
        },
        computed:{
            info(){
                return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;
            }
        },
        methods: {
            cw(){
                this.isHot = ! this.isHot
            }
        },
        //监视有两个方法
        //方法一
        watch:{
            isHot:{
            immediate:true,//初始化时让handler调用一下
            //handler什么时候调用？当isHot发生改变时。
            handler(newvalue,oldvalue){
                console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
            }
        }, 
            // 监视多级结构中某个属性的变化  
            &#39;numbers.a&#39;:{
                deep:true,
                handler(){
                    console.log(&#39;a被改变了&#39;)
                }
            }
        }
        
        //监视多级结构中所有属性的变化
        // numbers:{
        //         deep:true,
        //         handler(){
        //             console.log(&#39;numbers中有属性被改变了&#39;)
        //         }
        //     }   
        // }
        

    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".监视属性_简写"><a class="docs-heading-anchor" href="#.监视属性_简写">3.监视属性_简写</a><a id=".监视属性_简写-1"></a><a class="docs-heading-anchor-permalink" href="#.监视属性_简写" title="Permalink"></a></h5><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt;   
    &lt;button @click=&quot;cw&quot;&gt;切换天气&lt;/button&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue({
        el:&#39;#root&#39;,
        data:{
            isHot:true,
        },
        computed:{
            info(){
                return this.isHot ?&#39;炎热&#39;:&#39;凉爽&#39;
            }
        },
        methods: {
            cw(){
                this.isHot = ! this.isHot
            }
        },
        //监视有两个方法
        //方法一
        watch:{
            // isHot:{
            // //正常写法
            // immediate:true,//初始化时让handler调用一下
            // //handler什么时候调用？当isHot发生改变时。
            // //deep:true ,//深度监视
            // handler(newvalue,oldvalue){
            //     console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
            //         }
            //     }
        //简写
        // isHot(newvalue,oldvalue){
        //     console.log(&quot;isHot被修改&quot;,newvalue,oldvalue)
        // }
        }})
        //正常写法
        // vm.$watch(&#39;isHot&#39;,{immediate:true,//初始化时让handler调用一下
        //     // //handler什么时候调用？当isHot发生改变时。
        //     // //deep:true ,//深度监视
        //      handler(newvalue,oldvalue){
        //          console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
        //              }
        //          }

        // )
        //简写 
        vm.$watch(&#39;isHot&#39;,function(newvalue,oldvalue){
            console.log(&#39;info被修改了&#39;,newvalue,oldvalue)
        })
   
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".计算属性和监视属性的区别（computed和watch）"><a class="docs-heading-anchor" href="#.计算属性和监视属性的区别（computed和watch）">4.计算属性和监视属性的区别（computed和watch）</a><a id=".计算属性和监视属性的区别（computed和watch）-1"></a><a class="docs-heading-anchor-permalink" href="#.计算属性和监视属性的区别（computed和watch）" title="Permalink"></a></h5><p>1.computed能完成的功能，watch都可以完成</p><p>2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作</p><h5 id="**重要原则：**"><a class="docs-heading-anchor" href="#**重要原则：**"><strong>重要原则：</strong></a><a id="**重要原则：**-1"></a><a class="docs-heading-anchor-permalink" href="#**重要原则：**" title="Permalink"></a></h5><p>1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象</p><p>2.所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数、promise回调函数等），最好写成箭头函数，这样this的指向才是vm或组件实例对象。</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;姓名案例_watch实现&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        姓：&lt;input type=&quot;text&quot; v-model=&quot;firstname&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        名：&lt;input type=&quot;text&quot; v-model=&quot;lastname&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        姓名：&lt;span&gt;{{fullname}}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm = new Vue({
        el:&#39;#root&#39;,
        data:{
            firstname:&#39;张&#39;,
            lastname:&#39;三&#39;,
            fullname:&quot;张-三&quot;//初始值需要自己设定
        },
        watch:{
            firstname(newvalue){
                setTimeout(() =&gt; {//这个地方要写成箭头函数，括号里，没写东西，所以就往外找，this就指定为vm。否则指定为Windows，由js引擎帮忙调用
                    this.fullname = newvalue +&#39;-&#39; +this.lastname
                }, 1000);
                 
            },
            lastname(newvalue){
                this.fullname = this.firstname+&#39;-&#39; + newvalue
            },
            
            }
        }

           
        
        
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".绑定样式"><a class="docs-heading-anchor" href="#.绑定样式">10.绑定样式</a><a id=".绑定样式-1"></a><a class="docs-heading-anchor-permalink" href="#.绑定样式" title="Permalink"></a></h4><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .basic{
            width: 400px;
            height: 100px;
            border: 1px solid black;
        }
        .sad{
            border-color: green;
            background-color: gray;
        }
        .happy{
            border-color: red;
            background-color: yellow;
        }
        .normal{
            border-color: blue;
            background-color: brown;
        }
        .chd1{
            font-style: oblique;
        }
        .chd2{
            font-size: 30px;           
        }
        .chd3{
            border-color: skyblue;
        }
    &lt;/style&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;!-- 绑定class样式--字符串写法，适用于：样式的类别不确定，需要动态指定 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;change&quot;&gt;{{name}}&lt;/div&gt;
    &lt;/br&gt;&lt;/br&gt;
    &lt;!-- 绑定class样式--数组写法，适用于：适用于要样式个数不确定，名字也不确定 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;arr&quot; &gt;{{name}}&lt;/div&gt;
    &lt;/br&gt;&lt;/br&gt;
    &lt;!-- 绑定class样式--数组写法，适用于：适用于要绑定样式个数确定，名字也确定，但要动态决定用不用 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;classobj&quot;&gt;{{name}}&lt;/div&gt;
    &lt;/br&gt;&lt;/br&gt;
    &lt;!-- 绑定style样式--对象写法 --&gt;
    &lt;div class=&quot;basic&quot; :style=&quot;styleobj&quot;&gt;{{name}}&lt;/div&gt;
    
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    const vm=new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;ccchhhddd&#39;,
            mood:&quot;basic&quot;,
            arr:[&#39;chd1&#39;,&#39;chd2&#39;,&#39;chd3&#39;],
            classobj:{
                chd1:false,
                chd2:false,
            },
            styleobj:{
                fontSize:&#39;40px&#39;,
                color: &#39;red&#39;,
                backgroundColor:&#39;green&#39;
            }
        },
        methods: {
            change(){
                const arr =[&#39;happy&#39;,&#39;sad&#39;,&#39;normal&#39;]
                const index = Math.floor(Math.random()*3)
                this.mood = arr[index]
            }
            
        },
    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".条件渲染"><a class="docs-heading-anchor" href="#.条件渲染">11.条件渲染</a><a id=".条件渲染-1"></a><a class="docs-heading-anchor-permalink" href="#.条件渲染" title="Permalink"></a></h4><h5 id="**1.v-if**"><a class="docs-heading-anchor" href="#**1.v-if**"><strong>1.v-if</strong></a><a id="**1.v-if**-1"></a><a class="docs-heading-anchor-permalink" href="#**1.v-if**" title="Permalink"></a></h5><p>写法：</p><p>（1）v-if=&quot;表达式&quot;</p><p>（2）v-else-if=&quot;表达式&quot;</p><p>（3）v-else=&quot;表达式&quot;</p><p>适用于：切换频率较低的场景</p><p>特点：不展示的DOM元素直接被移除</p><p>注意：v-if可以和：v-else-if和v-else 一起使用。但要求结构不能被”打断“</p><h5 id="**2.v-show**"><a class="docs-heading-anchor" href="#**2.v-show**"><strong>2.v-show</strong></a><a id="**2.v-show**-1"></a><a class="docs-heading-anchor-permalink" href="#**2.v-show**" title="Permalink"></a></h5><p>写法：v-show=&quot;表达式&quot;</p><p>适用于：切换频率较高的场景</p><p>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p><h5 id="**3.备注:**"><a class="docs-heading-anchor" href="#**3.备注:**"><strong>3.备注:</strong></a><a id="**3.备注:**-1"></a><a class="docs-heading-anchor-permalink" href="#**3.备注:**" title="Permalink"></a></h5><p>使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt;
        &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
        &lt;!-- 使用v-show做条件渲染 --&gt;
        &lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到{{name}}&lt;/h2&gt;     --&gt;

        &lt;!-- 使用v-if做条件渲染 --&gt;
        &lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到{{name}}&lt;/h2&gt; --&gt;

        &lt;!-- 注意： v-if和v-else-if这组结构中间不允许被打断 --&gt;
        &lt;div v-if=&quot;n===1&quot;&gt;angular&lt;/div&gt;
        &lt;div v-else-if=&quot;n===2&quot;&gt;react&lt;/div&gt;
        &lt;div v-else-if=&quot;n===3&quot;&gt;Vue&lt;/div&gt;
        &lt;div v-else&gt;hhh&lt;/div&gt;
        

        &lt;!-- v-if和template的配合使用（不能和v-show） --&gt;
        &lt;template v-if=&quot;n===1&quot;&gt;
            &lt;h2&gt;你好&lt;/h2&gt;
            &lt;h2&gt;chd&lt;/h2&gt;
            &lt;h2&gt;hhh&lt;/h2&gt;
        &lt;/template&gt;

    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;chd&#39;,
            n:0
        }
    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".列表渲染"><a class="docs-heading-anchor" href="#.列表渲染">12.列表渲染</a><a id=".列表渲染-1"></a><a class="docs-heading-anchor-permalink" href="#.列表渲染" title="Permalink"></a></h4><h5 id=".基本列表"><a class="docs-heading-anchor" href="#.基本列表">1.基本列表</a><a id=".基本列表-1"></a><a class="docs-heading-anchor-permalink" href="#.基本列表" title="Permalink"></a></h5><h6 id="v-for指令："><a class="docs-heading-anchor" href="#v-for指令：">v-for指令：</a><a id="v-for指令：-1"></a><a class="docs-heading-anchor-permalink" href="#v-for指令：" title="Permalink"></a></h6><p>1.用于展示列表数据</p><p>2.语法：v-for=&quot;(item,index) in xxx&quot; :key=&#39;yyy&#39;</p><p>3.可遍历：数组、对象、字符串、指定次数</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
        &lt;!-- 遍历数组(用的最多) --&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;
            {{p.name}}-{{p.age}}
        &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历对象 --&gt;
    &lt;h2&gt;汽车信息&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;
            {{k}}-{{value}}
        &lt;/li&gt;
    &lt;/ul&gt;
    
    &lt;!-- 遍历字符串 --&gt;
    &lt;h2&gt;测试遍历字符串&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;
            {{index}}-{{char}}
        &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历指定次数 --&gt;
    &lt;h2&gt;测试遍历字符串&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;
            {{index}}-{{number}}
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            persons:[
                {id:&quot;001&quot;,name:&#39;张三&#39;,age:18},
                {id:&#39;002&#39;,name:&#39;李四&#39;,age:19},
                {id:&#39;003&#39;,name:&#39;王五&#39;,age:20}
            ],
            car:{
                name:&#39;奥迪A8&#39;,
                price:&#39;70万&#39;,
                color:&#39;red&#39;
            },
            str:&#39;hello&#39;

        }
    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".Vue面试重点题：vue中的key有什么作用？（key的内部原理）"><a class="docs-heading-anchor" href="#.Vue面试重点题：vue中的key有什么作用？（key的内部原理）">2.Vue面试重点题：vue中的key有什么作用？（key的内部原理）</a><a id=".Vue面试重点题：vue中的key有什么作用？（key的内部原理）-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue面试重点题：vue中的key有什么作用？（key的内部原理）" title="Permalink"></a></h5><h6 id=".虚拟DOM中key的作用："><a class="docs-heading-anchor" href="#.虚拟DOM中key的作用：">1.虚拟DOM中key的作用：</a><a id=".虚拟DOM中key的作用：-1"></a><a class="docs-heading-anchor-permalink" href="#.虚拟DOM中key的作用：" title="Permalink"></a></h6><p>​		key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p><h6 id=".对比规则;"><a class="docs-heading-anchor" href="#.对比规则;">2.对比规则;</a><a id=".对比规则;-1"></a><a class="docs-heading-anchor-permalink" href="#.对比规则;" title="Permalink"></a></h6><p>(1)旧虚拟DOM 中找到了与新虚拟DOM相同的key:</p><p>​		1）若虚拟DOM中的内容没变，直接使用之前的真实DOM</p><p>​		2）若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>（2）旧虚拟DOM中未找到与新虚拟DOM相同的key:</p><p>​		创建新的真实DOM，随后渲染到页面</p><h6 id=".用index作为key可能会引发的问题："><a class="docs-heading-anchor" href="#.用index作为key可能会引发的问题：">3.用index作为key可能会引发的问题：</a><a id=".用index作为key可能会引发的问题：-1"></a><a class="docs-heading-anchor-permalink" href="#.用index作为key可能会引发的问题：" title="Permalink"></a></h6><p>​		1）若对数据进行：逆序添加、逆序删除等破坏顺序操作：</p><p>​					会产生没有必要的真实DOM更新===》 界面效果没问题，但效率低</p><p>​		2）如果结构中还包含输入类的DOM：</p><p>​				会产生错误DOM更新 ===》界面有问题</p><h6 id=".开发中如何选择key?"><a class="docs-heading-anchor" href="#.开发中如何选择key?">4.开发中如何选择key?</a><a id=".开发中如何选择key?-1"></a><a class="docs-heading-anchor-permalink" href="#.开发中如何选择key?" title="Permalink"></a></h6><p>​		1.最好使用每条数据的唯一标识作为key,比如 id、手机号、身份证号、学号等唯一标识</p><p>​		2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p><h5 id=".列表过滤"><a class="docs-heading-anchor" href="#.列表过滤">3.列表过滤</a><a id=".列表过滤-1"></a><a class="docs-heading-anchor-permalink" href="#.列表过滤" title="Permalink"></a></h5><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;列表过滤&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;输入名字&quot; v-model=&quot;keyword&quot;&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;index&quot;&gt;
            {{p.name}}-{{p.age}}-{{p.sex}}
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;/div&gt;

   


&lt;script type=&quot;text/javascript&quot;&gt;
    // 用watch实现
    // new Vue({
    //     el:&#39;#root&#39;,
    //     data:{
    //         keyword:&#39;&#39;,
    //         persons:[
    //             {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
    //             {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
    //             {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
    //             {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;},
    //         ],
    //         filPersons:[]

    //     },
    //     watch:{
    //         keyword:{
    //             immediate:true,
    //             handler(val){
    //                 this.filPersons = this.persons.filter((p)=&gt;{
    //                 return p.name.indexOf(val) !==-1
    //             })
                
    //         }
    //         }
    //     }
    // })

    new Vue({
        el:&#39;#root&#39;,
        data:{
            keyword:&#39;&#39;,
            persons:[
                {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;},
                {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:20,sex:&#39;女&#39;},
                {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:21,sex:&#39;男&#39;},
                {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:22,sex:&#39;男&#39;},
             ],
        },
        computed:{
            filPersons(){
               return this.persons.filter((p)=&gt;{
                 return p.name.indexOf(this.keyword) !==-1   
                })
            }
        }          
        }
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id=".列表排序"><a class="docs-heading-anchor" href="#.列表排序">4.列表排序</a><a id=".列表排序-1"></a><a class="docs-heading-anchor-permalink" href="#.列表排序" title="Permalink"></a></h5><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;列表过滤&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;输入名字&quot; v-model=&quot;keyword&quot;&gt;
    &lt;button @click=&quot;sortType=2&quot;&gt;年龄升序&lt;/button&gt;
    &lt;button @click=&quot;sortType=1&quot;&gt;年龄降序&lt;/button&gt;
    &lt;button @click=&quot;sortType=0&quot;&gt;原顺序&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of filPersons&quot; :key=&quot;p.id&quot;&gt;
            {{p.name}}-{{p.age}}-{{p.sex}}
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;/div&gt;

   


&lt;script type=&quot;text/javascript&quot;&gt;
// 列表排序用computed实现
    new Vue({
        el:&#39;#root&#39;,
        data:{
            keyword:&#39;&#39;,
            sortType:0,//0原顺序，1降序，2升序
            persons:[
                {id:&quot;001&quot;,name:&#39;马冬梅&#39;,age:12,sex:&#39;女&#39;},
                {id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:11,sex:&#39;女&#39;},
                {id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:28,sex:&#39;男&#39;},
                {id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:50,sex:&#39;男&#39;},
             ],
        },
        computed:{
            filPersons(){
               const arr= this.persons.filter((p)=&gt;{
                 return p.name.indexOf(this.keyword) !==-1   
                })

                if(this.sortType){
                    arr.sort((p1,p2)=&gt;{
                        return this.sortType ===1 ? p2.age-p1.age :p1.age-p2.age
                    })
                }

                return arr
            }
        }          
        }
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id=".vue监测数据改变的原理"><a class="docs-heading-anchor" href="#.vue监测数据改变的原理">5.vue监测数据改变的原理</a><a id=".vue监测数据改变的原理-1"></a><a class="docs-heading-anchor-permalink" href="#.vue监测数据改变的原理" title="Permalink"></a></h5><p>data里的每一项数据（包括细分的数据）都有对应的getter和setter,以这样的方式实现数据的监测和修改</p><p><strong>如下图所示：</strong></p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
    &lt;/div&gt;
   
&lt;script type=&quot;text/javascript&quot;&gt;
// 列表排序用computed实现
    const vm =new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;chd&#39;,
            address:&quot;beijing&quot;,
            student:{
                name:&#39;tom&#39;,
                age:{
                    sage:20,
                    tage:18
                }
            }            
        },               
        }
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h5 id=".Vue.set的使用"><a class="docs-heading-anchor" href="#.Vue.set的使用">6.Vue.set的使用</a><a id=".Vue.set的使用-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue.set的使用" title="Permalink"></a></h5><p><strong>用法</strong>：</p><p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property</p><p>(比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</p><p><strong>注意：</strong></p><p>对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;
    &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
    &lt;hr/&gt;
    &lt;h1&gt;学生信息&lt;/h1&gt;
    &lt;button @click=&quot;addsex&quot;&gt;添加一个性别信息&lt;/button&gt;
    &lt;h2&gt;学生姓名：{{student.name}}&lt;/h2&gt;
    &lt;h2&gt;学生年龄：真实{{student.age.rage}},对外{{student.age.sage}}&lt;/h2&gt;
    &lt;h2 v-if=&quot;student.sex&quot;&gt;性别:{{student.sex}}&lt;/h2&gt;
    &lt;h2&gt;朋友们&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;
            {{f.name}}---{{f.age}}
        &lt;/li&gt;
    &lt;/div&gt;
   
&lt;script type=&quot;text/javascript&quot;&gt;
// 列表排序用computed实现
    const vm =new Vue({
        el:&#39;#root&#39;,
        data:{
            name:&#39;chd&#39;,
            address:&quot;beijing&quot;,
            student:{
                name:&#39;tom&#39;,
                age:{
                    sage:20,
                    rage:18
                },
                friends:[
                    {name:&#39;eecc&#39;,age:30},
                    {name:&#39;eveve&#39;,age:14}
                ]

                
            }            
        },
        methods: {
            addsex(){
                Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
                // this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
            }
        },               
        }
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".Vue监测数据改变的原理"><a class="docs-heading-anchor" href="#.Vue监测数据改变的原理">7.Vue监测数据改变的原理</a><a id=".Vue监测数据改变的原理-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue监测数据改变的原理" title="Permalink"></a></h5><p>Vue 将被侦听的数组的变更方法进行了<strong>包裹</strong>，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li><code>push()</code>	</li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><p>你可以打开控制台，然后对前面例子的 <code>items</code> 数组尝试调用变更方法。比如 <code>example1.items.push({ message: &#39;Baz&#39; })</code></p><h5 id=".总结Vue数据监测"><a class="docs-heading-anchor" href="#.总结Vue数据监测">8.总结Vue数据监测</a><a id=".总结Vue数据监测-1"></a><a class="docs-heading-anchor-permalink" href="#.总结Vue数据监测" title="Permalink"></a></h5><p>Vue监视数据的原理：</p><p><strong>1.Vue会监视data中所有层次的数据</strong></p><p><strong>2.如何监测对象的数据？</strong></p><p>​	通过setter实现监视，且要在new Vue时就传入要检测的数据</p><p>（1）对象中后追加的属性，Vue默认不做响应式处理</p><p>（2）如需给后添加的属性做响应式，请使用如下API: 			Vue.set(targer,propertyName,value)或</p><p>​			vm.set(target,propertyName/index,value)</p><p><strong>3.如何监测数组中的数据？</strong></p><p>​		通过包裹数组更新元素的方法实现，本质就是做了两件事：</p><p>​	（1）调用原生对应的方法对数组进行更新</p><p>​	（2）重新解析模版，进行更新页面</p><p><strong>4.在Vue修改数组中的某个元素一定要用如下方法：</strong></p><p>​	（1）使用这些API：push()  、pop() 、shift()  、unshift()  、splice()</p><p>​		(2)Vue.set()  或 vm.set()</p><p><strong>注意：</strong>Vue.set() 和vm.set() 不能给vm或vm的根数据对象 添加属性！！！</p><pre><code class="language-vue hljs">spilce() 的一个用法
this.student.hobby.splice(0,1,&#39;xc&#39;)
//Vue.set(this.student.hobby.0,&#39;xc&#39;)
//this.$set(this.student.hobby,0,&#39;xc&#39;)</code></pre><h4 id=".收集表单数据"><a class="docs-heading-anchor" href="#.收集表单数据">13.收集表单数据</a><a id=".收集表单数据-1"></a><a class="docs-heading-anchor-permalink" href="#.收集表单数据" title="Permalink"></a></h4><p><strong>若：&lt;input type=&#39;text&#39;/&gt;</strong>则v-model收集的是value值。用户输入就是value的值</p><p><strong>若：&lt;input type=&#39;radio&#39;/&gt;</strong>,则v-model收集的是value值，且要给标签配置value值</p><p><strong>若：&lt;input type=&#39;checkbox&#39;/&gt;</strong></p><p>​	1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是bool值）</p><p>​	2.v-model 的初始值是数组，那么收集的是value组成的数组</p><p><strong>备注：v-model的三个修饰符：</strong></p><p>​	lazy:失去焦点再收集数据</p><p>​	number:输入字符串转为有效数字</p><p>​	trim:输入收尾空格过滤</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
      &lt;form @submit.prevent=&quot;demo&quot;&gt;
        
        账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        性别：
        男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
        女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        爱好：
        学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
        打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;play&quot;&gt;
        唱歌&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;sing&quot;&gt;&lt;br/&gt;&lt;br/&gt;
        所属校区
        &lt;select v-model=&quot;userInfo.city&quot;&gt;
            &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
            &lt;option value=&quot;nanjing&quot;&gt;深圳&lt;/option&gt;
        &lt;/select&gt;&lt;br/&gt;&lt;br/&gt;
        其他信息： 
        &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;br/&gt;
        &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.baidu.com&quot;&gt;《用户协议》&lt;/a&gt;
        &lt;button&gt;提交&lt;/button&gt;
    &lt;/form&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            userInfo:{
            account:&#39;&#39;,
            password:&#39;&#39;,
            sex:&#39;&#39;,
            age:&#39;&#39;,
            hobby:[],
            city:&#39;&#39;,
            other:&#39;&#39;,
            agree:&#39;&#39;
        }
            
        },
        methods: {
            demo(){
               console.log(JSON.stringify(this.userInfo))
            }
        },
    })
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".过滤器"><a class="docs-heading-anchor" href="#.过滤器">14.过滤器</a><a id=".过滤器-1"></a><a class="docs-heading-anchor-permalink" href="#.过滤器" title="Permalink"></a></h4><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑得处理）</p><p>语法:</p><p>​	1.注册过滤器： Vue.filter(name,callback) 或 new Vue(filters:{})</p><p>​	2.使用过滤器：{{ xxx | 过滤器名}}  或 v-bind: 属性 = ‘xxx |过滤器名’</p><p>备注：</p><p>​	1.过滤器也可以接受额外参数，多个过滤器也可以串联</p><p>​	2.并没有改变原本的数据，是产生新的对应的数据</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/cdn.bootcdn.net_ajax_libs_dayjs_1.11.7_dayjs.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; 
     &lt;!--计算属性实现  --&gt;
    &lt;h3&gt; 1现在是:{{fmtTime}}&lt;/h3&gt;
    
    &lt;!--methods实现 --&gt;
    &lt;h3&gt; 2现在是:{{getfmtTime()}}&lt;/h3&gt;

    &lt;!--过滤器实现 --&gt;
    &lt;h3&gt; 3现在是:{{time | timeFormater}}&lt;/h3&gt;

    &lt;!--过滤器实现(传参+串联) --&gt;
    &lt;h3&gt; 4现在是:{{time | timeFormater(&#39;YYYY-MM-DD&#39;) | mySlice}}&lt;/h3&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    //全局过滤器
    // Vue.filters(&#39;mySlice&#39;,function(value){
    //     return value.slice(0,4)
    // })
    new Vue({
        el:&#39;#root&#39;,
        data:{
            time:1621561377603,//时间戳
        },
        computed:{
            fmtTime(){
                return dayjs(this.time).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)
            }
        },
        methods: {
            getfmtTime(){
                return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)
            }
        },
        //局部的过滤器
        filters:{
            timeFormater(value,str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;){
                return dayjs(value).format(str)
            },
            mySlice(value){
                return value.slice(0,4)
            }
        }
    }            
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".内置指令"><a class="docs-heading-anchor" href="#.内置指令">15.内置指令</a><a id=".内置指令-1"></a><a class="docs-heading-anchor-permalink" href="#.内置指令" title="Permalink"></a></h4><p><strong>v-bind :</strong> 单向绑定解析表达式，可简写为： xxx</p><p><strong>v-model :</strong> 双向数据绑定</p><p><strong>v-for :</strong> 遍历数组/对象/字符串</p><p><strong>v-on ：</strong> 绑定事件监听，可简写为@</p><p><strong>v-if :</strong> 条件渲染（动态控制节点是否存在）</p><p><strong>v-else :</strong> 条件渲染（动态控制节点是否存在）</p><p><strong>v-show :</strong> 条件渲染（动态控制节点是否展示）</p><p><strong>v-text指令：</strong></p><p>​	1.作用：向其所在的节点中渲染文本内容</p><p>​	2.与差值语法的区别：v-text会替换掉节点中的内容，{{xx}}不会</p><p><strong>v-html指令：</strong></p><p>1.作用：向指定节点中渲染包含html结构的内容</p><p>2.与差值语法的区别：</p><p>​	（1）v-html会替换掉节点中所有的内容，{{xx}}不会</p><p>​	（2）v-html可以识别html结构</p><p>3.严重注意：v-html有安全性问题</p><p>​	（1）在网站上动态渲染任意html是非常危险的，容易导致XSS攻击</p><p>​	（2）一定要在可信的内容上使用v-html。永远不要在用户提交的内容上用v-html</p><p><strong>补充cookie:</strong></p><p><strong>v-clock指令</strong>（没有值）：</p><p>​	1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-clock属性</p><p>​	2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p><p><strong>v-once指令：</strong></p><p>​	1.v-once所在节点在初次渲染后，被视为静态内容了</p><p>​	2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能</p><p><strong>v-pre指令：</strong></p><p>​	1.跳过其所在节点的编译过程</p><p>​	2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</p><h4 id=".自定义指令"><a class="docs-heading-anchor" href="#.自定义指令">16.自定义指令</a><a id=".自定义指令-1"></a><a class="docs-heading-anchor-permalink" href="#.自定义指令" title="Permalink"></a></h4><p>总结：</p><p>一、定义语法：</p><p>（1）局部指令：</p><p>​		new Vue({</p><p>​	directives:{指令名：配置对象}</p><p>})</p><p>或</p><p>new Vue({</p><p>​	directives{指令名：回调函数}</p><p>})</p><p>（2）全局指令</p><p>​	Vue.directive{指令名，配置对象） 或Vue.directive(指令名，回调函数)</p><p>二、配置对象中常用的3个回调：</p><p>​		（1）bind:指令与元素成功绑定时调用</p><p>​		（2）inserted:指令所在元素被插入页面时调用</p><p>​		（3）update:指令所在模版结构被重新解析时调用</p><p>三、备注：</p><p>​		1.指令定义时不加v-,但使用时要加v-;</p><p>​		2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名（驼峰命名法）。</p><pre><code class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍
         需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。 --&gt;
    &lt;div id =&quot;root&quot;&gt;
     &lt;h2&gt;当前的n值是:&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
     &lt;h2&gt;放大10倍后的n值是:&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
     &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
     &lt;hr/&gt;
     &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    new Vue({
        el:&#39;#root&#39;,
        data:{
            n:1,
        },
        directives:{
            //big函数何时会被调用？1.指令与元素成功绑定时（一上来）2.指令所在的模版被重新解析时
            big(element,binding){
                element.innerText = binding.value*10
                //console.log(element,binding.value)
            },
            fbind:{
                //指令与元素成功绑定时（一上来）
               bind(element,binding){
                element.value =binding.value
               },
               //指令所在元素被插入页面时
                inserted(element,binding){
                    element.focus()
                },
                //指令所在的模版被重新解析时
                update(element,binding){
                    element.value =binding.value 
                },
            }
            }
        }
    
            
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id=".生命周期"><a class="docs-heading-anchor" href="#.生命周期">17.生命周期</a><a id=".生命周期-1"></a><a class="docs-heading-anchor-permalink" href="#.生命周期" title="Permalink"></a></h4><p><strong>生命周期：</strong></p><p>1.又名：生命周期回调函数、生命周期函数、生命周期钩子</p><p>2.是什么：Vue在关键时刻帮助我们调用的一些特殊名称的函数</p><p>3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的</p><p>4.生命周期函数中的this指向是vm或组件实例对象	</p><p><strong>常用的生命周期钩子：</strong></p><p>1.mounted:发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】</p><p>2.beforeDestroy:清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】</p><p><strong>关于销毁Vue实例：</strong></p><p>1.销毁后借助Vue开发者工具看不到任何信息</p><p>2.销毁后自定义事件会失效，但原生DOM事件依然有效</p><p>3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p><p><strong>图示：</strong></p><p><img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"/></p><h4 id=".组件化编程"><a class="docs-heading-anchor" href="#.组件化编程">18.组件化编程</a><a id=".组件化编程-1"></a><a class="docs-heading-anchor-permalink" href="#.组件化编程" title="Permalink"></a></h4><h5 id="**1.Vue中使用组件的三大步骤：**"><a class="docs-heading-anchor" href="#**1.Vue中使用组件的三大步骤：**"><strong>1.Vue中使用组件的三大步骤：</strong></a><a id="**1.Vue中使用组件的三大步骤：**-1"></a><a class="docs-heading-anchor-permalink" href="#**1.Vue中使用组件的三大步骤：**" title="Permalink"></a></h5><p>1.定义组件（创建组件）</p><p>2.注册组件</p><p>3.使用组件</p><h5 id="**一、如何定义一个组件？**"><a class="docs-heading-anchor" href="#**一、如何定义一个组件？**"><strong>一、如何定义一个组件？</strong></a><a id="**一、如何定义一个组件？**-1"></a><a class="docs-heading-anchor-permalink" href="#**一、如何定义一个组件？**" title="Permalink"></a></h5><p>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但区别如下：</p><p>1.el不要写，为什么？</p><p>——最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器</p><p>2.data必须写成函数，为什么？</p><p>——避免组件被复用，数据存在引用关系</p><p>备注：使用template可以配置组件结构</p><h5 id="**二、如何注册组件？**"><a class="docs-heading-anchor" href="#**二、如何注册组件？**"><strong>二、如何注册组件？</strong></a><a id="**二、如何注册组件？**-1"></a><a class="docs-heading-anchor-permalink" href="#**二、如何注册组件？**" title="Permalink"></a></h5><p>1.局部注册：靠new Vue的时候传入components选项</p><p>2.全局注册：靠Vue.component(&#39;组件名&#39;，组件)</p><h5 id="**三、编写注册组件：**"><a class="docs-heading-anchor" href="#**三、编写注册组件：**"><strong>三、编写注册组件：</strong></a><a id="**三、编写注册组件：**-1"></a><a class="docs-heading-anchor-permalink" href="#**三、编写注册组件：**" title="Permalink"></a></h5><p>&lt;school&gt;&lt;/school&gt;</p><p><strong>1.基本使用.html</strong></p><pre><code class="nohighlight hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 准备好一个容器 --&gt;
    &lt;div id =&quot;root&quot;&gt;
   &lt;!-- 第三步:编写组件标签 --&gt;
    &lt;school&gt;&lt;/school&gt;
     &lt;hr&gt;
    &lt;student&gt;&lt;/student&gt;
    &lt;/div&gt;


&lt;script type=&quot;text/javascript&quot;&gt;
    //第一步：创建school组件
    const a =Vue.extend({
        //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理
        template:`
        &lt;div&gt;
        &lt;h2&gt;学校名称：{{schoolname}}&lt;/h2&gt;
        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
        &lt;button @click=&#39;showname&#39;&gt;点我提示学校名&lt;/button&gt;
        &lt;/div&gt;
        `,
        data(){//函数式
            return{
            schoolname:&#39;jiaoda&#39;,
            address:&#39;xian&#39;, 
            }},
            methods: {
                showname(){
                    alert(this.schoolname)
                }
            },

        }
    )
    //第二步：创建student组件
    const b =Vue.extend({
        
        //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理
        template:`
        &lt;div&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;
        &lt;/div&gt;
        `,
        data(){
            return{
            name:&#39;chd&#39;,
            age:20, 
            }}     
        }
    )


    //创建vm
    new Vue({
        el:&#39;#root&#39;,
        //第二步：注册组件（局部注册）
        components:{
            school:a,//组件名在这里定
            student:b
        }  }            
    )
&lt;/script&gt; 
&lt;/body&gt;
&lt;/html&gt;</code></pre><h5 id=".几个注意的要点"><a class="docs-heading-anchor" href="#.几个注意的要点">2.几个注意的要点</a><a id=".几个注意的要点-1"></a><a class="docs-heading-anchor-permalink" href="#.几个注意的要点" title="Permalink"></a></h5><p><strong>1.关于组件名：</strong></p><p>一个单词组成：</p><p>​	第一种写法（首字母小写）：school</p><p>​	第二种写法（首字母大写）：School</p><p>多个单词组成：</p><p>​	第一种写法（kebab-case命名）：my-school</p><p>​	第二种写法（CamelCase命名）：MySchool(需要Vue脚手架支持)</p><p>备注:</p><p>​	(1)组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行</p><p>（2）可以使用name配置项指定组件在开发者工具中呈现的名字</p><p><strong>2.关于组件标签</strong></p><p>​	第一种写法：&lt;school&gt;&lt;/school&gt;</p><p>​	第二种写法：&lt;school/&gt;</p><p>​	备注：不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。</p><p><strong>3.一个简写方式：</strong></p><p>const school =Vue.extend(options) 可简写为：const school = options</p><h5 id=".VueComponent"><a class="docs-heading-anchor" href="#.VueComponent">3.VueComponent</a><a id=".VueComponent-1"></a><a class="docs-heading-anchor-permalink" href="#.VueComponent" title="Permalink"></a></h5><p>关于VueComponent:</p><p>​	1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p><p>​	2.我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)</p><p>​	3.特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent !!!</p><p>​	4.关于this指向：</p><p>​		(1)组件配置中：</p><p>​				data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】</p><p>​	（2）new Vue(options)配置中：</p><p>​			data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】</p><p>​	5.VueComponent的实例对象、以后简称vc（也可称之为：组件实例对象）</p><p>Vue的实例对象，以后简称vm</p><p>​	6.因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。（vm和vc的异同）</p><h5 id=".一个重要的内置关系"><a class="docs-heading-anchor" href="#.一个重要的内置关系">4.一个重要的内置关系</a><a id=".一个重要的内置关系-1"></a><a class="docs-heading-anchor-permalink" href="#.一个重要的内置关系" title="Permalink"></a></h5><p>1.一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> ===Vue.prototype</p><p>2.为什么要有这个关系：让组件实例对象（vc）可以访问到Vue原型上的属性、方法</p><pre><code class="nohighlight hljs">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 准备好一个容器 --&gt;
    &lt;div id =&quot;root&quot;&gt;
    &lt;school&gt;&lt;/school&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.prototype.x=99//得益于VueComponent.prototype.__proto__ === Vue.prototype这个内置重要关系
   const school =Vue.extend({
        name:&#39;school&#39;,
        //el:&#39;#root&#39;,  //组件定义时，不要写el配置顶，因为最终所有的组件都要被一个vm管理
        template:`
        &lt;div&gt;
        &lt;h2&gt;学校名称：{{schoolname}}&lt;/h2&gt;
        &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;
        &lt;button @click=&#39;showX&#39;&gt;点我输出X&lt;/button&gt;  
        &lt;/div&gt;
        `,
        data(){//函数式
            return{
            schoolname:&#39;jiaoda&#39;,
            address:&#39;xian&#39;, 
            }},
        methods: {
            showX(){
            console.log(this.x)
            },
        },
    })
   const vm=new Vue({
    el:&#39;#root&#39;,
    data:{
        msg:&#39;你好&#39;
    },
    components:{
        school
    }
   })
   //console.log(school.prototype.__proto__ === Vue.prototype)
    // function Demo(){
    //     this.a=1
    //     this.b=2
    // }
    // //创建一个Demo的实例对象
    // const d= new Demo()
    
    // console.log(Demo.prototype) //显示原型属性
    // console.log(d.__proto__)//隐式原型属性

    // //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99
    // Demo.prototype.x = 99

    // console.log(&#39;@&#39;,d)

&lt;/script&gt; 

&lt;/html&gt;</code></pre><h3 id=".使用Vue脚手架"><a class="docs-heading-anchor" href="#.使用Vue脚手架">2.使用Vue脚手架</a><a id=".使用Vue脚手架-1"></a><a class="docs-heading-anchor-permalink" href="#.使用Vue脚手架" title="Permalink"></a></h3><h4 id=".单文件组件脚手架简介相关函数相关配置"><a class="docs-heading-anchor" href="#.单文件组件脚手架简介相关函数相关配置">1.单文件组件+脚手架简介+相关函数+相关配置</a><a id=".单文件组件脚手架简介相关函数相关配置-1"></a><a class="docs-heading-anchor-permalink" href="#.单文件组件脚手架简介相关函数相关配置" title="Permalink"></a></h4><p>xxxxx.Vue</p><p><strong>1.webpack</strong></p><p><strong>2.脚手架  Vue CLI  动能：浏览器不能直接识别并运行Vue文件，需要通过脚手架的环境配置的支持</strong></p><ol><li>Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）。</li><li>最新的版本是 4.x。</li><li>文档: https://cli.vuejs.org/zh/</li></ol><p><strong>3.模版目录框架</strong></p><p>├── node_modules</p><p>├── public </p><p>│ ├── favicon.ico: 页签图标</p><p>│ └── index.html: 主页面</p><p>├── src</p><p>│ ├── assets: 存放静态资源 </p><p>│ │└── logo.png </p><p>│ │── component: 存放组件</p><p>│ │ └── HelloWorld.vue</p><p>│ │── App.vue: 汇总所有组件</p><p>│ │── main.js: 入口文件</p><p>├── .gitignore: git 版本管制忽略的配置</p><p>├── babel.config.js: babel 的配置文件</p><p>├── package.json: 应用包配置文件</p><p>├── README.md: 应用描述文件</p><p>├── package-lock.json：包版本控制文件</p><p><strong>4.render函数</strong></p><p>关于不同版本的Vue：</p><p>​	1.vue.js与vue.runtime.xxx.js的区别：</p><p>​		（1）vue.js是完整版的Vue  包含：核心功能+模版解析器</p><p>​		（2） vue.runtime.xxx.js是运行版的Vue ,只包含：核心功能，没有模版解析器</p><p>​	2.因为vue.runtime.xxx.js没有模版解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。</p><pre><code class="nohighlight hljs">main.js文件
//该文件是整个项目的入口文件
//引入Vue（注意：这里引入的vue只是大的文件夹，并没有指定到核心的vue.js，所以仍需要在下方引入render函数，做模版解析）
import Vue from &#39;vue&#39;
//引入App组件，它是所有组件的父组件
import App from &#39;./App.vue&#39;
//关闭Vue的生产提示
Vue.config.productionTip = false

// 创建Vue的实例对象---vm
new Vue({
  el:&#39;#app&#39;,
  // 完成功能：将App组件放入容器中
  render: h =&gt; h(App),  //render函数只用在这里写一遍
})
</code></pre><p><strong>5.vue.config.js配置文件</strong></p><p>使用vue inspect  &gt; output.js 可以查看到Vue脚手架的默认配置</p><p>使用vue.config.js可以对脚手架进行<strong>个性化定制</strong>，详情见：https://cli.vuejs.org/zh/config/#vue-config-js</p><p><strong>6.ref属性</strong></p><p>1.被用来给元素或子组件注册引用信息（id的替代者）</p><p>2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</p><p>3.使用方式：</p><p>​		打标识：&lt;h1 ref=&#39;xxx&#39;&gt;.....&lt;/h1&gt;或&lt;School ref=&#39;xxx&#39;&gt;&lt;/SChool&gt;</p><p>​		获取：this.refs.xxx</p><p><strong>7.配置项props</strong></p><p>​	功能：让组件接收外部传来的数据</p><p>​		（1）传递数据：</p><p>​			&lt;Demo name =&#39;xxx&#39;/&gt;</p><p>​		（2）接收数据：</p><p>​			第一种方式（只接收）：		</p><pre><code class="nohighlight hljs"> props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]//简单声明接收。 这里写了，data里就不能有了 </code></pre><p>​			第二种方式（限制类型）：		</p><pre><code class="nohighlight hljs">// 接收的同时对数据进行类型限制
        // props:{
        //     name:String,
        //     age:Number,
        //     sex:String
        // }</code></pre><p>​				第三种方式（限制类型、限制必要性、指定默认值）：		</p><pre><code class="nohighlight hljs">props:{
            name:{
                type:String, //name的类型是字符串
                required:true //name是必要的
            },
            age:{
                type:Number,
                default:99 //默认值
            },
            sex:{
                type:String,
                require:true
            }
        }</code></pre><p><strong>备注：</strong>props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p><p>如下是一个名叫Student.vue的文件例子</p><pre><code class="nohighlight hljs">&lt;template&gt;
        &lt;div&gt;
        &lt;h1&gt;{{ msg }}&lt;/h1&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2&gt;学生年龄：{{Myage}}&lt;/h2&gt;
        &lt;button @click=&quot;chageage&quot;&gt;点我年龄++&lt;/button&gt;
        &lt;h2&gt;学生性别：{{sex}}&lt;/h2&gt;
        &lt;/div&gt;       
&lt;/template&gt;

&lt;script&gt;

    export default {
        name:&#39;MyStudent&#39;,   
        data(){//函数式
            return{
            msg:&#39;我是一名学生&#39;,
            Myage:this.age//这里利用的是props的优先级比data高实现的，也就是说程序先去扫描props里的数据。
            
            }},
            methods:{
                chageage(){
                    this.Myage++
                }
            },
        // props:[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;]//简单声明接收。 这里写了，data里就不能有了  

        // 接收的同时对数据进行类型限制
        // props:{
        //     name:String,
        //     age:Number,
        //     sex:String
        // }

        // 接收的同时对数据：进行类型限制+默认值的指定+必要性的限制
        props:{
            name:{
                type:String, //name的类型是字符串
                required:true //name是必要的
            },
            age:{
                type:Number,
                default:99 //默认值
            },
            sex:{
                type:String,
                require:true
            }
        }}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;</code></pre><p><strong>8.mixin(混入)</strong></p><p><strong>功能：</strong>可以把多个组件共用的配置提取成一个混入对象</p><p><strong>使用方法：</strong></p><p>​		第一步定义混合，例如：</p><p>{</p><p>data(){....},</p><p>methods:{....}</p><p>....</p><p>}</p><p>​	第二步使用混入，例如：</p><p>（1）全局混入：Vue.mixin(xxx)</p><p>（2）局部混入：mixins:[&#39;xxx&#39;]</p><p><strong>9.插件</strong></p><p><strong>功能：</strong>用于增强Vue</p><p><strong>本质：</strong>包含install方法的一个对象，install的第一个参数是Vue,第二个以后得参数是插件使用者传递的数据</p><p><strong>定义插件：</strong></p><pre><code class="nohighlight hljs">export default{
    install(Vue,x,y,z){
        console.log(x,y,z)

    //全局过滤器
    Vue.filter(&#39;mySlice&#39;,function(value){
        return value.slice(0,4)
    })
    //定义全局指令
    Vue.directive(&#39;fbind&#39;,{
        //指令与元素成功绑定时（一上来）
        bind(element,binding){
            element.value = binding.value
        },
    //指令所在元素被插入页面时
    inserted(element){
        element.focus()
    },
    //指令所在的模版被重新解析时
    update(element,binding){
        element.value = binding.value
    }
    })

    //定义混入
    Vue.mixin({
        data(){
            return{
                x:100,
                y:200
            }
        }
    })
    //给Vue原型上添加一个方法
    Vue.prototype.hello = ()=&gt;{alert(&#39;nihaoya&#39;)}
    //添加实例方法
    Vue.prototype.$myMethod = function(){...}
    Vue.prototype.$myProperty = xxxx
}
}
</code></pre><p><strong>使用插件：</strong>Vue.use()</p><h4 id=".scoped样式"><a class="docs-heading-anchor" href="#.scoped样式">2.scoped样式</a><a id=".scoped样式-1"></a><a class="docs-heading-anchor-permalink" href="#.scoped样式" title="Permalink"></a></h4><p>作用：让样式在局部生效，防止冲突</p><p>写法：&lt;style scoped&gt;</p><pre><code class="nohighlight hljs">&lt;template&gt;
        &lt;div class=&quot;demo&quot;&gt;
        &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;
        &lt;h2 class=&quot;qwe&quot;&gt;学生性别：{{sex}}&lt;/h2&gt;
        
        &lt;/div&gt;       
&lt;/template&gt;

&lt;script&gt;    
    export default {
        name:&#39;MyStudent&#39;,  
        data(){//函数式
            return{
            name:&#39;cccchhhhddd&#39;,
            sex:&#39;男&#39;
            }},
          
    
        }
&lt;/script&gt;

&lt;!-- 要用less 要安装less-loader 指令：npm i less-loader --&gt;
&lt;!-- 用less的好处：可以嵌套着写 --&gt;
&lt;style lang=&quot;less&quot; scoped&gt;
// 不写lang就默认是CSS
/* 加入scoped .demo就不担心存在重复的情况了,但此时demo只能在School组件里使用 */
.demo{
  background-color:pink;
  .qwe{
    font-size:40px;
  }
}
&lt;/style&gt;</code></pre><h4 id=".Todo-list案例"><a class="docs-heading-anchor" href="#.Todo-list案例">3.Todo-list案例</a><a id=".Todo-list案例-1"></a><a class="docs-heading-anchor-permalink" href="#.Todo-list案例" title="Permalink"></a></h4><p><strong>组件化编码流程（通用）</strong></p><p>1.实现静态组件：抽取组件，使用组件实现静态页面效果 </p><p>2.展示动态数据： 2.1. 数据的类型、名称是什么？ 2.2. 数据保存在哪个组件？ </p><p>3.交互——从绑定事件监听开始</p><p><strong>注：</strong>父亲给儿子可以传函数、数组.....在此基础上儿子调用先前父亲给儿子传的函数方法，儿子也可以给父亲传数据</p><h5 id="**总结todolist案例：**"><a class="docs-heading-anchor" href="#**总结todolist案例：**"><strong>总结todolist案例：</strong></a><a id="**总结todolist案例：**-1"></a><a class="docs-heading-anchor-permalink" href="#**总结todolist案例：**" title="Permalink"></a></h5><h5 id=".组件化编码流程："><a class="docs-heading-anchor" href="#.组件化编码流程：">1.组件化编码流程：</a><a id=".组件化编码流程：-1"></a><a class="docs-heading-anchor-permalink" href="#.组件化编码流程：" title="Permalink"></a></h5><p>​	（1）拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p><p>​	（2）实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p>​			1）一个组件再用：放在组件自身即可。</p><p>​			2)一些组件在用，放在他们共同的父组件上（状态提升）</p><p>​	（3）实现交互：从绑定事件开始</p><h5 id=".props适用于："><a class="docs-heading-anchor" href="#.props适用于：">2.props适用于：</a><a id=".props适用于：-1"></a><a class="docs-heading-anchor-permalink" href="#.props适用于：" title="Permalink"></a></h5><p>​	(1)父组件==&gt;子组件 通信</p><p>​	(2)子组件===&gt;父组件 通信 （要求父先给子一个函数）</p><h5 id=".使用v-model时要切记："><a class="docs-heading-anchor" href="#.使用v-model时要切记：">3.使用v-model时要切记：</a><a id=".使用v-model时要切记：-1"></a><a class="docs-heading-anchor-permalink" href="#.使用v-model时要切记：" title="Permalink"></a></h5><p>v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p><h5 id=".props传过来的若是对象类型的值："><a class="docs-heading-anchor" href="#.props传过来的若是对象类型的值：">4.props传过来的若是对象类型的值：</a><a id=".props传过来的若是对象类型的值：-1"></a><a class="docs-heading-anchor-permalink" href="#.props传过来的若是对象类型的值：" title="Permalink"></a></h5><p>修改对象中的属性时Vue不会报错，但不推荐这样做</p><h4 id=".webStorage（浏览器存储）"><a class="docs-heading-anchor" href="#.webStorage（浏览器存储）">4.webStorage（浏览器存储）</a><a id=".webStorage（浏览器存储）-1"></a><a class="docs-heading-anchor-permalink" href="#.webStorage（浏览器存储）" title="Permalink"></a></h4><p>1.存储大小一般支持5MB左右（不同浏览器不一样）</p><p>2.浏览器通过Window.sessionStorage和Window.localStorage 属性来实现本地存储机制</p><p>3.相关API</p><pre><code class="nohighlight hljs">1. xxxxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;);
该方法接受一个键和值作为参数，会把键值对添加到存储中，如果建名存在，则更新其对应的值
2.xxxxxxStorage.getItem(&#39;person&#39;);
该方法接受一个建名作为参数，返回键名对应的值
3.xxxxxxStorage.removeItem(&#39;key&#39;);
该方法接受一个建名作为参数，并把该建名从存储中删除
4.xxxxxxStorage.clear()
该方法会清空存储中的所有数据</code></pre><p>4.备注：</p><pre><code class="nohighlight hljs">1.SessionStorage存储的内容会随着浏览器窗口关闭而消失
2.LocalStorage存储的内容，需要手动清除才会消失
3.xxxxxxStorage.getItem(xxxx) 如果xxx对应的value获取不到，那么getItem的返回值是null
4.JSON.parse(null)的结果依然是null</code></pre><h4 id=".组件的自定义事件"><a class="docs-heading-anchor" href="#.组件的自定义事件">5.组件的自定义事件</a><a id=".组件的自定义事件-1"></a><a class="docs-heading-anchor-permalink" href="#.组件的自定义事件" title="Permalink"></a></h4><p>​	1.一种组件间通信的方式，适用于： 子组件==&gt;父组件</p><p>​	2.使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）</p><p>​	3.绑定自定义事件：</p><p>​		1.第一种方式，在父组件中：&lt;Demo @atguigu=&#39;test&#39;/&gt;  或&lt;Demo v-on:atguigu=&#39;test&#39;/&gt;</p><p>​		2.第二种方式，在父组件中：</p><pre><code class="nohighlight hljs">&lt;Demo ref=&#39;demo&#39;/&gt;
......
mounted(){
this.$refs.xxx.$on(&#39;atguigu&#39;,this.test)
}</code></pre><p>​		3.若想让自定义事件只能触发一次，可以使用once修饰符，或once方法</p><p>4.触发自定义事件：this.emit(&#39;atguigu&#39;,数据)</p><p>5.解绑自定义事件 this.off(&#39;atguigu&#39;)</p><p>6.组件上也可以绑定原生DOM事件，需要使用native修饰符</p><p>7.注意：通过 this.<span>$refs.xxx.$</span>on(&#39;atguigu&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题。【直接用function,this指的是xxx组件】</p><h4 id=".全局事件总线"><a class="docs-heading-anchor" href="#.全局事件总线">6.全局事件总线</a><a id=".全局事件总线-1"></a><a class="docs-heading-anchor-permalink" href="#.全局事件总线" title="Permalink"></a></h4><p>1.一种组件间通信的方式，适用于任意组件间通信</p><p>2.安装全局事件总线：</p><pre><code class="nohighlight hljs">new Vue({
  ......
  boforeCreate(){
    Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
        },
    .....
})</code></pre><p>3.使用事件总线：</p><p>​	1.接受数据：A组件想接收数据，则在A组件中给bus绑定自定义事件，事件的回调留在A组件自身</p><pre><code class="nohighlight hljs">methods(){
  demo(data){....}
}
......
mounted(){
  this.$bus.$on(&#39;xxxx&#39;,this.demo)
}</code></pre><p>​	2.提供数据：this.<span>$bus.$</span>emit(&#39;xxxx&#39;,数据)</p><p>4.最好在beforeDestroy钩子中，用off去解绑当前组件所用到的事件</p><p><strong>原理图：</strong></p><h4 id=".消息订阅与发布（pubsub）"><a class="docs-heading-anchor" href="#.消息订阅与发布（pubsub）">7.消息订阅与发布（pubsub）</a><a id=".消息订阅与发布（pubsub）-1"></a><a class="docs-heading-anchor-permalink" href="#.消息订阅与发布（pubsub）" title="Permalink"></a></h4><p>1.一种组件间通信的方式，适用于任意组件间通信</p><p>2.使用步骤：</p><p>​	1.安装pubsub：npm i pubsub-js</p><p>​	2.引入： import pubsub from &#39;pubsub-js&#39;</p><p>​	3.接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身</p><pre><code class="nohighlight hljs">methods(){
demo(data){....}
}
......
mounted(){
this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息
}</code></pre><p>​	4.提供数据： pubsub.publish(&#39;xxx&#39;,数据)</p><p>​	5.最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。</p><p><strong>原理图：</strong></p><h4 id=".nextTick"><a class="docs-heading-anchor" href="#.nextTick">8.nextTick</a><a id=".nextTick-1"></a><a class="docs-heading-anchor-permalink" href="#.nextTick" title="Permalink"></a></h4><p><strong>1.语法：</strong> this.nextTick(回调函数)</p><p><strong>2.作用：</strong> 在下一次DOM更新结束后执行其指定的回调</p><p><strong>3.什么时候用：</strong>当改变数据后，要<strong>基于更新后的新DOM进行某些操作时</strong>，要在nextTick所指定的回调函数中执行</p><pre><code class="nohighlight hljs">handleEdit(todo){
        
            if(&#39;isEdit&#39;== undefined){
                todo.isEdit = true
            }
            else{
                this.$set(todo,&#39;isEdit&#39;,true)
            }
            // 若没有外包一个东西的话，下面这行代码会执行，但是input还未出现，所以并没有显示相应的结果
            // 这是Vue在考虑效率时设置的形式。 异步？
            // $nextTick官方写法:
            this.$nextTick(function(){
                this.$refs.inputtitle.focus()
            })
            //或者 setTimeout(()=&gt;{
            // this.$refs.inputtitle.focus()
            // })
           },</code></pre><h4 id=".Vue封装的过度与动画"><a class="docs-heading-anchor" href="#.Vue封装的过度与动画">9.Vue封装的过度与动画</a><a id=".Vue封装的过度与动画-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue封装的过度与动画" title="Permalink"></a></h4><p>1.作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。</p><p>2.图示：</p><p>3.写法：</p><p>1.准备好样式：</p><p>​			元素进入的样式：</p><p>​					1.v-enter :进入的起点</p><p>​					2.v-enter-active:进入过程中</p><p>​					3.v-enter-to:进入的终点</p><p>​			元素离开时的样式：</p><p>​					1.v-leave:离开的起点</p><p>​					2.v-leave-active:离开过程中</p><p>​					3.v-leave-to:离开的终点</p><p>2.使用&lt;transition&gt;包裹要过度的元素，并配置name属性：</p><pre><code class="nohighlight hljs">&lt;transition name=&quot;hello&quot;&gt;
  &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;</code></pre><p>3.备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;,且每个元素都要指定key值</p><p>例子：</p><pre><code class="nohighlight hljs">&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;isShow = !isShow&quot;&gt; 显示/隐藏&lt;/button&gt;
    &lt;!--引入第三方动画 --&gt;
    &lt;transition-group
    appear 
    name=&quot;animate__animated animate__bounce&quot;  
    enter-active-class=&quot;animate__rubberBand&quot;
    leave-active-class=&quot;animate__backOutUp&quot;
    &gt;
        &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好哈哈哈哈！&lt;/h1&gt;
        &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;ccchhhddd&lt;/h1&gt;
    &lt;/transition-group&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#39;animate.css&#39;
export default {
    name:&#39;MyTest3&#39;,
    data(){
        return{
            isShow:true
        }
    }
}
&lt;/script&gt;

&lt;style scoped&gt;
    h1{
        background-color: orange;
    }
     
&lt;/style&gt;</code></pre><h3 id=".Vue中的ajax"><a class="docs-heading-anchor" href="#.Vue中的ajax">3.Vue中的ajax</a><a id=".Vue中的ajax-1"></a><a class="docs-heading-anchor-permalink" href="#.Vue中的ajax" title="Permalink"></a></h3><h4 id=".前端服务器相关文章与视频"><a class="docs-heading-anchor" href="#.前端服务器相关文章与视频">1.前端服务器相关文章与视频</a><a id=".前端服务器相关文章与视频-1"></a><a class="docs-heading-anchor-permalink" href="#.前端服务器相关文章与视频" title="Permalink"></a></h4><h5 id=".用Node.js搭建一个简单Web服务器"><a class="docs-heading-anchor" href="#.用Node.js搭建一个简单Web服务器">1.用Node.js搭建一个简单Web服务器</a><a id=".用Node.js搭建一个简单Web服务器-1"></a><a class="docs-heading-anchor-permalink" href="#.用Node.js搭建一个简单Web服务器" title="Permalink"></a></h5><p>https://blog.csdn.net/m0_46171043/article/details/132033934</p><h5 id=".【笔记】-node.js-开启本地服务器，返回json数据"><a class="docs-heading-anchor" href="#.【笔记】-node.js-开启本地服务器，返回json数据">2.【笔记】 node.js - 开启本地服务器，返回json数据</a><a id=".【笔记】-node.js-开启本地服务器，返回json数据-1"></a><a class="docs-heading-anchor-permalink" href="#.【笔记】-node.js-开启本地服务器，返回json数据" title="Permalink"></a></h5><p>https://blog.csdn.net/LawssssCat/article/details/103459796</p><h5 id=".FeHelper前端助手浏览器插件-chrome插件-Web开发者助手-FeHelper"><a class="docs-heading-anchor" href="#.FeHelper前端助手浏览器插件-chrome插件-Web开发者助手-FeHelper">3.FeHelper前端助手浏览器插件 chrome插件-Web开发者助手 FeHelper</a><a id=".FeHelper前端助手浏览器插件-chrome插件-Web开发者助手-FeHelper-1"></a><a class="docs-heading-anchor-permalink" href="#.FeHelper前端助手浏览器插件-chrome插件-Web开发者助手-FeHelper" title="Permalink"></a></h5><p>https://blog.csdn.net/A598853607/article/details/124118482</p><p>可以直接在谷歌应用商店里下载</p><h5 id=".【原生Ajax】全面了解xhr的概念与使用"><a class="docs-heading-anchor" href="#.【原生Ajax】全面了解xhr的概念与使用">4.【原生Ajax】全面了解xhr的概念与使用</a><a id=".【原生Ajax】全面了解xhr的概念与使用-1"></a><a class="docs-heading-anchor-permalink" href="#.【原生Ajax】全面了解xhr的概念与使用" title="Permalink"></a></h5><p>http://www.shouxieziti.cn/29383.html</p><p>xhr、jQuery现阶段用的比较少了，随着Vue和react框架的兴起axios用到比较多了</p><h5 id=".尚硅谷Web前端axios入门与源码解析（视频链接）"><a class="docs-heading-anchor" href="#.尚硅谷Web前端axios入门与源码解析（视频链接）">5.尚硅谷Web前端axios入门与源码解析（视频链接）</a><a id=".尚硅谷Web前端axios入门与源码解析（视频链接）-1"></a><a class="docs-heading-anchor-permalink" href="#.尚硅谷Web前端axios入门与源码解析（视频链接）" title="Permalink"></a></h5><p>https://www.bilibili.com/video/BV1wr4y1K7tq/?spm<em>id</em>from=333.337.search-card.all.click&amp;vd_source=ab1c31a8db0c1b9114896077df5b64aa</p><h4 id=".解决跨域问题"><a class="docs-heading-anchor" href="#.解决跨域问题">2.解决跨域问题</a><a id=".解决跨域问题-1"></a><a class="docs-heading-anchor-permalink" href="#.解决跨域问题" title="Permalink"></a></h4><p>协议、域名、端口号都对的上即不存在跨域问题</p><p>方法1：cors</p><p>方法2：jsonp(需要前后端配合，很巧妙)</p><p>方法3：配置代理服务器</p><p>1.nginx</p><p>2.vue-cli(下面用到的)</p><h5 id="方法一：在vue.config.js中添加如下配置"><a class="docs-heading-anchor" href="#方法一：在vue.config.js中添加如下配置">方法一：在vue.config.js中添加如下配置</a><a id="方法一：在vue.config.js中添加如下配置-1"></a><a class="docs-heading-anchor-permalink" href="#方法一：在vue.config.js中添加如下配置" title="Permalink"></a></h5><pre><code class="nohighlight hljs">devServer: {
    proxy: &#39;http://localhost:5000&#39;</code></pre><p>说明：</p><p>1.优点：配置简单，请求资源时直接发给前端（8080）即可。</p><p>2.缺点：不能配置多个代理，不能灵活的控制请求是否走代理</p><p>3.工作方式：若按照上述的代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）</p><p>方法二：编写vue.config.js配置具体代理规则：</p><pre><code class="nohighlight hljs">module.exports = defineConfig({
  // 开启代理服务器(方式2)
  devServer: {
    proxy: {
      &#39;/chd&#39;: {
        target: &#39;http://localhost:5000&#39;,
        pathRewrite:{&#39;^/chd&#39;:&#39;&#39;},
        ws: true,//用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值 
      },
      &#39;/demo&#39;: {
        target: &#39;http://localhost:5001&#39;,
        pathRewrite:{&#39;^/demo&#39;:&#39;&#39;},
        // ws: true,//用于支持websocket
        // changeOrigin: true //用于控制请求头中的host值 
      },
    }
  }
    // changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
  // changeOrigin设置为fasle时，服务器收到的请求头中的host为：localhost:8080
  // changeOrigin默认值为true
})
</code></pre><p>说明：</p><p>1.优点：可以配置多个代理，且可以灵活的控制请求是否走代理</p><p>2.缺点：配置略微繁琐，请求资源时必须加前缀</p><h4 id=".vue_github搜索案例"><a class="docs-heading-anchor" href="#.vue_github搜索案例">3.vue_github搜索案例</a><a id=".vue_github搜索案例-1"></a><a class="docs-heading-anchor-permalink" href="#.vue_github搜索案例" title="Permalink"></a></h4><p>https://blog.csdn.net/liaoai/article/details/123431352</p><p>上面链接里的案例没有用到main.js自身作为bus的全局事件总线</p><p>我后面进行了部分的简化可以省去不少的内容</p><h4 id=".插槽"><a class="docs-heading-anchor" href="#.插槽">4.插槽</a><a id=".插槽-1"></a><a class="docs-heading-anchor-permalink" href="#.插槽" title="Permalink"></a></h4><p>认识Vue中组件利器-插槽Slot-案例介绍</p><p>https://blog.csdn.net/JackieDYH/article/details/124481953</p><h5 id=".作用："><a class="docs-heading-anchor" href="#.作用：">1.作用：</a><a id=".作用：-1"></a><a class="docs-heading-anchor-permalink" href="#.作用：" title="Permalink"></a></h5><p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件==&gt;子组件</p><h5 id=".分类："><a class="docs-heading-anchor" href="#.分类：">2.分类：</a><a id=".分类：-1"></a><a class="docs-heading-anchor-permalink" href="#.分类：" title="Permalink"></a></h5><p>默认插槽、具名插槽、作用域插槽</p><h5 id=".使用方式："><a class="docs-heading-anchor" href="#.使用方式：">3.使用方式：</a><a id=".使用方式：-1"></a><a class="docs-heading-anchor-permalink" href="#.使用方式：" title="Permalink"></a></h5><h6 id=".默认插槽"><a class="docs-heading-anchor" href="#.默认插槽">1.默认插槽</a><a id=".默认插槽-1"></a><a class="docs-heading-anchor-permalink" href="#.默认插槽" title="Permalink"></a></h6><pre><code class="nohighlight hljs">父组件：
&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;美食&quot;&gt;
      &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;电影&quot;&gt;
      &lt;video controls src=&#39;./assets/shengqi.mp4&#39;&gt;&lt;/video&gt;
    &lt;/Category&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Category from &#39;./components/Category.vue&#39;
export default {
  name: &quot;App&quot;,
  components: { Category },
  data(){
    return{
      foods:[&#39;火锅&#39;,&#39;烧烤&#39;,&#39;小龙虾&#39;,&#39;牛排&#39;],
      games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],
      films:[&#39;《教父》&#39;,&#39;《星际穿越》&#39;,&#39;《变形金刚》&#39;,&#39;《盗梦空间》&#39;]

    }
  }
};
&lt;/script&gt;


子组件：
&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{ title }}分类&lt;/h3&gt;
    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;
    &lt;slot&gt;我是默认插槽，没有传递具体结构时，我会出现&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    name:&#39;MyCategory&#39;,
    props:[&#39;title&#39;]
}
&lt;/script&gt;

</code></pre><h6 id=".具名插槽"><a class="docs-heading-anchor" href="#.具名插槽">2.具名插槽</a><a id=".具名插槽-1"></a><a class="docs-heading-anchor-permalink" href="#.具名插槽" title="Permalink"></a></h6><pre><code class="nohighlight hljs">父组件：
&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;美食&quot;&gt;
      &lt;img slot=&quot;center&quot;  src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;
      &lt;a class=&quot;foot&quot;  slot=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt;
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;ul slot=&quot;center&quot;&gt;
        &lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;foot&quot; slot=&quot;footer&quot;&gt;
        &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;单机游戏&lt;/a&gt;
        &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;网络游戏&lt;/a&gt;
      &lt;/div&gt;      
    &lt;/Category&gt;

    &lt;Category title=&quot;电影&quot;&gt;
      &lt;video  slot=&quot;center&quot; controls src=&#39;./assets/shengqi.mp4&#39;&gt;&lt;/video&gt;
      &lt;template v-slot:footer&gt;
        &lt;div class=&quot;foot&quot;&gt;
        &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;经典&lt;/a&gt;
        &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;热门&lt;/a&gt;
        &lt;a solt=&quot;footer&quot;  href=&quot;https://baidu.com&quot;&gt;推荐&lt;/a&gt;
      &lt;/div&gt;
      &lt;h4&gt;欢迎前来观影&lt;/h4&gt;
      &lt;/template&gt;
      
    &lt;/Category&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Category from &#39;./components/Category.vue&#39;
export default {
  name: &quot;App&quot;,
  components: { Category },
  data(){
    return{
      foods:[&#39;火锅&#39;,&#39;烧烤&#39;,&#39;小龙虾&#39;,&#39;牛排&#39;],
      games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],
      films:[&#39;《教父》&#39;,&#39;《星际穿越》&#39;,&#39;《变形金刚》&#39;,&#39;《盗梦空间》&#39;]

    }
  }
};
&lt;/script&gt;




子组件：
&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{ title }}分类&lt;/h3&gt;
    &lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;
    &lt;slot name=&quot;center&quot;&gt;我是默认插槽，没有传递具体结构时，我会出现1&lt;/slot&gt;
    &lt;slot name=&quot;footer&quot;&gt;我是默认插槽，没有传递具体结构时，我会出现2&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    name:&#39;MyCategory&#39;,
    props:[&#39;title&#39;]
}
&lt;/script&gt;

</code></pre><h6 id=".作用域插槽："><a class="docs-heading-anchor" href="#.作用域插槽：">3.作用域插槽：</a><a id=".作用域插槽：-1"></a><a class="docs-heading-anchor-permalink" href="#.作用域插槽：" title="Permalink"></a></h6><p>​			1.理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</p><p>​			（games数据在category组件中，但使用数据所遍历出来的结构由App组件决定）</p><p>​			2.编码：	</p><pre><code class="nohighlight hljs">父组件:
&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;template scope=&quot;duixiang&quot;&gt;
        &lt;ul slot=&quot;center&quot;&gt;
          &lt;li v-for=&quot;(g,index) in duixiang.games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;     
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;!-- 解构赋值{} --&gt;
      &lt;template scope=&quot;{games}&quot;&gt;
        &lt;ol&gt;
          &lt;li style=&quot;color: red&quot; v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/template&gt;     
    &lt;/Category&gt;

    &lt;Category title=&quot;游戏&quot; &gt;
      &lt;!-- 解构赋值{} --&gt;
      &lt;template slot-scope=&quot;{games}&quot;&gt;
        &lt;h4 v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;{{g}}&lt;/h4&gt;     
      &lt;/template&gt;     
    &lt;/Category&gt;
    


  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Category from &#39;./components/Category.vue&#39;
export default {
  name: &quot;App&quot;,
  components: { Category },
  
};
&lt;/script&gt;


子组件：
&lt;template&gt;
  &lt;div class=&quot;category&quot;&gt;
    &lt;h3&gt;{{ title }}分类&lt;/h3&gt;
    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    name:&#39;MyCategory&#39;,
    props:[&#39;title&#39;],
    data(){
    return{
      games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;英雄联盟&#39;,&#39;刀塔&#39;],
    }
  }
}
&lt;/script&gt;
</code></pre><h5 id><a class="docs-heading-anchor" href="#"></a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h5></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3-JavaScript/">« JavaScript</a><a class="docs-footer-nextpage" href="../5-Vuex/">Vuex »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 27 October 2023 10:58">Friday 27 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
